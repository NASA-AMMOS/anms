--- ion-sf/Makefile.am	2023-05-30 10:55:36.645111430 -0400
+++ ion-anms/Makefile.am	2023-05-15 12:59:40.705868820 -0400
@@ -1629,7 +1629,7 @@
 	nm/agent/adm_amp_agent_agent.c \
 	nm/shared/adm/adm_init.c
 
-NM_ADM_INCLUDES = -I$(srcdir)/nm/shared/adm -I$(BP_SRC_DIR)/adm -I$(BP_SRC_DIR)
+NM_ADM_INCLUDES = -I$(srcdir)/nm/shared/adm -I$(BP_SRC_DIR)/nm/shared/adm -I$(BP_SRC_DIR)
 
 nm_agent_ADM_SOURCES = \
 	bpv6/adm/adm_bp_agent_impl.c \
@@ -2058,7 +2058,7 @@
 	ici/libbloom-master/bloom.h \
 	ici/libbloom-master/bloom.c \
 	ici/libbloom-master/murmur2/MurmurHash2.c
-	
+
 #########################################
 else
 libbp_la_SOURCES = \
@@ -2138,7 +2138,7 @@
 	bpv7/cgr/Unibo-CGR/core/msr/msr_utils.c \
 	bpv7/cgr/Unibo-CGR/core/bundles/bundles.c \
 	bpv7/cgr/Unibo-CGR/core/time_analysis/time.c
-	
+
 ####################################
 else
 libcgr_la_SOURCES = bpv7/cgr/libcgr.c
@@ -2618,15 +2618,15 @@
 	nm/agent/adm_amp_agent_agent.c \
 	nm/shared/adm/adm_init.c
 
-NM_ADM_INCLUDES = -I$(srcdir)/nm/shared/adm -I$(BP_SRC_DIR)/adm -I$(BP_SRC_DIR)
+NM_ADM_INCLUDES = -I$(srcdir)/nm/shared/adm -I$(BP_SRC_DIR)/nm/shared/adm -I$(BP_SRC_DIR)
 
 nm_agent_ADM_SOURCES = \
-	bpv7/adm/adm_bp_agent_impl.c \
-	bpv7/adm/adm_bp_agent_agent.c \
-	bpv7/adm/adm_bpsec_impl.c \
-	bpv7/adm/adm_bpsec_agent.c \
-	bpv7/adm/adm_ion_bp_admin_impl.c \
-	bpv7/adm/adm_ion_bp_admin_agent.c \
+	bpv7/nm/agent/adm_bp_agent_impl.c \
+	bpv7/nm/agent/adm_bp_agent_agent.c \
+	bpv7/nm/agent/adm_bpsec_impl.c \
+	bpv7/nm/agent/adm_bpsec_agent.c \
+	bpv7/nm/agent/adm_ion_bp_admin_impl.c \
+	bpv7/nm/agent/adm_ion_bp_admin_agent.c \
 	nm/agent/adm_ion_admin_agent.c \
 	nm/agent/adm_ion_admin_impl.c \
 	nm/agent/adm_ionsec_admin_impl.c \
@@ -2639,9 +2639,9 @@
 	nm/agent/adm_ltp_agent_agent.c
 
 nm_mgr_ADM_SOURCES = \
-	bpv7/adm/adm_bp_agent_mgr.c \
-	bpv7/adm/adm_bpsec_mgr.c \
-	bpv7/adm/adm_ion_bp_admin_mgr.c \
+	bpv7/nm/mgr/adm_bp_agent_mgr.c \
+	bpv7/nm/mgr/adm_bpsec_mgr.c \
+	bpv7/nm/mgr/adm_ion_bp_admin_mgr.c \
 	nm/mgr/adm_amp_agent_mgr.c \
 	nm/mgr/adm_ion_admin_mgr.c \
 	nm/mgr/adm_ionsec_admin_mgr.c \
@@ -2658,7 +2658,7 @@
 	$(top_builddir)/nm/doc/nm_mgr.1
 
 libampAgentADM_la_SOURCES = $(nm_agent_ADM_SOURCES)
-libampAgentADM_la_CFLAGS = -I/usr/include -I$(srcdir)/nm -I$(srcdir)/nm/shared/adm -I$(BP_SRC_DIR) -I$(BP_SRC_DIR)/library/ext/bpsec -I$(BP_SRC_DIR)/library -I$(srcdir)/ltp/library $(NM_CBOR_CFLAGS) $(AM_CFLAGS) $(NO_UNUSED_VARIABLE) 
+libampAgentADM_la_CFLAGS = -I/usr/include -I$(srcdir)/nm -I$(srcdir)/nm/shared/adm -I$(BP_SRC_DIR) -I$(BP_SRC_DIR)/nm/shared/adm -I$(BP_SRC_DIR)/library/ext/bpsec -I$(BP_SRC_DIR)/library -I$(srcdir)/ltp/library $(NM_CBOR_CFLAGS) $(AM_CFLAGS) $(NO_UNUSED_VARIABLE) 
 libampAgentADM_la_LIBADD = libamp.la libici.la $(bplib) libltp.la
 
 
@@ -3548,9 +3548,9 @@
 #
 ##########################
 
-DOC_VERSION_NUMBER := "4.1.1"
-DOC_VERSION_MAJOR := "4"
-DOC_VERSION_MINOR := "1.1"
+DOC_VERSION_NUMBER := $(shell cat $(srcdir)/$(BP_DIR)version.txt)
+DOC_VERSION_MAJOR := $(shell cat $(srcdir)/$(BP_DIR)version.txt | sed 's/\..*//')
+DOC_VERSION_MINOR := $(shell cat $(srcdir)/$(BP_DIR)version.txt | sed 's/[0-9]*\.//')
 DOC_DATE := $(shell date '+%Y-%m-%d')
 
 distribution: doc/ION-beginning.pdf doc/ION-manpages.ps
diff -ru --new-file ion-sf/bpv7/adm/adm_bp_agent_agent.c ion-anms/bpv7/adm/adm_bp_agent_agent.c
--- ion-sf/bpv7/adm/adm_bp_agent_agent.c	2023-05-30 10:55:36.705112198 -0400
+++ ion-anms/bpv7/adm/adm_bp_agent_agent.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,190 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bp_agent_agent.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_bp_agent.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "adm_bp_agent_impl.h"
-#include "agent/rda.h"
-
-
-
-#define _HAVE_DTN_BP_AGENT_ADM_
-#ifdef _HAVE_DTN_BP_AGENT_ADM_
-
-static vec_idx_t g_dtn_bp_agent_idx[11];
-
-void dtn_bp_agent_init()
-{
-	adm_add_adm_info("dtn_bp_agent", ADM_ENUM_DTN_BP_AGENT);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_META_IDX), &(g_dtn_bp_agent_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_RPTT_IDX), &(g_dtn_bp_agent_idx[ADM_RPTT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_EDD_IDX), &(g_dtn_bp_agent_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_CTRL_IDX), &(g_dtn_bp_agent_idx[ADM_CTRL_IDX]));
-
-
-	dtn_bp_agent_setup();
-	dtn_bp_agent_init_meta();
-	dtn_bp_agent_init_cnst();
-	dtn_bp_agent_init_edd();
-	dtn_bp_agent_init_op();
-	dtn_bp_agent_init_var();
-	dtn_bp_agent_init_ctrl();
-	dtn_bp_agent_init_mac();
-	dtn_bp_agent_init_rpttpl();
-	dtn_bp_agent_init_tblt();
-}
-
-void dtn_bp_agent_init_meta()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAME), dtn_bp_agent_meta_name);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAMESPACE), dtn_bp_agent_meta_namespace);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_VERSION), dtn_bp_agent_meta_version);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_ORGANIZATION), dtn_bp_agent_meta_organization);
-}
-
-void dtn_bp_agent_init_cnst()
-{
-
-}
-
-void dtn_bp_agent_init_edd()
-{
-
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_ID), dtn_bp_agent_get_bp_node_id);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_VERSION), dtn_bp_agent_get_bp_node_version);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_AVAILABLE_STORAGE), dtn_bp_agent_get_available_storage);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_LAST_RESET_TIME), dtn_bp_agent_get_last_reset_time);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_REGISTRATIONS), dtn_bp_agent_get_num_registrations);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_FWD), dtn_bp_agent_get_num_pend_fwd);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_DIS), dtn_bp_agent_get_num_pend_dis);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_IN_CUST), dtn_bp_agent_get_num_in_cust);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY), dtn_bp_agent_get_num_pend_reassembly);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY), dtn_bp_agent_get_bundles_by_priority);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY), dtn_bp_agent_get_bytes_by_priority);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY), dtn_bp_agent_get_src_bundles_by_priority);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY), dtn_bp_agent_get_src_bytes_by_priority);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES), dtn_bp_agent_get_num_fragmented_bundles);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED), dtn_bp_agent_get_num_fragments_produced);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON), dtn_bp_agent_get_num_failed_by_reason);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED), dtn_bp_agent_get_num_bundles_deleted);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES), dtn_bp_agent_get_failed_custody_bundles);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES), dtn_bp_agent_get_failed_custody_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES), dtn_bp_agent_get_failed_forward_bundles);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES), dtn_bp_agent_get_failed_forward_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BUNDLES), dtn_bp_agent_get_abandoned_bundles);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BYTES), dtn_bp_agent_get_abandoned_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BUNDLES), dtn_bp_agent_get_discarded_bundles);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BYTES), dtn_bp_agent_get_discarded_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_NAMES), dtn_bp_agent_get_endpoint_names);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE), dtn_bp_agent_get_endpoint_active);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON), dtn_bp_agent_get_endpoint_singleton);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_POLICY), dtn_bp_agent_get_endpoint_policy);
-}
-
-void dtn_bp_agent_init_op()
-{
-
-}
-
-void dtn_bp_agent_init_var()
-{
-
-}
-
-void dtn_bp_agent_init_ctrl()
-{
-
-	adm_add_ctrldef(g_dtn_bp_agent_idx[ADM_CTRL_IDX], DTN_BP_AGENT_CTRL_RESET_ALL_COUNTS, 0, dtn_bp_agent_ctrl_reset_all_counts);
-}
-
-void dtn_bp_agent_init_mac()
-{
-
-}
-
-void dtn_bp_agent_init_rpttpl()
-{
-
-	rpttpl_t *def = NULL;
-
-	/* FULL_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_dtn_bp_agent_idx[ADM_RPTT_IDX], DTN_BP_AGENT_RPTTPL_FULL_REPORT));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAME));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_VERSION));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_ID));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_VERSION));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_AVAILABLE_STORAGE));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_LAST_RESET_TIME));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_REGISTRATIONS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_FWD));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_DIS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_IN_CUST));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(4)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(4)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(4)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(4)));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(4)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(8)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(16)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(32)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(64)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(128)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(256)));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_NAMES));
-	adm_add_rpttpl(def);
-	/* ENDPOINT_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_bp_agent_idx[ADM_RPTT_IDX], DTN_BP_AGENT_RPTTPL_ENDPOINT_REPORT));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_POLICY, tnv_from_map(AMP_TYPE_STR, 0)));
-	adm_add_rpttpl(def);
-}
-
-void dtn_bp_agent_init_tblt()
-{
-
-}
-
-#endif // _HAVE_DTN_BP_AGENT_ADM_
diff -ru --new-file ion-sf/bpv7/adm/adm_bp_agent.h ion-anms/bpv7/adm/adm_bp_agent.h
--- ion-sf/bpv7/adm/adm_bp_agent.h	2023-05-30 10:55:36.705112198 -0400
+++ ion-anms/bpv7/adm/adm_bp_agent.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,290 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bp_agent.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-
-#ifndef ADM_BP_AGENT_H_
-#define ADM_BP_AGENT_H_
-#define _HAVE_DTN_BP_AGENT_ADM_
-#ifdef _HAVE_DTN_BP_AGENT_ADM_
-
-#include "shared/utils/nm_types.h"
-#include "shared/adm/adm.h"
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 ADM TEMPLATE DOCUMENTATION                                  +
- * +---------------------------------------------------------------------------------------------+
- *
- * ADM ROOT STRING:DTN/bp_agent
- */
-#define ADM_ENUM_DTN_BP_AGENT 2
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AGENT NICKNAME DEFINITIONS                                  +
- * +---------------------------------------------------------------------------------------------+
- */
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_BP_AGENT META-DATA DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |name                 |The human-readable name of the ADM.   |STR    |bp_agent                |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |namespace            |The namespace of the ADM.             |STR    |DTN/bp_agent            |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |version              |The version of the ADM                |STR    |v0.1                    |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |organization         |The name of the issuing organization o|       |                        |
- * |                     |f the ADM.                            |STR    |JHUAPL                  |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-// "name"
-#define DTN_BP_AGENT_META_NAME 0x00
-// "namespace"
-#define DTN_BP_AGENT_META_NAMESPACE 0x01
-// "version"
-#define DTN_BP_AGENT_META_VERSION 0x02
-// "organization"
-#define DTN_BP_AGENT_META_ORGANIZATION 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                      DTN_BP_AGENT EXTERNALLY DEFINED DATA DEFINITIONS                       +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |bp_node_id           |The node administration endpoint      |STR    |
- * +---------------------+--------------------------------------+-------+
- * |bp_node_version      |The latest version of the BP supported|       |
- * |                     | by this node                         |STR    |
- * +---------------------+--------------------------------------+-------+
- * |available_storage    |Bytes available for bundle storage    |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |last_reset_time      |The last time that BP counters were re|       |
- * |                     |set, either due to execution of a rese|       |
- * |                     |t control or a restart of the node its|       |
- * |                     |elf                                   |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |num_registrations    |number of registrations               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_pend_fwd         |number of bundles pending forwarding  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_pend_dis         |number of bundles awaiting dispatch   |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_in_cust          |number of bundles                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_pend_reassembly  |number of bundles pending reassembly  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |bundles_by_priority  |number of bundles for the given priori|       |
- * |                     |ty. Priority is given as a priority ma|       |
- * |                     |sk where Bulk=0x1, normal=0x2, express|       |
- * |                     |=0x4. Any bundles matching any of the |       |
- * |                     |masked priorities will be included in |       |
- * |                     |the returned count                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |bytes_by_priority    |number of bytes of the given priority.|       |
- * |                     | Priority is given as a priority mask |       |
- * |                     |where bulk=0x1, normal=0x2, express=0x|       |
- * |                     |4. Any bundles matching any of the mas|       |
- * |                     |ked priorities will be included in the|       |
- * |                     | returned count.                      |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |src_bundles_by_priori|number of bundles sourced by this node|       |
- * |                     | of the given priority. Priority is gi|       |
- * |                     |ven as a priority mask where bulk=0x1,|       |
- * |                     | normal=0x2, express=0x4. Any bundles |       |
- * |                     |sourced by this node and matching any |       |
- * |                     |of the masked priorities will be inclu|       |
- * |                     |ded in the returned count.            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |src_bytes_by_priority|number of bytes sourced by this node o|       |
- * |                     |f the given priority. Priority is give|       |
- * |                     |n as a priority mask where bulk=0x1, n|       |
- * |                     |ormal=0x2, express=0x4. Any bundles so|       |
- * |                     |urced by this node and matching any of|       |
- * |                     | the masked priorities will be include|       |
- * |                     |d in the returned count               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fragmented_bundle|number of fragmented bundles          |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fragments_produce|number of bundles with fragmentary pay|       |
- * |                     |loads produced by this node           |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_failed_by_reason |number of bundles failed for any of th|       |
- * |                     |e given reasons. (noInfo=0x1, Expired=|       |
- * |                     |0x2, UniFwd=0x4, Cancelled=0x8, NoStor|       |
- * |                     |age=0x10, BadEID=0x20, NoRoute=0x40, N|       |
- * |                     |oContact=0x80, BadBlock=0x100)        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bundles_deleted  |number of bundles deleted by this node|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |failed_custody_bundle|number of bundle fails at this node   |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |failed_custody_bytes |number bytes of fails at this node    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |failed_forward_bundle|number bundles not forwarded by this n|       |
- * |                     |ode                                   |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |failed_forward_bytes |number of bytes not forwaded by this n|       |
- * |                     |ode                                   |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |abandoned_bundles    |number of bundles abandoned by this no|       |
- * |                     |de                                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |abandoned_bytes      |number of bytes abandoned by this node|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |discarded_bundles    |number of bundles discarded by this no|       |
- * |                     |de                                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |discarded_bytes      |number of bytes discarded by this node|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |endpoint_names       |CSV list of endpoint names for this no|       |
- * |                     |de                                    |STR    |
- * +---------------------+--------------------------------------+-------+
- * |endpoint_active      |is the given endpoint active? (0=no)  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |endpoint_singleton   |is the given endpoint singleton? (0=no|       |
- * |                     |)                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |endpoint_policy      |Does the endpoint abandon on fail (0=n|       |
- * |                     |o)                                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_BP_AGENT_EDD_BP_NODE_ID 0x00
-#define DTN_BP_AGENT_EDD_BP_NODE_VERSION 0x01
-#define DTN_BP_AGENT_EDD_AVAILABLE_STORAGE 0x02
-#define DTN_BP_AGENT_EDD_LAST_RESET_TIME 0x03
-#define DTN_BP_AGENT_EDD_NUM_REGISTRATIONS 0x04
-#define DTN_BP_AGENT_EDD_NUM_PEND_FWD 0x05
-#define DTN_BP_AGENT_EDD_NUM_PEND_DIS 0x06
-#define DTN_BP_AGENT_EDD_NUM_IN_CUST 0x07
-#define DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY 0x08
-#define DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY 0x09
-#define DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY 0x0a
-#define DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY 0x0b
-#define DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY 0x0c
-#define DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES 0x0d
-#define DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED 0x0e
-#define DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON 0x0f
-#define DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED 0x10
-#define DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES 0x11
-#define DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES 0x12
-#define DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES 0x13
-#define DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES 0x14
-#define DTN_BP_AGENT_EDD_ABANDONED_BUNDLES 0x15
-#define DTN_BP_AGENT_EDD_ABANDONED_BYTES 0x16
-#define DTN_BP_AGENT_EDD_DISCARDED_BUNDLES 0x17
-#define DTN_BP_AGENT_EDD_DISCARDED_BYTES 0x18
-#define DTN_BP_AGENT_EDD_ENDPOINT_NAMES 0x19
-#define DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE 0x1a
-#define DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON 0x1b
-#define DTN_BP_AGENT_EDD_ENDPOINT_POLICY 0x1c
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                              DTN_BP_AGENT VARIABLE DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               DTN_BP_AGENT REPORT DEFINITIONS                               +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |full_report          |This is all known meta-data, EDD, and |       |
- * |                     |VAR values known by the agent.        |TNVC   |
- * +---------------------+--------------------------------------+-------+
- * |endpoint_report      |This is all known endpoint information|TNVC   |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_BP_AGENT_RPTTPL_FULL_REPORT 0x00
-#define DTN_BP_AGENT_RPTTPL_ENDPOINT_REPORT 0x01
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               DTN_BP_AGENT TABLE DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                              DTN_BP_AGENT CONTROL DEFINITIONS                               +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |reset_all_counts     |This control causes the Agent to reset|       |
- * |                     | all counts associated with bundle or |       |
- * |                     |byte statistics and to set the last re|       |
- * |                     |set time of the BP primitive data to t|       |
- * |                     |he time when the control was run      |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_BP_AGENT_CTRL_RESET_ALL_COUNTS 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                              DTN_BP_AGENT CONSTANT DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               DTN_BP_AGENT MACRO DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                              DTN_BP_AGENT OPERATOR DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-/* Initialization functions. */
-void dtn_bp_agent_init();
-void dtn_bp_agent_init_meta();
-void dtn_bp_agent_init_cnst();
-void dtn_bp_agent_init_edd();
-void dtn_bp_agent_init_op();
-void dtn_bp_agent_init_var();
-void dtn_bp_agent_init_ctrl();
-void dtn_bp_agent_init_mac();
-void dtn_bp_agent_init_rpttpl();
-void dtn_bp_agent_init_tblt();
-#endif /* _HAVE_DTN_BP_AGENT_ADM_ */
-#endif //ADM_BP_AGENT_H_
\ No newline at end of file
diff -ru --new-file ion-sf/bpv7/adm/adm_bp_agent_impl.c ion-anms/bpv7/adm/adm_bp_agent_impl.c
--- ion-sf/bpv7/adm/adm_bp_agent_impl.c	2023-05-30 10:55:36.705112198 -0400
+++ ion-anms/bpv7/adm/adm_bp_agent_impl.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1002 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bp_agent_impl.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "ion.h"
-#include "bp.h"
-#include "bpP.h"
-#include "bpnm.h"
-
-
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/adm/adm.h"
-#include "adm_bp_agent_impl.h"
-
-/*   START CUSTOM FUNCTIONS HERE */
-/*             TODO              */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_bp_agent_setup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-void dtn_bp_agent_cleanup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-
-/* Metadata Functions */
-
-
-tnv_t *dtn_bp_agent_meta_name(tnvc_t *parms)
-{
-	return tnv_from_str("bp_agent");
-}
-
-
-tnv_t *dtn_bp_agent_meta_namespace(tnvc_t *parms)
-{
-	return tnv_from_str("DTN/bp_agent");
-}
-
-
-tnv_t *dtn_bp_agent_meta_version(tnvc_t *parms)
-{
-	return tnv_from_str("v0.1");
-}
-
-
-tnv_t *dtn_bp_agent_meta_organization(tnvc_t *parms)
-{
-	return tnv_from_str("JHUAPL");
-}
-
-
-/* Constant Functions */
-/* Table Functions */
-
-
-/* Collect Functions */
-/*
- * The node administration endpoint
- */
-tnv_t *dtn_bp_agent_get_bp_node_id(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_bp_node_id BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpNode node_state;
-	bpnm_node_get(&node_state);
-
-	result = tnv_from_str((char *) node_state.nodeID);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_bp_node_id BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The latest version of the BP supported by this node
- */
-tnv_t *dtn_bp_agent_get_bp_node_version(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_bp_node_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpNode node_state;
-	bpnm_node_get(&node_state);
-
-	result = tnv_from_str((char *) node_state.bpVersionNbr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_bp_node_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Bytes available for bundle storage
- */
-tnv_t *dtn_bp_agent_get_available_storage(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_available_storage BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpNode node_state;
-	bpnm_node_get(&node_state);
-
-	result = tnv_from_uvast(node_state.avblStorage);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_available_storage BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The last time that BP counters were reset, either due to execution of a reset control or a restart o
- * f the node itself
- */
-tnv_t *dtn_bp_agent_get_last_reset_time(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_last_reset_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	Sdr sdr = getIonsdr();
-	Object dbobj = getBpDbObject();
-	BpDB db;
-
-	// TODO Check return call for sdr_begin_xn
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &db, dbobj, sizeof(BpDB));
-
-	result = tnv_from_uvast(db.resetTime);
-	oK(sdr_end_xn(sdr));
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_last_reset_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of registrations
- */
-tnv_t *dtn_bp_agent_get_num_registrations(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_registrations BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpNode node_state;
-	bpnm_node_get(&node_state);
-
-	result = tnv_from_uint(node_state.nbrOfRegistrations);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_registrations BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles pending forwarding
- */
-tnv_t *dtn_bp_agent_get_num_pend_fwd(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_pend_fwd BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.currentForwardPending);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_pend_fwd BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles awaiting dispatch
- */
-tnv_t *dtn_bp_agent_get_num_pend_dis(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_pend_dis BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.currentDispatchPending);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_pend_dis BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles
- */
-tnv_t *dtn_bp_agent_get_num_in_cust(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_in_cust BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.currentInCustody);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_in_cust BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles pending reassembly
- */
-tnv_t *dtn_bp_agent_get_num_pend_reassembly(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_pend_reassembly BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.currentReassemblyPending);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_pend_reassembly BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles for the given priority. Priority is given as a priority mask where Bulk=0x1, norma
- * l=0x2, express=0x4. Any bundles matching any of the masked priorities will be included in the return
- * ed count
- */
-tnv_t *dtn_bp_agent_get_bundles_by_priority(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_bundles_by_priority BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	int success = 0;
-
-	bpnm_disposition_get(&state);
-	uvast val = 0;
-	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
-
-	if(mask & 0x1)
-	{
-		val += state.currentResidentCount[0];
-	}
-	if(mask & 0x2)
-	{
-		val += state.currentResidentCount[1];
-	}
-	if(mask & 0x4)
-	{
-		val += state.currentResidentCount[2];
-	}
-
-	result = tnv_from_uvast(val);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_bundles_by_priority BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bytes of the given priority. Priority is given as a priority mask where bulk=0x1, normal=0
- * x2, express=0x4. Any bundles matching any of the masked priorities will be included in the returned 
- * count.
- */
-tnv_t *dtn_bp_agent_get_bytes_by_priority(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_bytes_by_priority BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	int success = 0;
-	bpnm_disposition_get(&state);
-	uvast val = 0;
-	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
-
-	if(mask & 0x1)
-	{
-		val += state.currentResidentBytes[0];
-	}
-	if(mask & 0x2)
-	{
-		val += state.currentResidentBytes[1];
-	}
-	if(mask & 0x4)
-	{
-		val += state.currentResidentBytes[2];
-	}
-
-	result = tnv_from_uvast(val);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_bytes_by_priority BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles sourced by this node of the given priority. Priority is given as a priority mask w
- * here bulk=0x1, normal=0x2, express=0x4. Any bundles sourced by this node and matching any of the mas
- * ked priorities will be included in the returned count.
- */
-tnv_t *dtn_bp_agent_get_src_bundles_by_priority(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_src_bundles_by_priority BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	int success = 0;
-	bpnm_disposition_get(&state);
-
-	uvast val = 0;
-	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
-
-	if(mask & 0x1)
-	{
-		val += state.bundleSourceCount[0];
-	}
-	if(mask & 0x2)
-	{
-		val += state.bundleSourceCount[1];
-	}
-	if(mask & 0x4)
-	{
-		val += state.bundleSourceCount[2];
-	}
-
-	result = tnv_from_uvast(val);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_src_bundles_by_priority BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bytes sourced by this node of the given priority. Priority is given as a priority mask whe
- * re bulk=0x1, normal=0x2, express=0x4. Any bundles sourced by this node and matching any of the maske
- * d priorities will be included in the returned count
- */
-tnv_t *dtn_bp_agent_get_src_bytes_by_priority(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_src_bytes_by_priority BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	int success = 0;
-	bpnm_disposition_get(&state);
-
-	uvast val = 0;
-	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
-
-	if(mask & 0x1)
-	{
-		val += state.bundleSourceBytes[0];
-	}
-	if(mask & 0x2)
-	{
-		val += state.bundleSourceBytes[1];
-	}
-	if(mask & 0x4)
-	{
-		val += state.bundleSourceBytes[2];
-	}
-
-	result = tnv_from_uvast(val);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_src_bytes_by_priority BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of fragmented bundles
- */
-tnv_t *dtn_bp_agent_get_num_fragmented_bundles(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fragmented_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.bundlesFragmented);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fragmented_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles with fragmentary payloads produced by this node
- */
-tnv_t *dtn_bp_agent_get_num_fragments_produced(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fragments_produced BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.fragmentsProduced);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fragments_produced BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles failed for any of the given reasons. (noInfo=0x1, Expired=0x2, UniFwd=0x4, Cancell
- * ed=0x8, NoStorage=0x10, BadEID=0x20, NoRoute=0x40, NoContact=0x80, BadBlock=0x100)
- */
-tnv_t *dtn_bp_agent_get_num_failed_by_reason(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_failed_by_reason BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	int success = 0;
-	bpnm_disposition_get(&state);
-
-	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
-	uvast val = 0;
-
-	if(mask & 0x01)
-	{
-		val += state.delNoneCount;
-	}
-	if(mask & 0x02)
-	{
-		val += state.delExpiredCount;
-	}
-	if(mask & 0x04)
-	{
-		val += state.delFwdUnidirCount;
-	}
-	if(mask & 0x08)
-	{
-		val += state.delCanceledCount;
-	}
-	if(mask & 0x10)
-	{
-		val += state.delDepletionCount;
-	}
-	if(mask & 0x20)
-	{
-		val += state.delEidMalformedCount;
-	}
-	if(mask & 0x40)
-	{
-		val += state.delNoRouteCount;
-	}
-	if(mask & 0x80)
-	{
-		val += state.delNoContactCount;
-	}
-	if(mask & 0x100)
-	{
-		val += state.delBlkMalformedCount;
-	}
-
-	result = tnv_from_uvast(val);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_failed_by_reason BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles deleted by this node
- */
-tnv_t *dtn_bp_agent_get_num_bundles_deleted(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bundles_deleted BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.delNoneCount + state.delExpiredCount + state.delFwdUnidirCount + state.delCanceledCount + state.delDepletionCount + state.delEidMalformedCount + state.delNoRouteCount + state.delNoContactCount + state.delBlkMalformedCount);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bundles_deleted BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundle fails at this node
- */
-tnv_t *dtn_bp_agent_get_failed_custody_bundles(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_failed_custody_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.custodyRefusedCount);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_failed_custody_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number bytes of fails at this node
- */
-tnv_t *dtn_bp_agent_get_failed_custody_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_failed_custody_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.custodyRefusedBytes);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_failed_custody_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number bundles not forwarded by this node
- */
-tnv_t *dtn_bp_agent_get_failed_forward_bundles(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_failed_forward_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.bundleFwdFailedCount);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_failed_forward_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bytes not forwaded by this node
- */
-tnv_t *dtn_bp_agent_get_failed_forward_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_failed_forward_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.bundleFwdFailedBytes);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_failed_forward_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles abandoned by this node
- */
-tnv_t *dtn_bp_agent_get_abandoned_bundles(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_abandoned_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.bundleAbandonCount);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_abandoned_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bytes abandoned by this node
- */
-tnv_t *dtn_bp_agent_get_abandoned_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_abandoned_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.bundleAbandonBytes);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_abandoned_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bundles discarded by this node
- */
-tnv_t *dtn_bp_agent_get_discarded_bundles(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_discarded_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.bundleDiscardCount);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_discarded_bundles BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * number of bytes discarded by this node
- */
-tnv_t *dtn_bp_agent_get_discarded_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_discarded_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmbpDisposition state;
-	bpnm_disposition_get(&state);
-
-	result = tnv_from_uvast(state.bundleDiscardBytes);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_discarded_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * CSV list of endpoint names for this node
- */
-tnv_t *dtn_bp_agent_get_endpoint_names(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_endpoint_names BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char names[2049];
-	char *ptrs[128];
-	int num = 0;
-	int i = 0;
-
-	bpnm_endpointNames_get((char *) names, 2048, ptrs, &num);
-
-	for(i = 0; i < (num-1); i++)
-	{
-		*(ptrs[i+1]-sizeof(char)) = ',';
-	}
-
-	result = tnv_from_str(names);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_endpoint_names BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * is the given endpoint active? (0=no)
- */
-tnv_t *dtn_bp_agent_get_endpoint_active(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_endpoint_active BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	NmbpEndpoint endpoint;
-	int success = 0;
-
-	bpnm_endpoint_get(name, &endpoint, &success);
-	if(success != 0)
-	{
-		result = tnv_from_uint(endpoint.active);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_endpoint_active BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * is the given endpoint singleton? (0=no)
- */
-tnv_t *dtn_bp_agent_get_endpoint_singleton(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_endpoint_singleton BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	NmbpEndpoint endpoint;
-	int success = 0;
-
-	bpnm_endpoint_get(name, &endpoint, &success);
-	if(success != 0)
-	{
-		result = tnv_from_uint(endpoint.singleton);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_endpoint_singleton BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Does the endpoint abandon on fail (0=no)
- */
-tnv_t *dtn_bp_agent_get_endpoint_policy(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_endpoint_policy BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	NmbpEndpoint endpoint;
-	int success = 0;
-
-	bpnm_endpoint_get(name, &endpoint, &success);
-	if(success != 0)
-	{
-		result = tnv_from_uint(endpoint.abandonOnDelivFailure);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_endpoint_policy BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* Control Functions */
-
-/*
- * This control causes the Agent to reset all counts associated with bundle or byte statistics and to s
- * et the last reset time of the BP primitive data to the time when the control was run
- */
-tnv_t *dtn_bp_agent_ctrl_reset_all_counts(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_reset_all_counts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	bpnm_disposition_reset();
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_reset_all_counts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* OP Functions */
diff -ru --new-file ion-sf/bpv7/adm/adm_bp_agent_impl.h ion-anms/bpv7/adm/adm_bp_agent_impl.h
--- ion-sf/bpv7/adm/adm_bp_agent_impl.h	2023-05-30 10:55:36.705112198 -0400
+++ ion-anms/bpv7/adm/adm_bp_agent_impl.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,101 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bp_agent_impl.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-#ifndef ADM_BP_AGENT_IMPL_H_
-#define ADM_BP_AGENT_IMPL_H_
-
-/*   START CUSTOM INCLUDES HERE  */
-/*             TODO              */
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/utils/utils.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-#include "shared/primitives/tnv.h"
-
-/*   START typeENUM */
-/*             TODO              */
-/*   STOP typeENUM  */
-
-void name_adm_init_agent();
-
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                     Retrieval Functions                                     +
- * +---------------------------------------------------------------------------------------------+
- */
-/*   START CUSTOM FUNCTIONS HERE */
-/*             TODO              */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_bp_agent_setup();
-void dtn_bp_agent_cleanup();
-
-
-/* Metadata Functions */
-tnv_t *dtn_bp_agent_meta_name(tnvc_t *parms);
-tnv_t *dtn_bp_agent_meta_namespace(tnvc_t *parms);
-tnv_t *dtn_bp_agent_meta_version(tnvc_t *parms);
-tnv_t *dtn_bp_agent_meta_organization(tnvc_t *parms);
-
-/* Constant Functions */
-
-/* Collect Functions */
-tnv_t *dtn_bp_agent_get_bp_node_id(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_bp_node_version(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_available_storage(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_last_reset_time(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_num_registrations(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_num_pend_fwd(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_num_pend_dis(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_num_in_cust(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_num_pend_reassembly(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_bundles_by_priority(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_bytes_by_priority(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_src_bundles_by_priority(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_src_bytes_by_priority(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_num_fragmented_bundles(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_num_fragments_produced(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_num_failed_by_reason(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_num_bundles_deleted(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_failed_custody_bundles(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_failed_custody_bytes(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_failed_forward_bundles(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_failed_forward_bytes(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_abandoned_bundles(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_abandoned_bytes(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_discarded_bundles(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_discarded_bytes(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_endpoint_names(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_endpoint_active(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_endpoint_singleton(tnvc_t *parms);
-tnv_t *dtn_bp_agent_get_endpoint_policy(tnvc_t *parms);
-
-
-/* Control Functions */
-tnv_t *dtn_bp_agent_ctrl_reset_all_counts(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-
-
-/* OP Functions */
-
-
-/* Table Build Functions */
-
-#endif //ADM_BP_AGENT_IMPL_H_
diff -ru --new-file ion-sf/bpv7/adm/adm_bp_agent_mgr.c ion-anms/bpv7/adm/adm_bp_agent_mgr.c
--- ion-sf/bpv7/adm/adm_bp_agent_mgr.c	2023-05-30 10:55:36.705112198 -0400
+++ ion-anms/bpv7/adm/adm_bp_agent_mgr.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,315 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bp_agent_mgr.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_bp_agent.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "metadata.h"
-#include "nm_mgr_ui.h"
-
-
-
-
-#define _HAVE_DTN_BP_AGENT_ADM_
-#ifdef _HAVE_DTN_BP_AGENT_ADM_
-static vec_idx_t g_dtn_bp_agent_idx[11];
-
-void dtn_bp_agent_init()
-{
-	adm_add_adm_info("dtn_bp_agent", ADM_ENUM_DTN_BP_AGENT);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_META_IDX), &(g_dtn_bp_agent_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_RPTT_IDX), &(g_dtn_bp_agent_idx[ADM_RPTT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_EDD_IDX), &(g_dtn_bp_agent_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_CTRL_IDX), &(g_dtn_bp_agent_idx[ADM_CTRL_IDX]));
-
-
-	dtn_bp_agent_init_meta();
-	dtn_bp_agent_init_cnst();
-	dtn_bp_agent_init_edd();
-	dtn_bp_agent_init_op();
-	dtn_bp_agent_init_var();
-	dtn_bp_agent_init_ctrl();
-	dtn_bp_agent_init_mac();
-	dtn_bp_agent_init_rpttpl();
-	dtn_bp_agent_init_tblt();
-}
-
-void dtn_bp_agent_init_meta()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAME);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "name", "The human-readable name of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAMESPACE);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "namespace", "The namespace of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_VERSION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "version", "The version of the ADM");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_ORGANIZATION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "organization", "The name of the issuing organization of the ADM.");
-
-}
-
-void dtn_bp_agent_init_cnst()
-{
-
-}
-
-void dtn_bp_agent_init_edd()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_ID);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "bp_node_id", "The node administration endpoint");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_VERSION);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "bp_node_version", "The latest version of the BP supported by this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_AVAILABLE_STORAGE);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UVAST, id, ADM_ENUM_DTN_BP_AGENT, "available_storage", "Bytes available for bundle storage");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_LAST_RESET_TIME);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UVAST, id, ADM_ENUM_DTN_BP_AGENT, "last_reset_time", "The last time that BP counters were reset, either due to execution of a reset control or a restart of the node itself");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_REGISTRATIONS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_registrations", "number of registrations");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_FWD);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_pend_fwd", "number of bundles pending forwarding");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_DIS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_pend_dis", "number of bundles awaiting dispatch");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_IN_CUST);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_in_cust", "number of bundles");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_pend_reassembly", "number of bundles pending reassembly");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "bundles_by_priority", "number of bundles for the given priority. Priority is given as a priority mask where Bulk=0x1, normal=0x2, express=0x4. Any bundles matching any of the masked priorities will be included in the returned count");
-
-	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "bytes_by_priority", "number of bytes of the given priority. Priority is given as a priority mask where bulk=0x1, normal=0x2, express=0x4. Any bundles matching any of the masked priorities will be included in the returned count.");
-
-	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "src_bundles_by_priority", "number of bundles sourced by this node of the given priority. Priority is given as a priority mask where bulk=0x1, normal=0x2, express=0x4. Any bundles sourced by this node and matching any of the masked priorities will be included in the returned count.");
-
-	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "src_bytes_by_priority", "number of bytes sourced by this node of the given priority. Priority is given as a priority mask where bulk=0x1, normal=0x2, express=0x4. Any bundles sourced by this node and matching any of the masked priorities will be included in the returned count");
-
-	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_fragmented_bundles", "number of fragmented bundles");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_fragments_produced", "number of bundles with fragmentary payloads produced by this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_failed_by_reason", "number of bundles failed for any of the given reasons. (noInfo=0x1, Expired=0x2, UniFwd=0x4, Cancelled=0x8, NoStorage=0x10, BadEID=0x20, NoRoute=0x40, NoContact=0x80, BadBlock=0x100)");
-
-	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_bundles_deleted", "number of bundles deleted by this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "failed_custody_bundles", "number of bundle fails at this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "failed_custody_bytes", "number bytes of fails at this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "failed_forward_bundles", "number bundles not forwarded by this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "failed_forward_bytes", "number of bytes not forwaded by this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BUNDLES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "abandoned_bundles", "number of bundles abandoned by this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "abandoned_bytes", "number of bytes abandoned by this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BUNDLES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "discarded_bundles", "number of bundles discarded by this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "discarded_bytes", "number of bytes discarded by this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_NAMES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "endpoint_names", "CSV list of endpoint names for this node");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "endpoint_active", "is the given endpoint active? (0=no)");
-
-	meta_add_parm(meta, "endpoint_name", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "endpoint_singleton", "is the given endpoint singleton? (0=no)");
-
-	meta_add_parm(meta, "endpoint_name", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_POLICY);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "endpoint_policy", "Does the endpoint abandon on fail (0=no)");
-
-	meta_add_parm(meta, "endpoint_name", AMP_TYPE_STR);
-}
-
-void dtn_bp_agent_init_op()
-{
-
-}
-
-void dtn_bp_agent_init_var()
-{
-
-}
-
-void dtn_bp_agent_init_ctrl()
-{
-
-	ari_t *id = NULL;
-
-
-	/* RESET_ALL_COUNTS */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 0, g_dtn_bp_agent_idx[ADM_CTRL_IDX], DTN_BP_AGENT_CTRL_RESET_ALL_COUNTS);
-	adm_add_ctrldef_ari(id, 0, NULL);
-	meta_add_ctrl(id, ADM_ENUM_DTN_BP_AGENT, "reset_all_counts", "This control causes the Agent to reset all counts associated with bundle or byte statistics and to set the last reset time of the BP primitive data to the time when the control was run");
-
-}
-
-void dtn_bp_agent_init_mac()
-{
-
-}
-
-void dtn_bp_agent_init_rpttpl()
-{
-
-	metadata_t *meta = NULL;
-
-	rpttpl_t *def = NULL;
-
-	/* FULL_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_dtn_bp_agent_idx[ADM_RPTT_IDX], DTN_BP_AGENT_RPTTPL_FULL_REPORT));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAME));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_VERSION));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_ID));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_VERSION));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_AVAILABLE_STORAGE));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_LAST_RESET_TIME));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_REGISTRATIONS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_FWD));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_DIS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_IN_CUST));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(4)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(4)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(4)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(4)));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(1)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(2)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(4)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(8)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(16)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(32)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(64)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(128)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(256)));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BUNDLES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_NAMES));
-	adm_add_rpttpl(def);
-	meta_add_rpttpl(def->id, ADM_ENUM_DTN_BP_AGENT, "full_report", "This is all known meta-data, EDD, and VAR values known by the agent.");
-	/* ENDPOINT_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_bp_agent_idx[ADM_RPTT_IDX], DTN_BP_AGENT_RPTTPL_ENDPOINT_REPORT));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_POLICY, tnv_from_map(AMP_TYPE_STR, 0)));
-	adm_add_rpttpl(def);
-	meta = meta_add_rpttpl(def->id, ADM_ENUM_DTN_BP_AGENT, "endpoint_report", "This is all known endpoint information");
-	meta_add_parm(meta, "endpoint_id", AMP_TYPE_STR);
-}
-
-void dtn_bp_agent_init_tblt()
-{
-
-}
-
-#endif // _HAVE_DTN_BP_AGENT_ADM_
diff -ru --new-file ion-sf/bpv7/adm/adm_bpsec_agent.c ion-anms/bpv7/adm/adm_bpsec_agent.c
--- ion-sf/bpv7/adm/adm_bpsec_agent.c	2023-05-30 10:55:36.709112249 -0400
+++ ion-anms/bpv7/adm/adm_bpsec_agent.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,282 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bpsec_agent.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_bpsec.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "adm_bpsec_impl.h"
-#include "agent/rda.h"
-
-
-#include "adm_amp_agent.h"
-
-#define _HAVE_DTN_BPSEC_ADM_
-#ifdef _HAVE_DTN_BPSEC_ADM_
-
-static vec_idx_t g_dtn_bpsec_idx[11];
-
-void dtn_bpsec_init()
-{
-	adm_add_adm_info("dtn_bpsec", ADM_ENUM_DTN_BPSEC);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_RPTT_IDX), &(g_dtn_bpsec_idx[ADM_RPTT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_EDD_IDX), &(g_dtn_bpsec_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_CTRL_IDX), &(g_dtn_bpsec_idx[ADM_CTRL_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_META_IDX), &(g_dtn_bpsec_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_TBLT_IDX), &(g_dtn_bpsec_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_VAR_IDX), &(g_dtn_bpsec_idx[ADM_VAR_IDX]));
-
-
-	dtn_bpsec_setup();
-	dtn_bpsec_init_meta();
-	dtn_bpsec_init_cnst();
-	dtn_bpsec_init_edd();
-	dtn_bpsec_init_op();
-	dtn_bpsec_init_var();
-	dtn_bpsec_init_ctrl();
-	dtn_bpsec_init_mac();
-	dtn_bpsec_init_rpttpl();
-	dtn_bpsec_init_tblt();
-}
-
-void dtn_bpsec_init_meta()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_NAME), dtn_bpsec_meta_name);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_NAMESPACE), dtn_bpsec_meta_namespace);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_VERSION), dtn_bpsec_meta_version);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_ORGANIZATION), dtn_bpsec_meta_organization);
-}
-
-void dtn_bpsec_init_cnst()
-{
-
-}
-
-void dtn_bpsec_init_edd()
-{
-
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK), dtn_bpsec_get_num_good_tx_bcb_blk);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK), dtn_bpsec_get_num_bad_tx_bcb_blk);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK), dtn_bpsec_get_num_good_rx_bcb_blk);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK), dtn_bpsec_get_num_bad_rx_bcb_blk);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS), dtn_bpsec_get_num_missing_rx_bcb_blks);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS), dtn_bpsec_get_num_fwd_bcb_blks);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES), dtn_bpsec_get_num_good_tx_bcb_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES), dtn_bpsec_get_num_bad_tx_bcb_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS), dtn_bpsec_get_num_bad_tx_bcb_blks);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES), dtn_bpsec_get_num_good_rx_bcb_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES), dtn_bpsec_get_num_bad_rx_bcb_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES), dtn_bpsec_get_num_missing_rx_bcb_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES), dtn_bpsec_get_num_fwd_bcb_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS), dtn_bpsec_get_num_good_tx_bib_blks);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS), dtn_bpsec_get_num_bad_tx_bib_blks);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS), dtn_bpsec_get_num_good_rx_bib_blks);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS), dtn_bpsec_get_num_bad_rx_bib_blks);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS), dtn_bpsec_get_num_miss_rx_bib_blks);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS), dtn_bpsec_get_num_fwd_bib_blks);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES), dtn_bpsec_get_num_good_tx_bib_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES), dtn_bpsec_get_num_bad_tx_bib_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES), dtn_bpsec_get_num_good_rx_bib_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES), dtn_bpsec_get_num_bad_rx_bib_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES), dtn_bpsec_get_num_miss_rx_bib_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES), dtn_bpsec_get_num_fwd_bib_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE), dtn_bpsec_get_last_update);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_KNOWN_KEYS), dtn_bpsec_get_num_known_keys);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_KEY_NAMES), dtn_bpsec_get_key_names);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_CIPHERSUITE_NAMES), dtn_bpsec_get_ciphersuite_names);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_RULE_SOURCE), dtn_bpsec_get_rule_source);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC), dtn_bpsec_get_num_good_tx_bcb_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC), dtn_bpsec_get_num_bad_tx_bcb_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC), dtn_bpsec_get_num_good_rx_bcb_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC), dtn_bpsec_get_num_bad_rx_bcb_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC), dtn_bpsec_get_num_missing_rx_bcb_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC), dtn_bpsec_get_num_fwd_bcb_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC), dtn_bpsec_get_num_good_tx_bcb_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC), dtn_bpsec_get_num_bad_tx_bcb_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC), dtn_bpsec_get_num_good_rx_bcb_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC), dtn_bpsec_get_num_bad_rx_bcb_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC), dtn_bpsec_get_num_missing_rx_bcb_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC), dtn_bpsec_get_num_fwd_bcb_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC), dtn_bpsec_get_num_good_tx_bib_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC), dtn_bpsec_get_num_bad_tx_bib_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC), dtn_bpsec_get_num_good_rx_bib_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC), dtn_bpsec_get_num_bad_rx_bib_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC), dtn_bpsec_get_num_miss_rx_bib_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC), dtn_bpsec_get_num_fwd_bib_blks_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC), dtn_bpsec_get_num_good_tx_bib_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC), dtn_bpsec_get_num_bad_tx_bib_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC), dtn_bpsec_get_num_good_rx_bib_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC), dtn_bpsec_get_num_bad_rx_bib_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC), dtn_bpsec_get_num_missing_rx_bib_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC), dtn_bpsec_get_num_fwd_bib_bytes_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE_SRC), dtn_bpsec_get_last_update_src);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_RESET), dtn_bpsec_get_last_reset);
-}
-
-void dtn_bpsec_init_op()
-{
-
-}
-
-void dtn_bpsec_init_var()
-{
-
-	ari_t *id = NULL;
-
-	expr_t *expr = NULL;
-
-
-	/* TOTAL_BAD_TX_BLKS */
-
-	id = adm_build_ari(AMP_TYPE_VAR, 0, g_dtn_bpsec_idx[ADM_VAR_IDX], DTN_BPSEC_VAR_TOTAL_BAD_TX_BLKS);
-	expr = expr_create(AMP_TYPE_UINT);
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS));
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS));
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUINT));
-	adm_add_var_from_expr(id, AMP_TYPE_UINT, expr);
-}
-
-void dtn_bpsec_init_ctrl()
-{
-
-	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_RST_ALL_CNTS, 0, dtn_bpsec_ctrl_rst_all_cnts);
-	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_RST_SRC_CNTS, 1, dtn_bpsec_ctrl_rst_src_cnts);
-	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DELETE_KEY, 1, dtn_bpsec_ctrl_delete_key);
-	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_KEY, 2, dtn_bpsec_ctrl_add_key);
-	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_BIB_RULE, 5, dtn_bpsec_ctrl_add_bib_rule);
-	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DEL_BIB_RULE, 3, dtn_bpsec_ctrl_del_bib_rule);
-	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_BCB_RULE, 5, dtn_bpsec_ctrl_add_bcb_rule);
-	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DEL_BCB_RULE, 3, dtn_bpsec_ctrl_del_bcb_rule);
-}
-
-void dtn_bpsec_init_mac()
-{
-
-}
-
-void dtn_bpsec_init_rpttpl()
-{
-
-	rpttpl_t *def = NULL;
-
-	/* FULL_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_dtn_bpsec_idx[ADM_RPTT_IDX], DTN_BPSEC_RPTTPL_FULL_REPORT));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_KNOWN_KEYS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_KEY_NAMES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_CIPHERSUITE_NAMES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_RULE_SOURCE));
-	adm_add_rpttpl(def);
-	/* SOURCE_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_bpsec_idx[ADM_RPTT_IDX], DTN_BPSEC_RPTTPL_SOURCE_REPORT));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_RESET, tnv_from_map(AMP_TYPE_STR, 0)));
-	adm_add_rpttpl(def);
-}
-
-void dtn_bpsec_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* KEYS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_KEYS), dtn_bpsec_tblt_keys);
-	tblt_add_col(def, AMP_TYPE_STR, "key_name");
-	adm_add_tblt(def);
-
-	/* CIPHERSUITES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_CIPHERSUITES), dtn_bpsec_tblt_ciphersuites);
-	tblt_add_col(def, AMP_TYPE_STR, "csname");
-	adm_add_tblt(def);
-
-	/* BIB_RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_BIB_RULES), dtn_bpsec_tblt_bib_rules);
-	tblt_add_col(def, AMP_TYPE_STR, "SrcEid");
-	tblt_add_col(def, AMP_TYPE_STR, "DestEid");
-	tblt_add_col(def, AMP_TYPE_UINT, "TgtBlk");
-	tblt_add_col(def, AMP_TYPE_STR, "csName");
-	tblt_add_col(def, AMP_TYPE_STR, "keyName");
-	adm_add_tblt(def);
-
-	/* BCB_RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_BCB_RULES), dtn_bpsec_tblt_bcb_rules);
-	tblt_add_col(def, AMP_TYPE_STR, "SrcEid");
-	tblt_add_col(def, AMP_TYPE_STR, "DestEid");
-	tblt_add_col(def, AMP_TYPE_UINT, "TgtBlk");
-	tblt_add_col(def, AMP_TYPE_STR, "csName");
-	tblt_add_col(def, AMP_TYPE_STR, "keyName");
-	adm_add_tblt(def);
-}
-
-#endif // _HAVE_DTN_BPSEC_ADM_
diff -ru --new-file ion-sf/bpv7/adm/adm_bpsec.h ion-anms/bpv7/adm/adm_bpsec.h
--- ion-sf/bpv7/adm/adm_bpsec.h	2023-05-30 10:55:36.709112249 -0400
+++ ion-anms/bpv7/adm/adm_bpsec.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,432 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bpsec.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-
-#ifndef ADM_BPSEC_H_
-#define ADM_BPSEC_H_
-#define _HAVE_DTN_BPSEC_ADM_
-#ifdef _HAVE_DTN_BPSEC_ADM_
-
-#include "shared/utils/nm_types.h"
-#include "shared/adm/adm.h"
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 ADM TEMPLATE DOCUMENTATION                                  +
- * +---------------------------------------------------------------------------------------------+
- *
- * ADM ROOT STRING:DTN/bpsec
- */
-#define ADM_ENUM_DTN_BPSEC 10
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AGENT NICKNAME DEFINITIONS                                  +
- * +---------------------------------------------------------------------------------------------+
- */
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               DTN_BPSEC META-DATA DEFINITIONS                               +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |name                 |The human-readable name of the ADM.   |STR    |bpsec                   |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |namespace            |The namespace of the ADM.             |STR    |DTN/bpsec               |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |version              |The version of the ADM.               |STR    |v1.0                    |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |organization         |The name of the issuing organization o|       |                        |
- * |                     |f the ADM.                            |STR    |JHUAPL                  |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-// "name"
-#define DTN_BPSEC_META_NAME 0x00
-// "namespace"
-#define DTN_BPSEC_META_NAMESPACE 0x01
-// "version"
-#define DTN_BPSEC_META_VERSION 0x02
-// "organization"
-#define DTN_BPSEC_META_ORGANIZATION 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                        DTN_BPSEC EXTERNALLY DEFINED DATA DEFINITIONS                        +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |num_good_tx_bcb_blk  |Total successfully Tx Bundle Confident|       |
- * |                     |iality blocks                         |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_tx_bcb_blk   |Total unsuccessfully Tx Block Confiden|       |
- * |                     |tiality Block (BCB) blocks            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_rx_bcb_blk  |Total successfully Rx BCB blocks      |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_rx_bcb_blk   |Total unsuccessfully Rx BCB blocks    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_missing_rx_bcb_bl|Total missing-on-RX BCB blocks        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fwd_bcb_blks     |Total forward BCB blocks              |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_tx_bcb_bytes|Total successfully Tx BCB bytes       |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_tx_bcb_bytes |Total unsuccessfully Tx BCB bytes     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_tx_bcb_blks  |Total unsuccessfully Tx BCB blocks    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_rx_bcb_bytes|Total successfully Rx BCB bytes       |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_rx_bcb_bytes |Total unsuccessfully Rx BCB bytes     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_missing_rx_bcb_by|Total missing-on-Rx BCB bytes         |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fwd_bcb_bytes    |Total forwarded BCB bytes             |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_tx_bib_blks |Total successfully Tx Block Integrity |       |
- * |                     |Block (BIB) blocks                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_tx_bib_blks  |Total unsuccessfully Tx BIB blocks    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_rx_bib_blks |Total successfully Rx BIB blocks      |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_rx_bib_blks  |Total unsuccessfully Rx BIB blocks    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_miss_rx_bib_blks |Total missing-on-Rx BIB blocks        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fwd_bib_blks     |Total forwarded BIB blocks            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_tx_bib_bytes|Total successfully Tx BIB bytes       |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_tx_bib_bytes |Total unsuccessfully Tx BIB bytes     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_rx_bib_bytes|Total successfully Rx BIB bytes       |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_rx_bib_bytes |Total unsuccessfully Rx BIB bytes     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_miss_rx_bib_bytes|Total missing-on-Rx BIB bytes         |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fwd_bib_bytes    |Total forwarded BIB bytes             |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |last_update          |Last BPSEC update                     |TV     |
- * +---------------------+--------------------------------------+-------+
- * |num_known_keys       |Number of known keys                  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |key_names            |Known key names                       |STR    |
- * +---------------------+--------------------------------------+-------+
- * |ciphersuite_names    |Known ciphersuite names               |STR    |
- * +---------------------+--------------------------------------+-------+
- * |rule_source          |Known rule sources                    |STR    |
- * +---------------------+--------------------------------------+-------+
- * |num_good_tx_bcb_blks_|Number of successfully Tx BCB blocks f|       |
- * |                     |rom SRC                               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_tx_bcb_blks_s|Number of failed TX BCB blocks from SR|       |
- * |                     |C                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_rx_bcb_blks_|Number of successfully Rx BCB blocks f|       |
- * |                     |rom SRC                               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_rx_bcb_blks_s|Number of failed RX BCB blocks from SR|       |
- * |                     |C                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_missing_rx_bcb_bl|Number of missing-onRX BCB blocks from|       |
- * |                     | SRC                                  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fwd_bcb_blks_src |Number of forwarded BCB blocks from SR|       |
- * |                     |C                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_tx_bcb_bytes|Number of successfully Tx bcb bytes fr|       |
- * |                     |om SRC                                |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_tx_bcb_bytes_|Number of failed Tx bcb bytes from SRC|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_rx_bcb_bytes|Number of successfully Rx bcb bytes fr|       |
- * |                     |om SRC                                |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_rx_bcb_bytes_|Number of failed Rx bcb bytes from SRC|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_missing_rx_bcb_by|Number of missing-on-Rx bcb bytes from|       |
- * |                     | SRC                                  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fwd_bcb_bytes_src|Number of forwarded bcb bytes from SRC|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_tx_bib_blks_|Number of successfully Tx BIB blocks f|       |
- * |                     |rom SRC                               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_tx_bib_blks_s|Number of failed Tx BIB blocks from SR|       |
- * |                     |C                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_rx_bib_blks_|Number of successfully Rx BIB blocks f|       |
- * |                     |rom SRC                               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_rx_bib_blks_s|Number of failed Rx BIB blocks from SR|       |
- * |                     |C                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_miss_rx_bib_blks_|Number of missing-on-Rx BIB blocks fro|       |
- * |                     |m SRC                                 |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fwd_bib_blks_src |Number of forwarded BIB blocks from SR|       |
- * |                     |C                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_tx_bib_bytes|Number of successfully Tx BIB bytes fr|       |
- * |                     |om SRC                                |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_tx_bib_bytes_|Number of failed Tx BIB bytes from SRC|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_good_rx_bib_bytes|Number of successfully Rx BIB bytes fr|       |
- * |                     |om SRC                                |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_bad_rx_bib_bytes_|Number of failed Rx BIB bytes from SRC|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_missing_rx_bib_by|Number of missing-on-Rx BIB bytes from|       |
- * |                     | SRC                                  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_fwd_bib_bytes_src|Number of forwarded BIB bytes from SRC|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |last_update_src      |Last BPSEC update from SRC            |TV     |
- * +---------------------+--------------------------------------+-------+
- * |last_reset           |Last reset                            |TV     |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK 0x00
-#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK 0x01
-#define DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK 0x02
-#define DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK 0x03
-#define DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS 0x04
-#define DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS 0x05
-#define DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES 0x06
-#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES 0x07
-#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS 0x08
-#define DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES 0x09
-#define DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES 0x0a
-#define DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES 0x0b
-#define DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES 0x0c
-#define DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS 0x0d
-#define DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS 0x0e
-#define DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS 0x0f
-#define DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS 0x10
-#define DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS 0x11
-#define DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS 0x12
-#define DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES 0x13
-#define DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES 0x14
-#define DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES 0x15
-#define DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES 0x16
-#define DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES 0x17
-#define DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES 0x18
-#define DTN_BPSEC_EDD_LAST_UPDATE 0x19
-#define DTN_BPSEC_EDD_NUM_KNOWN_KEYS 0x1a
-#define DTN_BPSEC_EDD_KEY_NAMES 0x1b
-#define DTN_BPSEC_EDD_CIPHERSUITE_NAMES 0x1c
-#define DTN_BPSEC_EDD_RULE_SOURCE 0x1d
-#define DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC 0x1e
-#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC 0x1f
-#define DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC 0x20
-#define DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC 0x21
-#define DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC 0x22
-#define DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC 0x23
-#define DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC 0x24
-#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC 0x25
-#define DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC 0x26
-#define DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC 0x27
-#define DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC 0x28
-#define DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC 0x29
-#define DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC 0x2a
-#define DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC 0x2b
-#define DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC 0x2c
-#define DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC 0x2d
-#define DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC 0x2e
-#define DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC 0x2f
-#define DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC 0x30
-#define DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC 0x31
-#define DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC 0x32
-#define DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC 0x33
-#define DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC 0x34
-#define DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC 0x35
-#define DTN_BPSEC_EDD_LAST_UPDATE_SRC 0x36
-#define DTN_BPSEC_EDD_LAST_RESET 0x37
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               DTN_BPSEC VARIABLE DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |total_bad_tx_blks    |This is the number of failed TX blocks|       |
- * |                     | (# failed BIB + # failed bcb).       |UINT   |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_BPSEC_VAR_TOTAL_BAD_TX_BLKS 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                DTN_BPSEC REPORT DEFINITIONS                                 +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |full_report          |all known meta-data, externally define|       |
- * |                     |d data, and variables                 |TNVC   |
- * +---------------------+--------------------------------------+-------+
- * |source_report        |security info by source               |TNVC   |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_BPSEC_RPTTPL_FULL_REPORT 0x00
-#define DTN_BPSEC_RPTTPL_SOURCE_REPORT 0x01
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 DTN_BPSEC TABLE DEFINITIONS                                 +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |keys                 |This table lists all keys in the secur|       |
- * |                     |ity policy database.                  |       |
- * +---------------------+--------------------------------------+-------+
- * |ciphersuites         |This table lists supported ciphersuite|       |
- * |                     |s.                                    |       |
- * +---------------------+--------------------------------------+-------+
- * |bib_rules            |BIB Rules.                            |       |
- * +---------------------+--------------------------------------+-------+
- * |bcb_rules            |BCB Rules.                            |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_BPSEC_TBLT_KEYS 0x00
-#define DTN_BPSEC_TBLT_CIPHERSUITES 0x01
-#define DTN_BPSEC_TBLT_BIB_RULES 0x02
-#define DTN_BPSEC_TBLT_BCB_RULES 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                DTN_BPSEC CONTROL DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |rst_all_cnts         |This control causes the Agent to reset|       |
- * |                     | all counts associated with block or b|       |
- * |                     |yte statistics and to set the Last Res|       |
- * |                     |et Time of the BPsec EDD data to the t|       |
- * |                     |ime when the control was run.         |       |
- * +---------------------+--------------------------------------+-------+
- * |rst_src_cnts         |This control causes the Agent to reset|       |
- * |                     | all counts (blocks and bytes) associa|       |
- * |                     |ted with a given bundle source and set|       |
- * |                     | the Last Reset Time of the source sta|       |
- * |                     |tistics to the time when the control w|       |
- * |                     |as run.                               |       |
- * +---------------------+--------------------------------------+-------+
- * |delete_key           |This control deletes a key from the BP|       |
- * |                     |sec system.                           |       |
- * +---------------------+--------------------------------------+-------+
- * |add_key              |This control adds a key to the BPsec s|       |
- * |                     |ystem.                                |       |
- * +---------------------+--------------------------------------+-------+
- * |add_bib_rule         |This control configures policy on the |       |
- * |                     |BPsec protocol implementation that des|       |
- * |                     |cribes how BIB blocks should be applie|       |
- * |                     |d to bundles in the system. This polic|       |
- * |                     |y is captured as a rule which states w|       |
- * |                     |hen transmitting a bundle from the giv|       |
- * |                     |en source endpoint ID to the given des|       |
- * |                     |tination endpoint ID, blocks of type t|       |
- * |                     |arget should have a BIB added to them |       |
- * |                     |using the given ciphersuite and the gi|       |
- * |                     |ven key.                              |       |
- * +---------------------+--------------------------------------+-------+
- * |del_bib_rule         |This control removes any configured po|       |
- * |                     |licy on the BPsec protocol implementat|       |
- * |                     |ion that describes how BIB blocks shou|       |
- * |                     |ld be applied to bundles in the system|       |
- * |                     |. A BIB policy is uniquely identified |       |
- * |                     |by a source endpoint Id, a destination|       |
- * |                     | Id, and a target block type.         |       |
- * +---------------------+--------------------------------------+-------+
- * |add_bcb_rule         |This control configures policy on the |       |
- * |                     |BPsec protocol implementation that des|       |
- * |                     |cribes how BCB blocks should be applie|       |
- * |                     |d to bundles in the system. This polic|       |
- * |                     |y is captured as a rule which states w|       |
- * |                     |hen transmitting a bundle from the giv|       |
- * |                     |en source endpoint id to the given des|       |
- * |                     |tination endpoint id, blocks of type t|       |
- * |                     |arget should have a bcb added to them |       |
- * |                     |using the given ciphersuite and the gi|       |
- * |                     |ven key.                              |       |
- * +---------------------+--------------------------------------+-------+
- * |del_bcb_rule         |This control removes any configured po|       |
- * |                     |licy on the BPsec protocol implementat|       |
- * |                     |ion that describes how BCB blocks shou|       |
- * |                     |ld be applied to bundles in the system|       |
- * |                     |. A bcb policy is uniquely identified |       |
- * |                     |by a source endpoint id, a destination|       |
- * |                     | endpoint id, and a target block type.|       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_BPSEC_CTRL_RST_ALL_CNTS 0x00
-#define DTN_BPSEC_CTRL_RST_SRC_CNTS 0x01
-#define DTN_BPSEC_CTRL_DELETE_KEY 0x02
-#define DTN_BPSEC_CTRL_ADD_KEY 0x03
-#define DTN_BPSEC_CTRL_ADD_BIB_RULE 0x04
-#define DTN_BPSEC_CTRL_DEL_BIB_RULE 0x05
-#define DTN_BPSEC_CTRL_ADD_BCB_RULE 0x06
-#define DTN_BPSEC_CTRL_DEL_BCB_RULE 0x07
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               DTN_BPSEC CONSTANT DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 DTN_BPSEC MACRO DEFINITIONS                                 +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               DTN_BPSEC OPERATOR DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-/* Initialization functions. */
-void dtn_bpsec_init();
-void dtn_bpsec_init_meta();
-void dtn_bpsec_init_cnst();
-void dtn_bpsec_init_edd();
-void dtn_bpsec_init_op();
-void dtn_bpsec_init_var();
-void dtn_bpsec_init_ctrl();
-void dtn_bpsec_init_mac();
-void dtn_bpsec_init_rpttpl();
-void dtn_bpsec_init_tblt();
-#endif /* _HAVE_DTN_BPSEC_ADM_ */
-#endif //ADM_BPSEC_H_
\ No newline at end of file
diff -ru --new-file ion-sf/bpv7/adm/adm_bpsec_impl.c ion-anms/bpv7/adm/adm_bpsec_impl.c
--- ion-sf/bpv7/adm/adm_bpsec_impl.c	2023-05-30 10:55:36.733112555 -0400
+++ ion-anms/bpv7/adm/adm_bpsec_impl.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1995 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bpsec_impl.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-/*   START CUSTOM INCLUDES HERE  */
-#include <math.h>
-
-#include "adm_bpsec_impl.h"
-#include "shared/primitives/report.h"
-#include "agent/rda.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-
-#include "adm_bpsec.h"
-#include "profiles.h"
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/adm/adm.h"
-#include "adm_bpsec_impl.h"
-
-/*   START CUSTOM FUNCTIONS HERE */
-
-
-static tnv_t *adm_bpsec_get_src_val(tnvc_t *parms, bpsec_instr_type_e type, query_type_e query)
-{
-    tnv_t *result = tnv_create();
-	char *eid_id = NULL;
-	uvast num = 0;
-	int success = ERROR;
-
-	result->type = AMP_TYPE_UNK;
-
-
-	if((eid_id = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) == NULL)
-	{
-		return result;
-	}
-
-	switch(query)
-	{
-	case SRC_BLK:     success = bpsec_instr_get_src_blk(eid_id, type, &num); break;
-	case SRC_BYTES:   success = bpsec_instr_get_src_bytes(eid_id, type, &num); break;
-	default: success = ERROR; break;
-	}
-
-	if(success != ERROR)
-	{
-		result->type = AMP_TYPE_UVAST;
-		result->value.as_uvast = num;
-	}
-
-	return result;
-}
-
-static tnv_t *adm_bpsec_get_tot_val(bpsec_instr_type_e type, query_type_e query)
-{
-        tnv_t *result = tnv_create();
-	uvast num = 0;
-	int8_t success = 0;
-
-	switch(query)
-	{
-	case TOTAL_BLK:   success = bpsec_instr_get_total_blk(type, &num); break;
-	case TOTAL_BYTES: success = bpsec_instr_get_total_bytes(type, &num); break;
-	default: success = ERROR; break;
-	}
-
-	if(success == ERROR)
-	{
-		result->type = AMP_TYPE_UNK;
-	}
-	else
-	{
-
-		result->type = AMP_TYPE_UVAST;
-		result->value.as_uvast = num;
-	}
-
-	return result;
-}
-
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_bpsec_setup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-void dtn_bpsec_cleanup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-
-/* Metadata Functions */
-
-
-tnv_t *dtn_bpsec_meta_name(tnvc_t *parms)
-{
-	return tnv_from_str("bpsec");
-}
-
-
-tnv_t *dtn_bpsec_meta_namespace(tnvc_t *parms)
-{
-	return tnv_from_str("DTN/bpsec");
-}
-
-
-tnv_t *dtn_bpsec_meta_version(tnvc_t *parms)
-{
-	return tnv_from_str("v1.0");
-}
-
-
-tnv_t *dtn_bpsec_meta_organization(tnvc_t *parms)
-{
-	return tnv_from_str("JHUAPL");
-}
-
-
-/* Constant Functions */
-/* Table Functions */
-
-
-/*
- * This table lists all keys in the security policy database.
- */
-tbl_t *dtn_bpsec_tblt_keys(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_keys BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_keys BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * This table lists supported ciphersuites.
- */
-tbl_t *dtn_bpsec_tblt_ciphersuites(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_ciphersuites BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_ciphersuites BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * BIB Rules.
- */
-tbl_t *dtn_bpsec_tblt_bib_rules(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_bib_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr sdr = getIonsdr();
-	Object listObj = 0;
-	Object	elt = 0;
-	OBJ_POINTER(BPsecBibRule, rule);
-	char strBuffer[SDRSTRING_BUFSZ];
-	tnvc_t *cur_row = NULL;
-	int len = 0;
-
-	if((listObj = sec_get_bpsecBibRuleList()) == 0)
-	{
-		AMP_DEBUG_ERR("dtn_bpsec_tblt_bib_rules","Cannot get list.", NULL);
-		tbl_release(table, 1);
-		return NULL;
-	}
-
-	if (sdr_begin_xn(sdr) < 0)
-	{
-		AMP_DEBUG_ERR("dtn_bpsec_tblt_bib_rules","Can't start transaction.", NULL);
-		tbl_release(table, 1);
-		return NULL;
-	}
-
-	for (elt = sdr_list_first(sdr, listObj); elt; elt = sdr_list_next(sdr, elt))
-	{
-
-		if((cur_row = tnvc_create(5)) != NULL)
-		{
-			GET_OBJ_POINTER(sdr, BPsecBibRule, rule, sdr_list_data(sdr, elt));
-
-			if(rule != NULL)
-			{
-				len = sdr_string_read(sdr, strBuffer, rule->securitySrcEid);
-				tnvc_insert(cur_row, tnv_from_str( (len > 0) ? strBuffer : "unk"));
-
-				len = sdr_string_read(sdr, strBuffer, rule->destEid);
-				tnvc_insert(cur_row, tnv_from_str( (len > 0) ? strBuffer : "unk"));
-
-				tnvc_insert(cur_row, tnv_from_uint(rule->blockType));
-				tnvc_insert(cur_row, tnv_from_str(rule->profileName));
-				tnvc_insert(cur_row, tnv_from_str(rule->keyName));
-
-				tbl_add_row(table, cur_row);
-			}
-			else
-			{
-				AMP_DEBUG_WARN("dtn_bpsec_tblt_bib_rules", "NULL rule?", NULL);
-			}
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_bpsec_tblt_bib_rules", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_bib_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * BCB Rules.
- */
-tbl_t *dtn_bpsec_tblt_bcb_rules(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_bcb_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr sdr = getIonsdr();
-	Object listObj = 0;
-	Object	elt = 0;
-	OBJ_POINTER(BPsecBcbRule, rule);
-	char strBuffer[SDRSTRING_BUFSZ];
-	tnvc_t *cur_row = NULL;
-	int len = 0;
-
-	if((listObj = sec_get_bpsecBcbRuleList()) == 0)
-	{
-		AMP_DEBUG_ERR("dtn_bpsec_tblt_bcb_rules","Cannot get list.", NULL);
-		tbl_release(table, 1);
-		return NULL;
-	}
-
-	if (sdr_begin_xn(sdr) < 0)
-	{
-		AMP_DEBUG_ERR("dtn_bpsec_tblt_bcb_rules","Can't start transaction.", NULL);
-		tbl_release(table, 1);
-		return NULL;
-	}
-
-	for (elt = sdr_list_first(sdr, listObj); elt; elt = sdr_list_next(sdr, elt))
-	{
-		if((cur_row = tnvc_create(5)) != NULL)
-		{
-			GET_OBJ_POINTER(sdr, BPsecBcbRule, rule, sdr_list_data(sdr, elt));
-
-			if(rule != NULL)
-			{
-				len = sdr_string_read(sdr, strBuffer, rule->securitySrcEid);
-				tnvc_insert(cur_row, tnv_from_str( (len > 0) ? strBuffer : "unk"));
-
-				len = sdr_string_read(sdr, strBuffer, rule->destEid);
-				tnvc_insert(cur_row, tnv_from_str( (len > 0) ? strBuffer : "unk"));
-
-				tnvc_insert(cur_row, tnv_from_uint(rule->blockType));
-				tnvc_insert(cur_row, tnv_from_str(rule->profileName));
-				tnvc_insert(cur_row, tnv_from_str(rule->keyName));
-
-				tbl_add_row(table, cur_row);
-			}
-			else
-			{
-				AMP_DEBUG_WARN("dtn_bpsec_tblt_bcb_rules", "NULL rule?", NULL);
-			}
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_bpsec_tblt_bcb_rules", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_bcb_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/* Collect Functions */
-/*
- * Total successfully Tx Bundle Confidentiality blocks
- */
-tnv_t *dtn_bpsec_get_num_good_tx_bcb_blk(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_tx_bcb_blk BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_TX_PASS, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_tx_bcb_blk BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total unsuccessfully Tx Block Confidentiality Block (BCB) blocks
- */
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blk(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_blk BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_TX_FAIL, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_blk BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total successfully Rx BCB blocks
- */
-tnv_t *dtn_bpsec_get_num_good_rx_bcb_blk(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_rx_bcb_blk BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_RX_PASS, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_rx_bcb_blk BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total unsuccessfully Rx BCB blocks
- */
-tnv_t *dtn_bpsec_get_num_bad_rx_bcb_blk(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_rx_bcb_blk BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_RX_FAIL, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bcb_blk BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total missing-on-RX BCB blocks
- */
-tnv_t *dtn_bpsec_get_num_missing_rx_bcb_blks(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_missing_rx_bcb_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_RX_MISS, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bcb_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total forward BCB blocks
- */
-tnv_t *dtn_bpsec_get_num_fwd_bcb_blks(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fwd_bcb_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_FWD, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fwd_bcb_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total successfully Tx BCB bytes
- */
-tnv_t *dtn_bpsec_get_num_good_tx_bcb_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_tx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_TX_PASS, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_tx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total unsuccessfully Tx BCB bytes
- */
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_TX_FAIL, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total unsuccessfully Tx BCB blocks
- */
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blks(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_TX_FAIL, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total successfully Rx BCB bytes
- */
-tnv_t *dtn_bpsec_get_num_good_rx_bcb_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_rx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_RX_PASS, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_rx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total unsuccessfully Rx BCB bytes
- */
-tnv_t *dtn_bpsec_get_num_bad_rx_bcb_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_rx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_RX_FAIL, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total missing-on-Rx BCB bytes
- */
-tnv_t *dtn_bpsec_get_num_missing_rx_bcb_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_missing_rx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_RX_MISS, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total forwarded BCB bytes
- */
-tnv_t *dtn_bpsec_get_num_fwd_bcb_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fwd_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BCB_FWD, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fwd_bcb_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total successfully Tx Block Integrity Block (BIB) blocks
- */
-tnv_t *dtn_bpsec_get_num_good_tx_bib_blks(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_tx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_TX_PASS, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_tx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total unsuccessfully Tx BIB blocks
- */
-tnv_t *dtn_bpsec_get_num_bad_tx_bib_blks(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_tx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_TX_FAIL, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total successfully Rx BIB blocks
- */
-tnv_t *dtn_bpsec_get_num_good_rx_bib_blks(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_rx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_RX_PASS, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_rx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total unsuccessfully Rx BIB blocks
- */
-tnv_t *dtn_bpsec_get_num_bad_rx_bib_blks(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_rx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_RX_FAIL, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total missing-on-Rx BIB blocks
- */
-tnv_t *dtn_bpsec_get_num_miss_rx_bib_blks(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_miss_rx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_RX_MISS, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_miss_rx_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total forwarded BIB blocks
- */
-tnv_t *dtn_bpsec_get_num_fwd_bib_blks(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fwd_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_FWD, TOTAL_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fwd_bib_blks BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total successfully Tx BIB bytes
- */
-tnv_t *dtn_bpsec_get_num_good_tx_bib_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_tx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_TX_PASS, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_tx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total unsuccessfully Tx BIB bytes
- */
-tnv_t *dtn_bpsec_get_num_bad_tx_bib_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_tx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_TX_FAIL, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total successfully Rx BIB bytes
- */
-tnv_t *dtn_bpsec_get_num_good_rx_bib_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_rx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_RX_PASS, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_rx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total unsuccessfully Rx BIB bytes
- */
-tnv_t *dtn_bpsec_get_num_bad_rx_bib_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_rx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_RX_FAIL, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total missing-on-Rx BIB bytes
- */
-tnv_t *dtn_bpsec_get_num_miss_rx_bib_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_miss_rx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_RX_MISS, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_miss_rx_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Total forwarded BIB bytes
- */
-tnv_t *dtn_bpsec_get_num_fwd_bib_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fwd_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_tot_val( BIB_FWD, TOTAL_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fwd_bib_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Last BPSEC update
- */
-tnv_t *dtn_bpsec_get_last_update(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_last_update BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = tnv_create();
-	result->type = AMP_TYPE_UNK;
-	if(bpsec_instr_get_tot_update((time_t*)&(result->value.as_uint)) != ERROR)
-	{
-		result->type = AMP_TYPE_TS;
-	}
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_last_update BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of known keys
- */
-tnv_t *dtn_bpsec_get_num_known_keys(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_known_keys BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	uint32_t size = 0;
-	result = tnv_create();
-	result->type = AMP_TYPE_UINT;
-	result->value.as_uint = bpsec_instr_get_num_keys((int*)&size);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_known_keys BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Known key names
- */
-tnv_t *dtn_bpsec_get_key_names(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_key_names BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *tmp = bpsec_instr_get_keynames();
-
-	result = tnv_create();
-	result->type = AMP_TYPE_UNK;
-	/* TMP is allocated using MTAKE. We need to move it to
-	 * something using STAKE.
-	 */
-	if(tmp != NULL)
-	{
-		uint32_t size = strlen(tmp) + 1;
-		if((result->value.as_ptr = STAKE(size)) == NULL)
-		{
-			MRELEASE(tmp);
-			return result;
-		}
-		memcpy(result->value.as_ptr, tmp, size);
-		MRELEASE(tmp);
-
-		result->type = AMP_TYPE_STR;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_key_names BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Known ciphersuite names
- */
-tnv_t *dtn_bpsec_get_ciphersuite_names(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_ciphersuite_names BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *tmp = bpsec_instr_get_csnames();
-
-	result = tnv_create();
-	result->type = AMP_TYPE_UNK;
-	/* TMP is allocated using MTAKE. We need to move it to
-	 * something using STAKE.
-	 */
-	if(tmp != NULL)
-	{
-		uint32_t size = strlen(tmp) + 1;
-		if((result->value.as_ptr = STAKE(size)) == NULL)
-		{
-			MRELEASE(tmp);
-			return result;
-		}
-		memcpy(result->value.as_ptr, tmp, size);
-		MRELEASE(tmp);
-
-		result->type = AMP_TYPE_STR;
-	}
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_ciphersuite_names BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Known rule sources
- */
-tnv_t *dtn_bpsec_get_rule_source(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_rule_source BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *tmp = bpsec_instr_get_srcnames();
-
-	result = tnv_create();
-	result->type = AMP_TYPE_UNK;
-	/* TMP is allocated using MTAKE. We need to move it to
-	 * something using STAKE.
-	 */
-	if(tmp != NULL)
-	{
-		uint32_t size = strlen(tmp) + 1;
-		if((result->value.as_ptr = STAKE(size)) == NULL)
-		{
-			MRELEASE(tmp);
-			return result;
-		}
-		memcpy(result->value.as_ptr, tmp, size);
-		result->type = AMP_TYPE_STR;
-	}
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_rule_source BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of successfully Tx BCB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_good_tx_bcb_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_tx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_TX_PASS, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_tx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of failed TX BCB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_TX_FAIL, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of successfully Rx BCB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_good_rx_bcb_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_rx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_RX_PASS, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_rx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of failed RX BCB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_bad_rx_bcb_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_rx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_RX_FAIL, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of missing-onRX BCB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_missing_rx_bcb_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_missing_rx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_RX_MISS, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of forwarded BCB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_fwd_bcb_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fwd_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_FWD, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fwd_bcb_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of successfully Tx bcb bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_good_tx_bcb_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_tx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_TX_PASS, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_tx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of failed Tx bcb bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_TX_FAIL, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of successfully Rx bcb bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_good_rx_bcb_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_rx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_RX_PASS, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_rx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of failed Rx bcb bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_bad_rx_bcb_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_rx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_RX_FAIL, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of missing-on-Rx bcb bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_missing_rx_bcb_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_missing_rx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_RX_MISS, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of forwarded bcb bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_fwd_bcb_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fwd_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BCB_FWD, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fwd_bcb_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of successfully Tx BIB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_good_tx_bib_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_tx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_TX_PASS, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_tx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of failed Tx BIB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_bad_tx_bib_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_tx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_TX_FAIL, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of successfully Rx BIB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_good_rx_bib_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_rx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_RX_PASS, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_rx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of failed Rx BIB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_bad_rx_bib_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_rx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_RX_FAIL, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of missing-on-Rx BIB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_miss_rx_bib_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_miss_rx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_RX_MISS, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_miss_rx_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of forwarded BIB blocks from SRC
- */
-tnv_t *dtn_bpsec_get_num_fwd_bib_blks_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fwd_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_FWD, SRC_BLK);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fwd_bib_blks_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of successfully Tx BIB bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_good_tx_bib_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_tx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_TX_PASS, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_tx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of failed Tx BIB bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_bad_tx_bib_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_tx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_TX_FAIL, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of successfully Rx BIB bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_good_rx_bib_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_good_rx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_RX_PASS, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_good_rx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of failed Rx BIB bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_bad_rx_bib_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_bad_rx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_RX_FAIL, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of missing-on-Rx BIB bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_missing_rx_bib_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_missing_rx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return adm_bpsec_get_src_val(parms, BIB_RX_MISS, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Number of forwarded BIB bytes from SRC
- */
-tnv_t *dtn_bpsec_get_num_fwd_bib_bytes_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_fwd_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_bpsec_get_src_val(parms, BIB_FWD, SRC_BYTES);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_fwd_bib_bytes_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Last BPSEC update from SRC
- */
-tnv_t *dtn_bpsec_get_last_update_src(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_last_update_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	time_t time = 0;
-	char *name = NULL;
-	int success = 0;
-
-	result = tnv_create();
-	result->type = AMP_TYPE_UNK;
-
-	if((name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) == NULL)
-	{
-		return result;
-	}
-
-	if(bpsec_instr_get_src_update(name, &time) != ERROR)
-	{
-		result->type = AMP_TYPE_TS;
-		result->value.as_uint = time;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_last_update_src BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Last reset
- */
-tnv_t *dtn_bpsec_get_last_reset(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_last_reset BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	bpsec_instr_misc_t misc;
-
-	result = tnv_create();
-	if(bpsec_instr_get_misc(&misc) == ERROR)
-	{
-		result->type = AMP_TYPE_UNK;
-		return result;
-	}
-
-	result->type = AMP_TYPE_TS;
-	result->value.as_uint = misc.last_reset;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_last_reset BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* Control Functions */
-
-/*
- * This control causes the Agent to reset all counts associated with block or byte statistics and to se
- * t the Last Reset Time of the BPsec EDD data to the time when the control was run.
- */
-tnv_t *dtn_bpsec_ctrl_rst_all_cnts(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_rst_all_cnts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	bpsec_instr_reset();
-	*status = CTRL_SUCCESS;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_rst_all_cnts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control causes the Agent to reset all counts (blocks and bytes) associated with a given bundle 
- * source and set the Last Reset Time of the source statistics to the time when the control was run.
- */
-tnv_t *dtn_bpsec_ctrl_rst_src_cnts(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_rst_src_cnts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *src = NULL;
-	int success = 0;
-
-	/* Step 1: Grab the MID defining the new computed definition. */
-	if((src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) != NULL)
-	{
-		bpsec_instr_reset_src(src);
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_rst_src_cnts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control deletes a key from the BPsec system.
- */
-tnv_t *dtn_bpsec_ctrl_delete_key(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_delete_key BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *name = NULL;
-	int success = 0;
-	/* Step 1: Grab the name of the key to delete. */
-	if((name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * Step 2: Make sure key to be deleted is not an active key. Deleting
-	 * an active key can lock someone out of the system
-	 */
-	if(sec_activeKey(name) != 0)
-	{
-		AMP_DEBUG_WARN("adm_bpsec_ctrl_delete_key","Can't remove active key %s", name);
-		return NULL;
-	}
-
-	if(sec_removeKey(name) == 1)
-	{
-		*status = CTRL_SUCCESS;
-	}
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_delete_key BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control adds a key to the BPsec system.
- */
-tnv_t *dtn_bpsec_ctrl_add_key(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_add_key BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *name = NULL;
-	blob_t *value = NULL;
-	int success = 0;
-	/* Step 1: Grab the name of the new key. */
-	if((name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) == NULL)
-	{
-		return NULL;
-	}
-
-	/* Step 2: Grab the key value. */
-	if((value = adm_get_parm_obj(parms, 1, AMP_TYPE_STR)) == NULL)
-	{
-		return NULL;
-	}
-
-	if(sec_addKeyValue(name, (char *)value->value, value->length) == 1)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_add_key BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control configures policy on the BPsec protocol implementation that describes how BIB blocks sh
- * ould be applied to bundles in the system. This policy is captured as a rule which states when transm
- * itting a bundle from the given source endpoint ID to the given destination endpoint ID, blocks of ty
- * pe target should have a BIB added to them using the given ciphersuite and the given key.
- */
-tnv_t *dtn_bpsec_ctrl_add_bib_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_add_bib_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *src = NULL;
-	char *dst = NULL;
-	uint32_t tgt = 0;
-	char *cs = NULL;
-	char *key = NULL;
-	int success = 0;
-	/* Step 1: Grab the name of the new key. */
-	src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	dst = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	tgt = adm_get_parm_uint(parms, 2, &success);
-	cs = adm_get_parm_obj(parms, 3, AMP_TYPE_STR);
-	key = adm_get_parm_obj(parms, 4, AMP_TYPE_STR);
-
-	if(get_bib_prof_by_name(cs) != NULL)
-	{
-		Object addr;
-		Object elt;
-
-		/* Step 3: Check to see if key exists. */
-		sec_findKey(key, &addr, &elt);
-		if(elt != 0)
-		{
-			/* Step 4: Update the BCB Rule. */
-			if(sec_addBPsecBibRule(src, dst, tgt, cs, key) == 1)
-			{
-				*status = CTRL_SUCCESS;
-			}
-			else
-			{
-				AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bib_rule", "Can't update rule.", NULL);
-			}
-		}
-		else
-		{
-			AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bib_rule", "Key %s doesn't exist.", key);
-		}
-	}
-	else
-	{
-		AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bib_rule", "CIphersuite %s not supported.", cs);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_add_bib_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control removes any configured policy on the BPsec protocol implementation that describes how B
- * IB blocks should be applied to bundles in the system. A BIB policy is uniquely identified by a sourc
- * e endpoint Id, a destination Id, and a target block type.
- */
-tnv_t *dtn_bpsec_ctrl_del_bib_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_del_bib_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *src = NULL;
-	char *dst = NULL;
-	uint32_t tgt = 0;
-	int success = 0;
-	/* Step 1: Grab the name of the new key. */
-	src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	dst = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	tgt = adm_get_parm_uint(parms, 2, &success);
-
-
-	if(sec_removeBPsecBibRule(src, dst, tgt) == 1)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_del_bib_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control configures policy on the BPsec protocol implementation that describes how BCB blocks sh
- * ould be applied to bundles in the system. This policy is captured as a rule which states when transm
- * itting a bundle from the given source endpoint id to the given destination endpoint id, blocks of ty
- * pe target should have a bcb added to them using the given ciphersuite and the given key.
- */
-tnv_t *dtn_bpsec_ctrl_add_bcb_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_add_bcb_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *src = NULL;
-	char *dst = NULL;
-	uint32_t tgt = 0;
-	char *cs = NULL;
-	char *key = NULL;
-	int success = 0;
-
-	/* Step 1: Grab the name of the new key. */
-	src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	dst = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	tgt = adm_get_parm_int(parms, 2, &success);
-	cs = adm_get_parm_obj(parms, 3, AMP_TYPE_STR);
-	key = adm_get_parm_obj(parms, 4, AMP_TYPE_STR);
-
-
-	if(get_bcb_prof_by_name(cs) != NULL)
-	{
-		Object addr;
-		Object elt;
-
-		/* Step 3: Check to see if key exists. */
-		sec_findKey(key, &addr, &elt);
-		if(elt != 0)
-		{
-			/* Step 4: Update the BCB Rule. */
-			if(sec_addBPsecBcbRule(src, dst, tgt, cs, key) == 1)
-			{
-				*status = CTRL_SUCCESS;
-			}
-			else
-			{
-				AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bcbrule", "Can't add rule.", NULL);
-			}
-		}
-		else
-		{
-			AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bcbrule", "Key %s doesn't exist.", key);
-		}
-	}
-	else
-	{
-		AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bcbrule", "Ciphersuite %s not supported.", cs);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_add_bcb_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control removes any configured policy on the BPsec protocol implementation that describes how B
- * CB blocks should be applied to bundles in the system. A bcb policy is uniquely identified by a sourc
- * e endpoint id, a destination endpoint id, and a target block type.
- */
-tnv_t *dtn_bpsec_ctrl_del_bcb_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_del_bcb_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *src = NULL;
-	char *dst = NULL;
-	uint32_t tgt = 0;
-	int success = 0;
-
-	/* Step 1: Grab the name of the new key. */
-	src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	dst = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	tgt = adm_get_parm_int(parms, 2, &success);
-
-	if(sec_removeBPsecBcbRule(src, dst, tgt) == 1)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_del_bcb_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* OP Functions */
diff -ru --new-file ion-sf/bpv7/adm/adm_bpsec_impl.h ion-anms/bpv7/adm/adm_bpsec_impl.h
--- ion-sf/bpv7/adm/adm_bpsec_impl.h	2023-05-30 10:55:36.733112555 -0400
+++ ion-anms/bpv7/adm/adm_bpsec_impl.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,156 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bpsec_impl.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-#ifndef ADM_BPSEC_IMPL_H_
-#define ADM_BPSEC_IMPL_H_
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "adm_bpsec.h"
-//#include "shared/adm/adm_bp.h"
-#include "shared/primitives/expr.h"
-
-#include "library/ext/bpsec/bpsec_instr.h"
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/utils/utils.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-#include "shared/primitives/tnv.h"
-
-/*   START typeENUM */
-
-typedef enum
-{
-	TOTAL_BLK,
-	TOTAL_BYTES,
-	SRC_BLK,
-	SRC_BYTES
-} query_type_e;
-
-typedef enum
-{
-    BIB_RULE,
-	BCB_RULE
-} bpsec_rule_type_e;
-
-/*   STOP typeENUM  */
-
-void name_adm_init_agent();
-
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                     Retrieval Functions                                     +
- * +---------------------------------------------------------------------------------------------+
- */
-/*   START CUSTOM FUNCTIONS HERE */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_bpsec_setup();
-void dtn_bpsec_cleanup();
-
-
-/* Metadata Functions */
-tnv_t *dtn_bpsec_meta_name(tnvc_t *parms);
-tnv_t *dtn_bpsec_meta_namespace(tnvc_t *parms);
-tnv_t *dtn_bpsec_meta_version(tnvc_t *parms);
-tnv_t *dtn_bpsec_meta_organization(tnvc_t *parms);
-
-/* Constant Functions */
-
-/* Collect Functions */
-tnv_t *dtn_bpsec_get_num_good_tx_bcb_blk(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blk(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_rx_bcb_blk(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_rx_bcb_blk(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_missing_rx_bcb_blks(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_fwd_bcb_blks(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_tx_bcb_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blks(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_rx_bcb_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_rx_bcb_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_missing_rx_bcb_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_fwd_bcb_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_tx_bib_blks(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_tx_bib_blks(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_rx_bib_blks(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_rx_bib_blks(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_miss_rx_bib_blks(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_fwd_bib_blks(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_tx_bib_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_tx_bib_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_rx_bib_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_rx_bib_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_miss_rx_bib_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_fwd_bib_bytes(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_last_update(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_known_keys(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_key_names(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_ciphersuite_names(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_rule_source(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_tx_bcb_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_rx_bcb_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_rx_bcb_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_missing_rx_bcb_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_fwd_bcb_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_tx_bcb_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_tx_bcb_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_rx_bcb_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_rx_bcb_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_missing_rx_bcb_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_fwd_bcb_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_tx_bib_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_tx_bib_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_rx_bib_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_rx_bib_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_miss_rx_bib_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_fwd_bib_blks_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_tx_bib_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_tx_bib_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_good_rx_bib_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_bad_rx_bib_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_missing_rx_bib_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_num_fwd_bib_bytes_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_last_update_src(tnvc_t *parms);
-tnv_t *dtn_bpsec_get_last_reset(tnvc_t *parms);
-
-
-/* Control Functions */
-tnv_t *dtn_bpsec_ctrl_rst_all_cnts(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_bpsec_ctrl_rst_src_cnts(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_bpsec_ctrl_delete_key(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_bpsec_ctrl_add_key(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_bpsec_ctrl_add_bib_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_bpsec_ctrl_del_bib_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_bpsec_ctrl_add_bcb_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_bpsec_ctrl_del_bcb_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-
-
-/* OP Functions */
-
-
-/* Table Build Functions */
-tbl_t *dtn_bpsec_tblt_keys(ari_t *id);
-tbl_t *dtn_bpsec_tblt_ciphersuites(ari_t *id);
-tbl_t *dtn_bpsec_tblt_bib_rules(ari_t *id);
-tbl_t *dtn_bpsec_tblt_bcb_rules(ari_t *id);
-
-#endif //ADM_BPSEC_IMPL_H_
diff -ru --new-file ion-sf/bpv7/adm/adm_bpsec_mgr.c ion-anms/bpv7/adm/adm_bpsec_mgr.c
--- ion-sf/bpv7/adm/adm_bpsec_mgr.c	2023-05-30 10:55:36.733112555 -0400
+++ ion-anms/bpv7/adm/adm_bpsec_mgr.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,576 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_bpsec_mgr.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_bpsec.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "metadata.h"
-#include "nm_mgr_ui.h"
-
-
-#include "adm_amp_agent.h"
-
-
-#define _HAVE_DTN_BPSEC_ADM_
-#ifdef _HAVE_DTN_BPSEC_ADM_
-static vec_idx_t g_dtn_bpsec_idx[11];
-
-void dtn_bpsec_init()
-{
-	adm_add_adm_info("dtn_bpsec", ADM_ENUM_DTN_BPSEC);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_RPTT_IDX), &(g_dtn_bpsec_idx[ADM_RPTT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_EDD_IDX), &(g_dtn_bpsec_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_CTRL_IDX), &(g_dtn_bpsec_idx[ADM_CTRL_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_META_IDX), &(g_dtn_bpsec_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_TBLT_IDX), &(g_dtn_bpsec_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_VAR_IDX), &(g_dtn_bpsec_idx[ADM_VAR_IDX]));
-
-
-	dtn_bpsec_init_meta();
-	dtn_bpsec_init_cnst();
-	dtn_bpsec_init_edd();
-	dtn_bpsec_init_op();
-	dtn_bpsec_init_var();
-	dtn_bpsec_init_ctrl();
-	dtn_bpsec_init_mac();
-	dtn_bpsec_init_rpttpl();
-	dtn_bpsec_init_tblt();
-}
-
-void dtn_bpsec_init_meta()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_NAME);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "name", "The human-readable name of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_NAMESPACE);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "namespace", "The namespace of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_VERSION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "version", "The version of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_ORGANIZATION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "organization", "The name of the issuing organization of the ADM.");
-
-}
-
-void dtn_bpsec_init_cnst()
-{
-
-}
-
-void dtn_bpsec_init_edd()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bcb_blk", "Total successfully Tx Bundle Confidentiality blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_blk", "Total unsuccessfully Tx Block Confidentiality Block (BCB) blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bcb_blk", "Total successfully Rx BCB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bcb_blk", "Total unsuccessfully Rx BCB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bcb_blks", "Total missing-on-RX BCB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bcb_blks", "Total forward BCB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bcb_bytes", "Total successfully Tx BCB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_bytes", "Total unsuccessfully Tx BCB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_blks", "Total unsuccessfully Tx BCB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bcb_bytes", "Total successfully Rx BCB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bcb_bytes", "Total unsuccessfully Rx BCB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bcb_bytes", "Total missing-on-Rx BCB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bcb_bytes", "Total forwarded BCB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bib_blks", "Total successfully Tx Block Integrity Block (BIB) blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bib_blks", "Total unsuccessfully Tx BIB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bib_blks", "Total successfully Rx BIB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bib_blks", "Total unsuccessfully Rx BIB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_miss_rx_bib_blks", "Total missing-on-Rx BIB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bib_blks", "Total forwarded BIB blocks");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bib_bytes", "Total successfully Tx BIB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bib_bytes", "Total unsuccessfully Tx BIB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bib_bytes", "Total successfully Rx BIB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bib_bytes", "Total unsuccessfully Rx BIB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_miss_rx_bib_bytes", "Total missing-on-Rx BIB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bib_bytes", "Total forwarded BIB bytes");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_TV, id, ADM_ENUM_DTN_BPSEC, "last_update", "Last BPSEC update");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_KNOWN_KEYS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_known_keys", "Number of known keys");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_KEY_NAMES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "key_names", "Known key names");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_CIPHERSUITE_NAMES);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "ciphersuite_names", "Known ciphersuite names");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_RULE_SOURCE);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "rule_source", "Known rule sources");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bcb_blks_src", "Number of successfully Tx BCB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_blks_src", "Number of failed TX BCB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bcb_blks_src", "Number of successfully Rx BCB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bcb_blks_src", "Number of failed RX BCB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bcb_blks_src", "Number of missing-onRX BCB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bcb_blks_src", "Number of forwarded BCB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bcb_bytes_src", "Number of successfully Tx bcb bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_bytes_src", "Number of failed Tx bcb bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bcb_bytes_src", "Number of successfully Rx bcb bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bcb_bytes_src", "Number of failed Rx bcb bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bcb_bytes_src", "Number of missing-on-Rx bcb bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bcb_bytes_src", "Number of forwarded bcb bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bib_blks_src", "Number of successfully Tx BIB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bib_blks_src", "Number of failed Tx BIB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bib_blks_src", "Number of successfully Rx BIB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bib_blks_src", "Number of failed Rx BIB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_miss_rx_bib_blks_src", "Number of missing-on-Rx BIB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bib_blks_src", "Number of forwarded BIB blocks from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bib_bytes_src", "Number of successfully Tx BIB bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bib_bytes_src", "Number of failed Tx BIB bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bib_bytes_src", "Number of successfully Rx BIB bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bib_bytes_src", "Number of failed Rx BIB bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bib_bytes_src", "Number of missing-on-Rx BIB bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bib_bytes_src", "Number of forwarded BIB bytes from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE_SRC);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_TV, id, ADM_ENUM_DTN_BPSEC, "last_update_src", "Last BPSEC update from SRC");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_RESET);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_TV, id, ADM_ENUM_DTN_BPSEC, "last_reset", "Last reset");
-
-	meta_add_parm(meta, "Src", AMP_TYPE_STR);
-}
-
-void dtn_bpsec_init_op()
-{
-
-}
-
-void dtn_bpsec_init_var()
-{
-
-	ari_t *id = NULL;
-
-	expr_t *expr = NULL;
-
-
-	/* TOTAL_BAD_TX_BLKS */
-
-	id = adm_build_ari(AMP_TYPE_VAR, 0, g_dtn_bpsec_idx[ADM_VAR_IDX], DTN_BPSEC_VAR_TOTAL_BAD_TX_BLKS);
-	expr = expr_create(AMP_TYPE_UINT);
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS));
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS));
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUINT));
-	adm_add_var_from_expr(id, AMP_TYPE_UINT, expr);
-	meta_add_var(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "total_bad_tx_blks", "This is the number of failed TX blocks (# failed BIB + # failed bcb).");
-
-}
-
-void dtn_bpsec_init_ctrl()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-
-	/* RST_ALL_CNTS */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 0, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_RST_ALL_CNTS);
-	adm_add_ctrldef_ari(id, 0, NULL);
-	meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "rst_all_cnts", "This control causes the Agent to reset all counts associated with block or byte statistics and to set the Last Reset Time of the BPsec EDD data to the time when the control was run.");
-
-
-	/* RST_SRC_CNTS */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_RST_SRC_CNTS);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "rst_src_cnts", "This control causes the Agent to reset all counts (blocks and bytes) associated with a given bundle source and set the Last Reset Time of the source statistics to the time when the control was run.");
-
-	meta_add_parm(meta, "src", AMP_TYPE_STR);
-
-	/* DELETE_KEY */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DELETE_KEY);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "delete_key", "This control deletes a key from the BPsec system.");
-
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-
-	/* ADD_KEY */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_KEY);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "add_key", "This control adds a key to the BPsec system.");
-
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "keyData", AMP_TYPE_BYTESTR);
-
-	/* ADD_BIB_RULE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_BIB_RULE);
-	adm_add_ctrldef_ari(id, 5, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "add_bib_rule", "This control configures policy on the BPsec protocol implementation that describes how BIB blocks should be applied to bundles in the system. This policy is captured as a rule which states when transmitting a bundle from the given source endpoint ID to the given destination endpoint ID, blocks of type target should have a BIB added to them using the given ciphersuite and the given key.");
-
-	meta_add_parm(meta, "source", AMP_TYPE_STR);
-	meta_add_parm(meta, "destination", AMP_TYPE_STR);
-	meta_add_parm(meta, "target", AMP_TYPE_INT);
-	meta_add_parm(meta, "ciphersuiteId", AMP_TYPE_STR);
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-
-	/* DEL_BIB_RULE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DEL_BIB_RULE);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "del_bib_rule", "This control removes any configured policy on the BPsec protocol implementation that describes how BIB blocks should be applied to bundles in the system. A BIB policy is uniquely identified by a source endpoint Id, a destination Id, and a target block type.");
-
-	meta_add_parm(meta, "source", AMP_TYPE_STR);
-	meta_add_parm(meta, "destination", AMP_TYPE_STR);
-	meta_add_parm(meta, "target", AMP_TYPE_INT);
-
-	/* ADD_BCB_RULE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_BCB_RULE);
-	adm_add_ctrldef_ari(id, 5, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "add_bcb_rule", "This control configures policy on the BPsec protocol implementation that describes how BCB blocks should be applied to bundles in the system. This policy is captured as a rule which states when transmitting a bundle from the given source endpoint id to the given destination endpoint id, blocks of type target should have a bcb added to them using the given ciphersuite and the given key.");
-
-	meta_add_parm(meta, "source", AMP_TYPE_STR);
-	meta_add_parm(meta, "destination", AMP_TYPE_STR);
-	meta_add_parm(meta, "target", AMP_TYPE_INT);
-	meta_add_parm(meta, "ciphersuiteId", AMP_TYPE_STR);
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-
-	/* DEL_BCB_RULE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DEL_BCB_RULE);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "del_bcb_rule", "This control removes any configured policy on the BPsec protocol implementation that describes how BCB blocks should be applied to bundles in the system. A bcb policy is uniquely identified by a source endpoint id, a destination endpoint id, and a target block type.");
-
-	meta_add_parm(meta, "source", AMP_TYPE_STR);
-	meta_add_parm(meta, "destination", AMP_TYPE_STR);
-	meta_add_parm(meta, "target", AMP_TYPE_INT);
-}
-
-void dtn_bpsec_init_mac()
-{
-
-}
-
-void dtn_bpsec_init_rpttpl()
-{
-
-	metadata_t *meta = NULL;
-
-	rpttpl_t *def = NULL;
-
-	/* FULL_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_dtn_bpsec_idx[ADM_RPTT_IDX], DTN_BPSEC_RPTTPL_FULL_REPORT));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_KNOWN_KEYS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_KEY_NAMES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_CIPHERSUITE_NAMES));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_RULE_SOURCE));
-	adm_add_rpttpl(def);
-	meta_add_rpttpl(def->id, ADM_ENUM_DTN_BPSEC, "full_report", "all known meta-data, externally defined data, and variables");
-	/* SOURCE_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_bpsec_idx[ADM_RPTT_IDX], DTN_BPSEC_RPTTPL_SOURCE_REPORT));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_RESET, tnv_from_map(AMP_TYPE_STR, 0)));
-	adm_add_rpttpl(def);
-	meta = meta_add_rpttpl(def->id, ADM_ENUM_DTN_BPSEC, "source_report", "security info by source");
-	meta_add_parm(meta, "Source", AMP_TYPE_STR);
-}
-
-void dtn_bpsec_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* KEYS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_KEYS), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "key_name");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_BPSEC, "keys", "This table lists all keys in the security policy database.");
-
-	/* CIPHERSUITES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_CIPHERSUITES), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "csname");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_BPSEC, "ciphersuites", "This table lists supported ciphersuites.");
-
-	/* BIB_RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_BIB_RULES), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "SrcEid");
-	tblt_add_col(def, AMP_TYPE_STR, "DestEid");
-	tblt_add_col(def, AMP_TYPE_UINT, "TgtBlk");
-	tblt_add_col(def, AMP_TYPE_STR, "csName");
-	tblt_add_col(def, AMP_TYPE_STR, "keyName");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_BPSEC, "bib_rules", "BIB Rules.");
-
-	/* BCB_RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_BCB_RULES), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "SrcEid");
-	tblt_add_col(def, AMP_TYPE_STR, "DestEid");
-	tblt_add_col(def, AMP_TYPE_UINT, "TgtBlk");
-	tblt_add_col(def, AMP_TYPE_STR, "csName");
-	tblt_add_col(def, AMP_TYPE_STR, "keyName");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_BPSEC, "bcb_rules", "BCB Rules.");
-}
-
-#endif // _HAVE_DTN_BPSEC_ADM_
diff -ru --new-file ion-sf/bpv7/adm/adm_ion_bp_admin_agent.c ion-anms/bpv7/adm/adm_ion_bp_admin_agent.c
--- ion-sf/bpv7/adm/adm_ion_bp_admin_agent.c	2023-05-30 10:55:36.733112555 -0400
+++ ion-anms/bpv7/adm/adm_ion_bp_admin_agent.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,189 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_bp_admin_agent.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ion_bp_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "adm_ion_bp_admin_impl.h"
-#include "agent/rda.h"
-
-
-
-#define _HAVE_DTN_ION_BPADMIN_ADM_
-#ifdef _HAVE_DTN_ION_BPADMIN_ADM_
-
-static vec_idx_t g_dtn_ion_bpadmin_idx[11];
-
-void dtn_ion_bpadmin_init()
-{
-	adm_add_adm_info("dtn_ion_bpadmin", ADM_ENUM_DTN_ION_BPADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_bpadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_bpadmin_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_bpadmin_setup();
-	dtn_ion_bpadmin_init_meta();
-	dtn_ion_bpadmin_init_cnst();
-	dtn_ion_bpadmin_init_edd();
-	dtn_ion_bpadmin_init_op();
-	dtn_ion_bpadmin_init_var();
-	dtn_ion_bpadmin_init_ctrl();
-	dtn_ion_bpadmin_init_mac();
-	dtn_ion_bpadmin_init_rpttpl();
-	dtn_ion_bpadmin_init_tblt();
-}
-
-void dtn_ion_bpadmin_init_meta()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_NAME), dtn_ion_bpadmin_meta_name);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_NAMESPACE), dtn_ion_bpadmin_meta_namespace);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_VERSION), dtn_ion_bpadmin_meta_version);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_ORGANIZATION), dtn_ion_bpadmin_meta_organization);
-}
-
-void dtn_ion_bpadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_bpadmin_init_edd()
-{
-
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_bpadmin_idx[ADM_EDD_IDX], DTN_ION_BPADMIN_EDD_BP_VERSION), dtn_ion_bpadmin_get_bp_version);
-}
-
-void dtn_ion_bpadmin_init_op()
-{
-
-}
-
-void dtn_ion_bpadmin_init_var()
-{
-
-}
-
-void dtn_ion_bpadmin_init_ctrl()
-{
-
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_ADD, 3, dtn_ion_bpadmin_ctrl_endpoint_add);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_CHANGE, 3, dtn_ion_bpadmin_ctrl_endpoint_change);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_DEL, 1, dtn_ion_bpadmin_ctrl_endpoint_del);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_ADD, 3, dtn_ion_bpadmin_ctrl_induct_add);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_CHANGE, 3, dtn_ion_bpadmin_ctrl_induct_change);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_DEL, 2, dtn_ion_bpadmin_ctrl_induct_del);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_START, 2, dtn_ion_bpadmin_ctrl_induct_start);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_STOP, 2, dtn_ion_bpadmin_ctrl_induct_stop);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_MANAGE_HEAP_MAX, 1, dtn_ion_bpadmin_ctrl_manage_heap_max);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_ADD, 4, dtn_ion_bpadmin_ctrl_outduct_add);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_CHANGE, 4, dtn_ion_bpadmin_ctrl_outduct_change);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_DEL, 2, dtn_ion_bpadmin_ctrl_outduct_del);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_START, 2, dtn_ion_bpadmin_ctrl_outduct_start);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_BLOCK, 1, dtn_ion_bpadmin_ctrl_egress_plan_block);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_UNBLOCK, 1, dtn_ion_bpadmin_ctrl_egress_plan_unblock);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_STOP, 2, dtn_ion_bpadmin_ctrl_outduct_stop);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_ADD, 4, dtn_ion_bpadmin_ctrl_protocol_add);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_DEL, 1, dtn_ion_bpadmin_ctrl_protocol_del);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_START, 1, dtn_ion_bpadmin_ctrl_protocol_start);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_STOP, 1, dtn_ion_bpadmin_ctrl_protocol_stop);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_ADD, 3, dtn_ion_bpadmin_ctrl_scheme_add);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_CHANGE, 3, dtn_ion_bpadmin_ctrl_scheme_change);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_DEL, 1, dtn_ion_bpadmin_ctrl_scheme_del);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_START, 1, dtn_ion_bpadmin_ctrl_scheme_start);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_STOP, 1, dtn_ion_bpadmin_ctrl_scheme_stop);
-	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_WATCH, 2, dtn_ion_bpadmin_ctrl_watch);
-}
-
-void dtn_ion_bpadmin_init_mac()
-{
-
-}
-
-void dtn_ion_bpadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_bpadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* ENDPOINTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_ENDPOINTS), dtn_ion_bpadmin_tblt_endpoints);
-	tblt_add_col(def, AMP_TYPE_STR, "scheme_name");
-	tblt_add_col(def, AMP_TYPE_STR, "endpoint_nss");
-	tblt_add_col(def, AMP_TYPE_UINT, "app_pid");
-	tblt_add_col(def, AMP_TYPE_STR, "recv_rule");
-	tblt_add_col(def, AMP_TYPE_STR, "rcv_script");
-	adm_add_tblt(def);
-
-	/* INDUCTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_INDUCTS), dtn_ion_bpadmin_tblt_inducts);
-	tblt_add_col(def, AMP_TYPE_STR, "protocol_name");
-	tblt_add_col(def, AMP_TYPE_STR, "duct_name");
-	tblt_add_col(def, AMP_TYPE_STR, "cli_control");
-	adm_add_tblt(def);
-
-	/* OUTDUCTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_OUTDUCTS), dtn_ion_bpadmin_tblt_outducts);
-	tblt_add_col(def, AMP_TYPE_STR, "protocol_name");
-	tblt_add_col(def, AMP_TYPE_STR, "duct_name");
-	tblt_add_col(def, AMP_TYPE_UINT, "clo_pid");
-	tblt_add_col(def, AMP_TYPE_STR, "clo_control");
-	tblt_add_col(def, AMP_TYPE_UINT, "max_payload_length");
-	adm_add_tblt(def);
-
-	/* PROTOCOLS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_PROTOCOLS), dtn_ion_bpadmin_tblt_protocols);
-	tblt_add_col(def, AMP_TYPE_STR, "name");
-	tblt_add_col(def, AMP_TYPE_UINT, "payload_bpf");
-	tblt_add_col(def, AMP_TYPE_UINT, "overhead_bpf");
-	tblt_add_col(def, AMP_TYPE_UINT, "protocol class");
-	adm_add_tblt(def);
-
-	/* SCHEMES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_SCHEMES), dtn_ion_bpadmin_tblt_schemes);
-	tblt_add_col(def, AMP_TYPE_STR, "scheme_name");
-	tblt_add_col(def, AMP_TYPE_UINT, "fwd_pid");
-	tblt_add_col(def, AMP_TYPE_STR, "fwd_cmd");
-	tblt_add_col(def, AMP_TYPE_UINT, "admin_app_pid");
-	tblt_add_col(def, AMP_TYPE_STR, "admin_app_cmd");
-	adm_add_tblt(def);
-
-	/* EGRESS_PLANS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_EGRESS_PLANS), dtn_ion_bpadmin_tblt_egress_plans);
-	tblt_add_col(def, AMP_TYPE_STR, "neighbor_eid");
-	tblt_add_col(def, AMP_TYPE_UINT, "clm_pid");
-	tblt_add_col(def, AMP_TYPE_UINT, "nominal_rate");
-	adm_add_tblt(def);
-}
-
-#endif // _HAVE_DTN_ION_BPADMIN_ADM_
diff -ru --new-file ion-sf/bpv7/adm/adm_ion_bp_admin.h ion-anms/bpv7/adm/adm_ion_bp_admin.h
--- ion-sf/bpv7/adm/adm_ion_bp_admin.h	2023-05-30 10:55:36.733112555 -0400
+++ ion-anms/bpv7/adm/adm_ion_bp_admin.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,401 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_bp_admin.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-
-#ifndef ADM_ION_BP_ADMIN_H_
-#define ADM_ION_BP_ADMIN_H_
-#define _HAVE_DTN_ION_BPADMIN_ADM_
-#ifdef _HAVE_DTN_ION_BPADMIN_ADM_
-
-#include "shared/utils/nm_types.h"
-#include "shared/adm/adm.h"
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 ADM TEMPLATE DOCUMENTATION                                  +
- * +---------------------------------------------------------------------------------------------+
- *
- * ADM ROOT STRING:DTN/ION/bpadmin
- */
-#define ADM_ENUM_DTN_ION_BPADMIN 5
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AGENT NICKNAME DEFINITIONS                                  +
- * +---------------------------------------------------------------------------------------------+
- */
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_BPADMIN META-DATA DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |name                 |The human-readable name of the ADM.   |STR    |ion_bp_admin            |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |namespace            |The namespace of the ADM              |STR    |DTN/ION/bpadmin         |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |version              |The version of the ADM                |STR    |v0.0                    |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |organization         |The name of the issuing organization o|       |                        |
- * |                     |f the ADM                             |STR    |JHUAPL                  |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-// "name"
-#define DTN_ION_BPADMIN_META_NAME 0x00
-// "namespace"
-#define DTN_ION_BPADMIN_META_NAMESPACE 0x01
-// "version"
-#define DTN_ION_BPADMIN_META_VERSION 0x02
-// "organization"
-#define DTN_ION_BPADMIN_META_ORGANIZATION 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                     DTN_ION_BPADMIN EXTERNALLY DEFINED DATA DEFINITIONS                     +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |bp_version           |Version of installed ION BP Admin util|       |
- * |                     |ity.                                  |STR    |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_BPADMIN_EDD_BP_VERSION 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_BPADMIN VARIABLE DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_BPADMIN REPORT DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                              DTN_ION_BPADMIN TABLE DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |endpoints            |Local endpoints, regardless of scheme |       |
- * |                     |name.                                 |       |
- * +---------------------+--------------------------------------+-------+
- * |inducts              |Inducts established locally for the in|       |
- * |                     |dicated CL protocol.                  |       |
- * +---------------------+--------------------------------------+-------+
- * |outducts             |If protocolName is specified, this tab|       |
- * |                     |le lists all outducts established loca|       |
- * |                     |lly for the indicated CL protocol. Oth|       |
- * |                     |erwise, it lists all locally establish|       |
- * |                     |ed outducts, regardless of their proto|       |
- * |                     |col.                                  |       |
- * +---------------------+--------------------------------------+-------+
- * |protocols            |Convergence layer protocols that can c|       |
- * |                     |urrently be utilized at the local node|       |
- * |                     |.                                     |       |
- * +---------------------+--------------------------------------+-------+
- * |schemes              |Declared endpoint naming schemes.     |       |
- * +---------------------+--------------------------------------+-------+
- * |egress_plans         |Egress plans.                         |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_BPADMIN_TBLT_ENDPOINTS 0x00
-#define DTN_ION_BPADMIN_TBLT_INDUCTS 0x01
-#define DTN_ION_BPADMIN_TBLT_OUTDUCTS 0x02
-#define DTN_ION_BPADMIN_TBLT_PROTOCOLS 0x03
-#define DTN_ION_BPADMIN_TBLT_SCHEMES 0x04
-#define DTN_ION_BPADMIN_TBLT_EGRESS_PLANS 0x05
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_BPADMIN CONTROL DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |endpoint_add         |Establish DTN endpoint named endpointI|       |
- * |                     |d on the local node. The remaining par|       |
- * |                     |ameters indicate what is to be done wh|       |
- * |                     |en bundles destined for this endpoint |       |
- * |                     |arrive at a time when no application h|       |
- * |                     |as the endpoint open for bundle recept|       |
- * |                     |ion. If type is 'x', then such bundles|       |
- * |                     | are to be discarded silently and imme|       |
- * |                     |diately. If type is 'q', then such bun|       |
- * |                     |dles are to be enqueued for later deli|       |
- * |                     |very and, if recvScript is provided, r|       |
- * |                     |ecvScript is to be executed.          |       |
- * +---------------------+--------------------------------------+-------+
- * |endpoint_change      |Change the action taken when bundles d|       |
- * |                     |estined for this endpoint arrive at a |       |
- * |                     |time when no application has the endpo|       |
- * |                     |int open for bundle reception.        |       |
- * +---------------------+--------------------------------------+-------+
- * |endpoint_del         |Delete the endpoint identified by endp|       |
- * |                     |ointId. The control will fail if any b|       |
- * |                     |undles are currently pending delivery |       |
- * |                     |to this endpoint.                     |       |
- * +---------------------+--------------------------------------+-------+
- * |induct_add           |Establish a duct for reception of bund|       |
- * |                     |les via the indicated CL protocol. The|       |
- * |                     | duct's data acquisition structure is |       |
- * |                     |used and populated by the induct task |       |
- * |                     |whose operation is initiated by cliCon|       |
- * |                     |trol at the time the duct is started. |       |
- * +---------------------+--------------------------------------+-------+
- * |induct_change        |Change the control used to initiate op|       |
- * |                     |eration of the induct task for the ind|       |
- * |                     |icated duct.                          |       |
- * +---------------------+--------------------------------------+-------+
- * |induct_del           |Delete the induct identified by protoc|       |
- * |                     |olName and ductName. The control will |       |
- * |                     |fail if any bundles are currently pend|       |
- * |                     |ing acquisition via this induct.      |       |
- * +---------------------+--------------------------------------+-------+
- * |induct_start         |Start the indicated induct task as def|       |
- * |                     |ined for the indicated CL protocol on |       |
- * |                     |the local node.                       |       |
- * +---------------------+--------------------------------------+-------+
- * |induct_stop          |Stop the indicated induct task as defi|       |
- * |                     |ned for the indicated CL protocol on t|       |
- * |                     |he local node.                        |       |
- * +---------------------+--------------------------------------+-------+
- * |manage_heap_max      |Declare the maximum number of bytes of|       |
- * |                     | SDR heap space that will be occupied |       |
- * |                     |by any single bundle acquisition activ|       |
- * |                     |ity (nominally the acquisition of a si|       |
- * |                     |ngle bundle, but this is at the discre|       |
- * |                     |tion of the convergence-layer input ta|       |
- * |                     |sk). All data acquired in excess of th|       |
- * |                     |is limit will be written to a temporar|       |
- * |                     |y file pending extraction and dispatch|       |
- * |                     |ing of the acquired bundle or bundles.|       |
- * |                     | The default is the minimum allowed va|       |
- * |                     |lue (560 bytes), which is the approxim|       |
- * |                     |ate size of a ZCO file reference objec|       |
- * |                     |t; this is the minimum SDR heap space |       |
- * |                     |occupancy in the event that all acquis|       |
- * |                     |ition is into a file.                 |       |
- * +---------------------+--------------------------------------+-------+
- * |outduct_add          |Establish a duct for transmission of b|       |
- * |                     |undles via the indicated CL protocol. |       |
- * |                     |the duct's data transmission structure|       |
- * |                     | is serviced by the outduct task whose|       |
- * |                     | operation is initiated by CLOcommand |       |
- * |                     |at the time the duct is started. A val|       |
- * |                     |ue of zero for maxPayloadLength indica|       |
- * |                     |tes that bundles of any size can be ac|       |
- * |                     |comodated; this is the default.       |       |
- * +---------------------+--------------------------------------+-------+
- * |outduct_change       |Set new values for the indicated duct'|       |
- * |                     |s payload size limit and the control t|       |
- * |                     |hat is used to initiate operation of t|       |
- * |                     |he outduct task for this duct.        |       |
- * +---------------------+--------------------------------------+-------+
- * |outduct_del          |Delete the outduct identified by proto|       |
- * |                     |colName and ductName. The control will|       |
- * |                     | fail if any bundles are currently pen|       |
- * |                     |ding transmission via this outduct.   |       |
- * +---------------------+--------------------------------------+-------+
- * |outduct_start        |Start the indicated outduct task as de|       |
- * |                     |fined for the indicated CL protocol on|       |
- * |                     | the local node.                      |       |
- * +---------------------+--------------------------------------+-------+
- * |egress_plan_block    |Disable transmission of bundles queued|       |
- * |                     | for transmission to the indicated nod|       |
- * |                     |e and reforwards all non-critical bund|       |
- * |                     |les currently queued for transmission |       |
- * |                     |to this node. This may result in some |       |
- * |                     |or all of these bundles being enqueued|       |
- * |                     | for transmission to the psuedo-node l|       |
- * |                     |imbo.                                 |       |
- * +---------------------+--------------------------------------+-------+
- * |egress_plan_unblock  |Re-enable transmission of bundles to t|       |
- * |                     |he indicated node and reforwards all b|       |
- * |                     |undles in limbo in the hope that the u|       |
- * |                     |nblocking of this egress plan will ena|       |
- * |                     |ble some of them to be transmitted.   |       |
- * +---------------------+--------------------------------------+-------+
- * |outduct_stop         |Stop the indicated outduct task as def|       |
- * |                     |ined for the indicated CL protocol on |       |
- * |                     |the local node.                       |       |
- * +---------------------+--------------------------------------+-------+
- * |protocol_add         |Establish access to the named converge|       |
- * |                     |nce layer protocol at the local node. |       |
- * |                     |The optional protocolClass argument in|       |
- * |                     |dicates the protocol's reliability.   |       |
- * +---------------------+--------------------------------------+-------+
- * |protocol_del         |Delete the convergence layer protocol |       |
- * |                     |identified by protocolName. The contro|       |
- * |                     |l will fail if any ducts are still loc|       |
- * |                     |ally declared for this protocol.      |       |
- * +---------------------+--------------------------------------+-------+
- * |protocol_start       |Start all induct and outduct tasks for|       |
- * |                     | inducts and outducts that have been d|       |
- * |                     |efined for the indicated CL protocol o|       |
- * |                     |n the local node.                     |       |
- * +---------------------+--------------------------------------+-------+
- * |protocol_stop        |Stop all induct and outduct tasks for |       |
- * |                     |inducts and outducts that have been de|       |
- * |                     |fined for the indicated CL protocol on|       |
- * |                     | the local node.                      |       |
- * +---------------------+--------------------------------------+-------+
- * |scheme_add           |Declares an endpoint naming scheme for|       |
- * |                     | use in endpoint IDs, which are struct|       |
- * |                     |ured as URIs: schemeName:schemeSpecifi|       |
- * |                     |cPart. forwarderControl will be execut|       |
- * |                     |ed when the scheme is started on this |       |
- * |                     |node, to initiate operation of a forwa|       |
- * |                     |rding daemon for this scheme. adminApp|       |
- * |                     |Control will also be executed when the|       |
- * |                     | scheme is started on this node, to in|       |
- * |                     |itiate operation of a daemon that open|       |
- * |                     |s a custodian endpoint identified with|       |
- * |                     |in this scheme so that it can recieve |       |
- * |                     |and process custody signals and bundle|       |
- * |                     | status reports.                      |       |
- * +---------------------+--------------------------------------+-------+
- * |scheme_change        |Set the indicated scheme's forwarderCo|       |
- * |                     |ntrol and adminAppControl to the strin|       |
- * |                     |gs provided as arguments.             |       |
- * +---------------------+--------------------------------------+-------+
- * |scheme_del           |Delete the scheme identified by scheme|       |
- * |                     |Name. The control will fail if any bun|       |
- * |                     |dles identified in this scheme are pen|       |
- * |                     |ding forwarding, transmission, or deli|       |
- * |                     |very.                                 |       |
- * +---------------------+--------------------------------------+-------+
- * |scheme_start         |Start the forwarder and administrative|       |
- * |                     | endpoint tasks for the indicated sche|       |
- * |                     |me task on the local node.            |       |
- * +---------------------+--------------------------------------+-------+
- * |scheme_stop          |Stop the forwarder and administrative |       |
- * |                     |endpoint tasks for the indicated schem|       |
- * |                     |e task on the local node.             |       |
- * +---------------------+--------------------------------------+-------+
- * |watch                |Enable/Disable production of a continu|       |
- * |                     |ous stream of user selected Bundle Pro|       |
- * |                     |tocol activity indication characters. |       |
- * |                     |A watch parameter of 1 selects all BP |       |
- * |                     |activity indication characters, 0 dese|       |
- * |                     |lects allBP activity indication charac|       |
- * |                     |ters; any other activitySpec such as a|       |
- * |                     |cz~ selects all activity indication ch|       |
- * |                     |aracters in the string, deselecting al|       |
- * |                     |l others. BP will print each selected |       |
- * |                     |activity indication character to stdou|       |
- * |                     |t every time a processing event of the|       |
- * |                     | associated type occurs: a new bundle |       |
- * |                     |is queued for forwarding, b bundle is |       |
- * |                     |queued for transmission, c bundle is p|       |
- * |                     |opped from its transmission queue, m c|       |
- * |                     |ustody acceptance signal is recieved, |       |
- * |                     |w custody of bundle is accepted, x cus|       |
- * |                     |tody of bundle is refused, y bundle is|       |
- * |                     | accepted upon arrival, z bundle is qu|       |
- * |                     |eued for delivery to an application, ~|       |
- * |                     | bundle is abandoned (discarded) on at|       |
- * |                     |tempt to forward it, ! bundle is destr|       |
- * |                     |oyed due to TTL expiration, &amp; cust|       |
- * |                     |ody refusal signal is recieved, # bund|       |
- * |                     |le is queued for re-forwarding due to |       |
- * |                     |CL protocol failures, j bundle is plac|       |
- * |                     |ed in 'limbo' for possible future refo|       |
- * |                     |rwarding, k bundle is removed from 'li|       |
- * |                     |mbo' and queued for reforwarding, $ bu|       |
- * |                     |ndle's custodial retransmission timeou|       |
- * |                     |t interval expired.                   |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_BPADMIN_CTRL_ENDPOINT_ADD 0x00
-#define DTN_ION_BPADMIN_CTRL_ENDPOINT_CHANGE 0x01
-#define DTN_ION_BPADMIN_CTRL_ENDPOINT_DEL 0x02
-#define DTN_ION_BPADMIN_CTRL_INDUCT_ADD 0x03
-#define DTN_ION_BPADMIN_CTRL_INDUCT_CHANGE 0x04
-#define DTN_ION_BPADMIN_CTRL_INDUCT_DEL 0x05
-#define DTN_ION_BPADMIN_CTRL_INDUCT_START 0x06
-#define DTN_ION_BPADMIN_CTRL_INDUCT_STOP 0x07
-#define DTN_ION_BPADMIN_CTRL_MANAGE_HEAP_MAX 0x08
-#define DTN_ION_BPADMIN_CTRL_OUTDUCT_ADD 0x09
-#define DTN_ION_BPADMIN_CTRL_OUTDUCT_CHANGE 0x0a
-#define DTN_ION_BPADMIN_CTRL_OUTDUCT_DEL 0x0b
-#define DTN_ION_BPADMIN_CTRL_OUTDUCT_START 0x0c
-#define DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_BLOCK 0x0d
-#define DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_UNBLOCK 0x0e
-#define DTN_ION_BPADMIN_CTRL_OUTDUCT_STOP 0x0f
-#define DTN_ION_BPADMIN_CTRL_PROTOCOL_ADD 0x10
-#define DTN_ION_BPADMIN_CTRL_PROTOCOL_DEL 0x11
-#define DTN_ION_BPADMIN_CTRL_PROTOCOL_START 0x12
-#define DTN_ION_BPADMIN_CTRL_PROTOCOL_STOP 0x13
-#define DTN_ION_BPADMIN_CTRL_SCHEME_ADD 0x14
-#define DTN_ION_BPADMIN_CTRL_SCHEME_CHANGE 0x15
-#define DTN_ION_BPADMIN_CTRL_SCHEME_DEL 0x16
-#define DTN_ION_BPADMIN_CTRL_SCHEME_START 0x17
-#define DTN_ION_BPADMIN_CTRL_SCHEME_STOP 0x18
-#define DTN_ION_BPADMIN_CTRL_WATCH 0x19
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_BPADMIN CONSTANT DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                              DTN_ION_BPADMIN MACRO DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_BPADMIN OPERATOR DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-/* Initialization functions. */
-void dtn_ion_bpadmin_init();
-void dtn_ion_bpadmin_init_meta();
-void dtn_ion_bpadmin_init_cnst();
-void dtn_ion_bpadmin_init_edd();
-void dtn_ion_bpadmin_init_op();
-void dtn_ion_bpadmin_init_var();
-void dtn_ion_bpadmin_init_ctrl();
-void dtn_ion_bpadmin_init_mac();
-void dtn_ion_bpadmin_init_rpttpl();
-void dtn_ion_bpadmin_init_tblt();
-#endif /* _HAVE_DTN_ION_BPADMIN_ADM_ */
-#endif //ADM_ION_BP_ADMIN_H_
diff -ru --new-file ion-sf/bpv7/adm/adm_ion_bp_admin_impl.c ion-anms/bpv7/adm/adm_ion_bp_admin_impl.c
--- ion-sf/bpv7/adm/adm_ion_bp_admin_impl.c	2023-05-30 10:55:36.733112555 -0400
+++ ion-anms/bpv7/adm/adm_ion_bp_admin_impl.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,1472 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_bp_admin_impl.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "bpP.h"
-#include "csi.h"
-
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/adm/adm.h"
-#include "adm_ion_bp_admin_impl.h"
-
-/*   START CUSTOM FUNCTIONS HERE */
-/*             TODO              */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_bpadmin_setup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-void dtn_ion_bpadmin_cleanup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-
-/* Metadata Functions */
-
-
-tnv_t *dtn_ion_bpadmin_meta_name(tnvc_t *parms)
-{
-	return tnv_from_str("ion_bp_admin");
-}
-
-
-tnv_t *dtn_ion_bpadmin_meta_namespace(tnvc_t *parms)
-{
-	return tnv_from_str("DTN/ION/bpadmin");
-}
-
-
-tnv_t *dtn_ion_bpadmin_meta_version(tnvc_t *parms)
-{
-	return tnv_from_str("v0.0");
-}
-
-
-tnv_t *dtn_ion_bpadmin_meta_organization(tnvc_t *parms)
-{
-	return tnv_from_str("JHUAPL");
-}
-
-
-/* Constant Functions */
-/* Table Functions */
-
-
-/*
- * Local endpoints, regardless of scheme name.
- */
-tbl_t *dtn_ion_bpadmin_tblt_endpoints(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_endpoints BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr		sdr = getIonsdr();
-	PsmPartition	ionwm = getIonwm();
-	VScheme		*vscheme;
-	VEndpoint	*vpoint;
-	PsmAddress	scheme_elt;
-	PsmAddress  vpoint_elt;
-	char	recvRule;
-	char	recvScriptBuffer[SDRSTRING_BUFSZ];
-	char	*recvScript = recvScriptBuffer;
-	tnvc_t  *cur_row = NULL;
-
-	OBJ_POINTER(Endpoint, endpoint);
-	OBJ_POINTER(Scheme, scheme);
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (scheme_elt = sm_list_first(ionwm, (getBpVdb())->schemes); scheme_elt; scheme_elt = sm_list_next(ionwm, scheme_elt))
-	{
-		vscheme = (VScheme *) psp(ionwm, sm_list_data(ionwm, scheme_elt));
-
-		for (vpoint_elt = sm_list_first(ionwm, vscheme->endpoints); vpoint_elt; vpoint_elt = sm_list_next(ionwm, vpoint_elt))
-		{
-			vpoint = (VEndpoint *) psp(ionwm, sm_list_data(ionwm, vpoint_elt));
-
-			GET_OBJ_POINTER(sdr, Endpoint, endpoint, sdr_list_data(sdr, vpoint->endpointElt));
-			GET_OBJ_POINTER(sdr, Scheme, scheme, endpoint->scheme);
-
-			recvRule = (endpoint->recvRule == EnqueueBundle) ? 'q' : 'x';
-
-			if (endpoint->recvScript == 0)
-			{
-				recvScriptBuffer[0] = '\0';
-			}
-			else
-			{
-				if (sdr_string_read(sdr, recvScriptBuffer, endpoint->recvScript)
-					       	< 0)
-				{
-					recvScript = "?";
-				}
-			}
-
-			/* (STR) scheme_name, (STR) endpoint_nss, (UINT) app_pid, (STR) recv_rule, (STR) rcv_script */
-
-			if((cur_row = tnvc_create(5)) != NULL)
-			{
-				char tmp[2];
-				tmp[0] = recvRule;
-				tmp[1] = 0;
-				tnvc_insert(cur_row, tnv_from_str(scheme->name));
-				tnvc_insert(cur_row, tnv_from_str(endpoint->nss));
-				tnvc_insert(cur_row, tnv_from_uint(vpoint->appPid));
-				tnvc_insert(cur_row, tnv_from_str(tmp));
-				tnvc_insert(cur_row, tnv_from_str(recvScript));
-
-				tbl_add_row(table, cur_row);
-			}
-			else
-			{
-				AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_endpoints", "Can't allocate row. Skipping.", NULL);
-			}
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_endpoints BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * Inducts established locally for the indicated CL protocol.
- */
-tbl_t *dtn_ion_bpadmin_tblt_inducts(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_inducts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr		sdr = getIonsdr();
-	PsmPartition	ionwm = getIonwm();
-	ClProtocol	clpbuf;
-	Object		clp_elt;
-	VInduct		*vduct;
-	PsmAddress	vduct_elt;
-	OBJ_POINTER(Induct, duct);
-	OBJ_POINTER(ClProtocol, clp);
-	char	cliCmdBuffer[SDRSTRING_BUFSZ];
-	char	*cliCmd;
-	tnvc_t  *cur_row = NULL;
-
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (clp_elt = sdr_list_first(sdr, (getBpConstants())->protocols);
-			clp_elt; clp_elt = sdr_list_next(sdr, clp_elt))
-	{
-		sdr_read(sdr, (char *) &clpbuf, sdr_list_data(sdr, clp_elt), sizeof(ClProtocol));
-
-		for (vduct_elt = sm_list_first(ionwm, (getBpVdb())->inducts); vduct_elt;
-				vduct_elt = sm_list_next(ionwm, vduct_elt))
-		{
-			vduct = (VInduct *) psp(ionwm, sm_list_data(ionwm, vduct_elt));
-
-			if (strcmp(vduct->protocolName, clpbuf.name) == 0)
-			{
-				GET_OBJ_POINTER(sdr, Induct, duct, sdr_list_data(sdr, vduct->inductElt));
-				GET_OBJ_POINTER(sdr, ClProtocol, clp, duct->protocol);
-				if (sdr_string_read(sdr, cliCmdBuffer, duct->cliCmd) < 0)
-				{
-					cliCmd = "?";
-				}
-				else
-				{
-					cliCmd = cliCmdBuffer;
-				}
-
-				/* (STR) protocol_name, (STR) duct_name, (STR) cli_control */
-				if((cur_row = tnvc_create(3)) != NULL)
-				{
-					tnvc_insert(cur_row, tnv_from_str(clp->name));
-					tnvc_insert(cur_row, tnv_from_str(duct->name));
-					tnvc_insert(cur_row, tnv_from_str(cliCmd));
-
-					tbl_add_row(table, cur_row);
-				}
-				else
-				{
-					AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_inducts", "Can't allocate row. Skipping.", NULL);
-				}
-
-			}
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_inducts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * If protocolName is specified, this table lists all outducts established locally for the indicated CL
- *  protocol. Otherwise, it lists all locally established outducts, regardless of their protocol.
- */
-tbl_t *dtn_ion_bpadmin_tblt_outducts(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_outducts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	Sdr		sdr = getIonsdr();
-	PsmPartition	ionwm = getIonwm();
-	ClProtocol	clpbuf;
-	Object		clp_elt;
-	VOutduct	*vduct;
-	PsmAddress	vduct_elt;
-	OBJ_POINTER(Outduct, duct);
-	OBJ_POINTER(ClProtocol, clp);
-	char	cloCmdBuffer[SDRSTRING_BUFSZ];
-	char	*cloCmd;
-	tnvc_t  *cur_row = NULL;
-
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (clp_elt = sdr_list_first(sdr, (getBpConstants())->protocols);
-			clp_elt; clp_elt = sdr_list_next(sdr, clp_elt))
-	{
-		sdr_read(sdr, (char *) &clpbuf, sdr_list_data(sdr, clp_elt), sizeof(ClProtocol));
-
-		for (vduct_elt = sm_list_first(ionwm, (getBpVdb())->outducts); vduct_elt;
-				vduct_elt = sm_list_next(ionwm, vduct_elt))
-		{
-			vduct = (VOutduct *) psp(ionwm, sm_list_data(ionwm, vduct_elt));
-
-			if (strcmp(vduct->protocolName, clpbuf.name) == 0)
-			{
-				GET_OBJ_POINTER(sdr, Outduct, duct, sdr_list_data(sdr, vduct->outductElt));
-				GET_OBJ_POINTER(sdr, ClProtocol, clp, duct->protocol);
-
-				if (duct->cloCmd == 0)
-				{
-					cloCmd = "?";
-				}
-				else if (sdr_string_read(sdr, cloCmdBuffer, duct->cloCmd) < 0)
-				{
-					cloCmd = "?";
-				}
-				else
-				{
-					cloCmd = cloCmdBuffer;
-				}
-
-				/* (STR) protocol_name, (STR) duct_name, (UINT) clo_pid, (STR) clo_control, (STR) max_ayload_len */
-				if((cur_row = tnvc_create(5)) != NULL)
-				{
-					tnvc_insert(cur_row, tnv_from_str(clp->name));
-					tnvc_insert(cur_row, tnv_from_str(duct->name));
-					tnvc_insert(cur_row, tnv_from_uint(vduct->cloPid));
-					tnvc_insert(cur_row, tnv_from_str(cloCmd));
-					tnvc_insert(cur_row, tnv_from_uint(duct->maxPayloadLen));
-
-					tbl_add_row(table, cur_row);
-				}
-				else
-				{
-					AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_outducts", "Can't allocate row. Skipping.", NULL);
-				}
-
-			}
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_outducts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * Convergence layer protocols that can currently be utilized at the local node.
- */
-tbl_t *dtn_ion_bpadmin_tblt_protocols(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_protocols BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr	sdr = getIonsdr();
-	Object	elt;
-	OBJ_POINTER(ClProtocol, clp);
-	tnvc_t  *cur_row = NULL;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (elt = sdr_list_first(sdr, (getBpConstants())->protocols); elt;
-			elt = sdr_list_next(sdr, elt))
-	{
-		GET_OBJ_POINTER(sdr, ClProtocol, clp, sdr_list_data(sdr, elt));
-
-		/* (STR) name, (UINT) protocol_class */
-		if((cur_row = tnvc_create(2)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_str(clp->name));
-			tnvc_insert(cur_row, tnv_from_uint(clp->protocolClass));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_protocols", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_protocols BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * Declared endpoint naming schemes.
- */
-tbl_t *dtn_ion_bpadmin_tblt_schemes(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_schemes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr		sdr = getIonsdr();
-	PsmPartition	ionwm = getIonwm();
-	PsmAddress	elt;
-	VScheme		*vscheme;
-	OBJ_POINTER(Scheme, scheme);
-	char	fwdCmdBuffer[SDRSTRING_BUFSZ];
-	char	*fwdCmd;
-	char	admAppCmdBuffer[SDRSTRING_BUFSZ];
-	char	*admAppCmd;
-	tnvc_t  *cur_row = NULL;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (elt = sm_list_first(ionwm, (getBpVdb())->schemes); elt;
-			elt = sm_list_next(ionwm, elt))
-	{
-		vscheme = (VScheme *) psp(ionwm, sm_list_data(ionwm, elt));
-
-		GET_OBJ_POINTER(sdr, Scheme, scheme, sdr_list_data(sdr, vscheme->schemeElt));
-		if (sdr_string_read(sdr, fwdCmdBuffer, scheme->fwdCmd) < 0)
-		{
-			fwdCmd = "?";
-		}
-		else
-		{
-			fwdCmd = fwdCmdBuffer;
-		}
-
-		if (sdr_string_read(sdr, admAppCmdBuffer, scheme->admAppCmd) < 0)
-		{
-			admAppCmd = "?";
-		}
-		else
-		{
-			admAppCmd = admAppCmdBuffer;
-		}
-
-		/* (STR) name, (UINT) fwd_pid, (STR) fwd_cmd, (UINT) admin_app_pid (STR) admin_app_cmd */
-		if((cur_row = tnvc_create(5)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_str(scheme->name));
-			tnvc_insert(cur_row, tnv_from_uint(vscheme->fwdPid));
-			tnvc_insert(cur_row, tnv_from_str(fwdCmd));
-			tnvc_insert(cur_row, tnv_from_uint(vscheme->admAppPid));
-			tnvc_insert(cur_row, tnv_from_str(admAppCmd));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_schemess", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_schemes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * Egress plans.
- */
-tbl_t *dtn_ion_bpadmin_tblt_egress_plans(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_egress_plans BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr		sdr = getIonsdr();
-	PsmPartition	ionwm = getIonwm();
-	PsmAddress	elt;
-	VPlan		*vplan;
-	OBJ_POINTER(BpPlan, plan);
-	tnvc_t  *cur_row = NULL;
-
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (elt = sm_list_first(ionwm, (getBpVdb())->plans); elt;
-			elt = sm_list_next(ionwm, elt))
-	{
-		vplan = (VPlan *) psp(ionwm, sm_list_data(ionwm, elt));
-		GET_OBJ_POINTER(sdr, BpPlan, plan, sdr_list_data(sdr, vplan->planElt));
-
-		/* (STR) neighbor EID, (UINT) clm_pid, (UINT) nominal rate*/
-		if((cur_row = tnvc_create(3)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_str(plan->neighborEid));
-			tnvc_insert(cur_row, tnv_from_uint(vplan->clmPid));
-			tnvc_insert(cur_row, tnv_from_uint(plan->nominalRate));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_egress_plans", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_egress_plans BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/* Collect Functions */
-/*
- * Version of installed ION BP Admin utility.
- */
-tnv_t *dtn_ion_bpadmin_get_bp_version(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_bp_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char buffer[80];
-	isprintf(buffer, sizeof buffer,
-			"%s compiled with crypto suite: %s",
-			IONVERSIONNUMBER, CSI_SUITE_NAME);
-	result = tnv_from_str(buffer);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_bp_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* Control Functions */
-
-/*
- * Establish DTN endpoint named endpointId on the local node. The remaining parameters indicate what is
- *  to be done when bundles destined for this endpoint arrive at a time when no application has the end
- * point open for bundle reception. If type is 'x', then such bundles are to be discarded silently and 
- * immediately. If type is 'q', then such bundles are to be enqueued for later delivery and, if recvScr
- * ipt is provided, recvScript is to be executed.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_endpoint_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_endpoint_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	int success;
-	BpRecvRule	rule;
-
-	char *id = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-    uint32_t type = adm_get_parm_uint(parms, 1, &success);
-    char *rcv = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-
-    rule = (type == 'q') ? EnqueueBundle : DiscardBundle;
-
-	if(addEndpoint(id, rule, rcv) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_endpoint_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Change the action taken when bundles destined for this endpoint arrive at a time when no application
- *  has the endpoint open for bundle reception.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_endpoint_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_endpoint_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	BpRecvRule	rule;
-
-	char *id = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-    uint32_t type = adm_get_parm_uint(parms, 1, &success);
-    char *rcv = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-
-    rule = (type == 'q') ? EnqueueBundle : DiscardBundle;
-
-	if(updateEndpoint(id, rule, rcv) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_endpoint_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Delete the endpoint identified by endpointId. The control will fail if any bundles are currently pen
- * ding delivery to this endpoint.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_endpoint_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_endpoint_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *id = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	if(removeEndpoint(id) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_endpoint_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Establish a duct for reception of bundles via the indicated CL protocol. The duct's data acquisition
- *  structure is used and populated by the induct task whose operation is initiated by cliControl at th
- * e time the duct is started.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_induct_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_induct_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	char *cli_ctrl = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-
-	if(addInduct(p_name, d_name, cli_ctrl) > 1)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_induct_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Change the control used to initiate operation of the induct task for the indicated duct.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_induct_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_induct_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	char *cli_ctrl = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-
-	if(updateInduct(p_name, d_name, cli_ctrl) > 1)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_induct_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Delete the induct identified by protocolName and ductName. The control will fail if any bundles are 
- * currently pending acquisition via this induct.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_induct_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_induct_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-
-	if(removeInduct(p_name, d_name) > 1)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_induct_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Start the indicated induct task as defined for the indicated CL protocol on the local node.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_induct_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_induct_start BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-
-	if(bpStartInduct(p_name, d_name) > 1)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_induct_start BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Stop the indicated induct task as defined for the indicated CL protocol on the local node.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_induct_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_induct_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-
-	bpStopInduct(p_name, d_name);
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_induct_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Declare the maximum number of bytes of SDR heap space that will be occupied by any single bundle acq
- * uisition activity (nominally the acquisition of a single bundle, but this is at the discretion of th
- * e convergence-layer input task). All data acquired in excess of this limit will be written to a temp
- * orary file pending extraction and dispatching of the acquired bundle or bundles. The default is the 
- * minimum allowed value (560 bytes), which is the approximate size of a ZCO file reference object; thi
- * s is the minimum SDR heap space occupancy in the event that all acquisition is into a file.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_manage_heap_max(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_manage_heap_max BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	Sdr		sdr = getIonsdr();
-	Object		bpdbObj = getBpDbObject();
-	BpDB		bpdb;
-	int success;
-	unsigned int heapmax = adm_get_parm_uint(parms, 0, &success);
-
-	if (heapmax < 560)
-	{
-		AMP_DEBUG_WARN("dtn_ion_bpadmin_ctrl_manage_heap_max", "heapmax (%lu) must be at least 560.", heapmax);
-		return NULL;
-	}
-
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &bpdb, bpdbObj, sizeof(BpDB));
-	bpdb.maxAcqInHeap = heapmax;
-	sdr_write(sdr, bpdbObj, (char *) &bpdb, sizeof(BpDB));
-	if (sdr_end_xn(sdr) < 0)
-	{
-		AMP_DEBUG_ERR("dtn_ion_bpadmin_ctrl_manage_heap_max", "Can't change maxAcqInHeap.", NULL);
-	}
-	else
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_manage_heap_max BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Establish a duct for transmission of bundles via the indicated CL protocol. the duct's data transmis
- * sion structure is serviced by the outduct task whose operation is initiated by CLOcommand at the tim
- * e the duct is started. A value of zero for maxPayloadLength indicates that bundles of any size can b
- * e accomodated; this is the default.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_outduct_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	int success;
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	char *clo_cmd = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-	unsigned int max_len = adm_get_parm_uint(parms, 3, &success);
-
-	if(addOutduct(p_name, d_name, clo_cmd, max_len) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_outduct_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Set new values for the indicated duct's payload size limit and the control that is used to initiate 
- * operation of the outduct task for this duct.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_outduct_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	char *clo_cmd = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-	unsigned int max_len = adm_get_parm_uint(parms, 3, &success);
-
-	if(updateOutduct(p_name, d_name, clo_cmd, max_len) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_outduct_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Delete the outduct identified by protocolName and ductName. The control will fail if any bundles are
- *  currently pending transmission via this outduct.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_outduct_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-
-	if(removeOutduct(p_name, d_name) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_outduct_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Start the indicated outduct task as defined for the indicated CL protocol on the local node.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_outduct_start BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-
-	if(bpStartOutduct(p_name, d_name) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_outduct_start BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Disable transmission of bundles queued for transmission to the indicated node and reforwards all non
- * -critical bundles currently queued for transmission to this node. This may result in some or all of 
- * these bundles being enqueued for transmission to the psuedo-node limbo.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_block(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_egress_plan_block BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	if(bpBlockPlan(name) >= 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_egress_plan_block BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Re-enable transmission of bundles to the indicated node and reforwards all bundles in limbo in the h
- * ope that the unblocking of this egress plan will enable some of them to be transmitted.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_unblock(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_egress_plan_unblock BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	if(bpUnblockPlan(name) >= 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_egress_plan_unblock BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Stop the indicated outduct task as defined for the indicated CL protocol on the local node.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_outduct_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-
-	bpStopOutduct(p_name, d_name);
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_outduct_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Establish access to the named convergence layer protocol at the local node.
- * The optional protocolCLass indicates the reliability of the protocol.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_protocol_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_protocol_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	int protocolClass = adm_get_parm_uint(parms, 1, &success);
-
-	if(addProtocol(name, protocolClass) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_protocol_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Delete the convergence layer protocol identified by protocolName. The control will fail if any ducts
- *  are still locally declared for this protocol.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_protocol_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_protocol_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	if(removeProtocol(name) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_protocol_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Start all induct and outduct tasks for inducts and outducts that have been defined for the indicated
- *  CL protocol on the local node.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_protocol_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_protocol_start BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	if(bpStartProtocol(name) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_protocol_start BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Stop all induct and outduct tasks for inducts and outducts that have been defined for the indicated 
- * CL protocol on the local node.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_protocol_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_protocol_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	bpStopProtocol(name);
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_protocol_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Declares an endpoint naming scheme for use in endpoint IDs, which are structured as URIs: schemeName
- * :schemeSpecificPart. forwarderControl will be executed when the scheme is started on this node, to i
- * nitiate operation of a forwarding daemon for this scheme. adminAppControl will also be executed when
- *  the scheme is started on this node, to initiate operation of a daemon that opens a custodian endpoi
- * nt identified within this scheme so that it can recieve and process custody signals and bundle statu
- * s reports.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_scheme_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *fwd_ctrl = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	char *adm_app_ctrl = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-
-	if(addScheme(name, fwd_ctrl, adm_app_ctrl) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_scheme_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Set the indicated scheme's forwarderControl and adminAppControl to the strings provided as arguments
- * .
- */
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_scheme_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *fwd_ctrl = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-	char *adm_app_ctrl = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-
-	if(updateScheme(name, fwd_ctrl, adm_app_ctrl) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_scheme_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Delete the scheme identified by schemeName. The control will fail if any bundles identified in this 
- * scheme are pending forwarding, transmission, or delivery.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_scheme_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	if(removeScheme(name) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_scheme_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Start the forwarder and administrative endpoint tasks for the indicated scheme task on the local nod
- * e.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_scheme_start BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	if(bpStartScheme(name) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_scheme_start BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Stop the forwarder and administrative endpoint tasks for the indicated scheme task on the local node
- * .
- */
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_scheme_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	bpStopScheme(name);
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_scheme_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Enable/Disable production of a continuous stream of user selected Bundle Protocol activity indicatio
- * n characters. A watch parameter of 1 selects all BP activity indication characters, 0 deselects allB
- * P activity indication characters; any other activitySpec such as acz~ selects all activity indicatio
- * n characters in the string, deselecting all others. BP will print each selected activity indication 
- * character to stdout every time a processing event of the associated type occurs: a new bundle is que
- * ued for forwarding, b bundle is queued for transmission, c bundle is popped from its transmission qu
- * eue, m custody acceptance signal is recieved, w custody of bundle is accepted, x custody of bundle i
- * s refused, y bundle is accepted upon arrival, z bundle is queued for delivery to an application, ~ b
- * undle is abandoned (discarded) on attempt to forward it, ! bundle is destroyed due to TTL expiration
- * , &amp; custody refusal signal is recieved, # bundle is queued for re-forwarding due to CL protocol 
- * failures, j bundle is placed in 'limbo' for possible future reforwarding, k bundle is removed from '
- * limbo' and queued for reforwarding, $ bundle's custodial retransmission timeout interval expired.
- */
-tnv_t *dtn_ion_bpadmin_ctrl_watch(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_watch BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	Sdr	sdr = getIonsdr();
-	Object	dbObj = getBpDbObject();
-	BpDB	db;
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	BpVdb	*vdb = getBpVdb();
-	int i;
-
-	CHKNULL(vdb);
-	*status = CTRL_SUCCESS;
-
-	if (strcmp(name, "1") == 0)
-	{
-		vdb->watching = -1;
-		return result;
-	}
-
-	vdb->watching = 0;
-	if (strcmp(name, "0") == 0)
-	{
-		return result;
-	}
-
-	for(i = 0; i < strlen(name); i++)
-	{
-		switch(name[i])
-		{
-			case 'a': vdb->watching |= WATCH_a; break;
-			case 'b': vdb->watching |= WATCH_b; break;
-			case 'c': vdb->watching |= WATCH_c; break;
-			case 'y': vdb->watching |= WATCH_y; break;
-			case 'z': vdb->watching |= WATCH_z; break;
-			case '~': vdb->watching |= WATCH_abandon; break;
-			case '!': vdb->watching |= WATCH_expire;  break;
-			case 'j': vdb->watching |= WATCH_limbo;   break;
-			case 'k': vdb->watching |= WATCH_delimbo; break;
-			default:
-				AMP_DEBUG_WARN("dtn_ion_bpadmin_ctrl_watch", "Invalid watch char %c.", name[i]);
-				break;
-		}
-	}
-
-
-	if (dbObj != 0)
-	{
-		CHKNULL(sdr_begin_xn(sdr));
-		sdr_stage(sdr, (char *) &db, dbObj, sizeof(BpDB));
-		db.watching = vdb->watching;
-		sdr_write(sdr, dbObj, (char *) &db, sizeof(BpDB));
-		oK(sdr_end_xn(sdr));
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_watch BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* OP Functions */
diff -ru --new-file ion-sf/bpv7/adm/adm_ion_bp_admin_impl.h ion-anms/bpv7/adm/adm_ion_bp_admin_impl.h
--- ion-sf/bpv7/adm/adm_ion_bp_admin_impl.h	2023-05-30 10:55:36.733112555 -0400
+++ ion-anms/bpv7/adm/adm_ion_bp_admin_impl.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,102 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_bp_admin_impl.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-#ifndef ADM_ION_BP_ADMIN_IMPL_H_
-#define ADM_ION_BP_ADMIN_IMPL_H_
-
-/*   START CUSTOM INCLUDES HERE  */
-/*             TODO              */
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/utils/utils.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-#include "shared/primitives/tnv.h"
-
-/*   START typeENUM */
-/*   STOP typeENUM  */
-
-void name_adm_init_agent();
-
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                     Retrieval Functions                                     +
- * +---------------------------------------------------------------------------------------------+
- */
-/*   START CUSTOM FUNCTIONS HERE */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_bpadmin_setup();
-void dtn_ion_bpadmin_cleanup();
-
-
-/* Metadata Functions */
-tnv_t *dtn_ion_bpadmin_meta_name(tnvc_t *parms);
-tnv_t *dtn_ion_bpadmin_meta_namespace(tnvc_t *parms);
-tnv_t *dtn_ion_bpadmin_meta_version(tnvc_t *parms);
-tnv_t *dtn_ion_bpadmin_meta_organization(tnvc_t *parms);
-
-/* Constant Functions */
-
-/* Collect Functions */
-tnv_t *dtn_ion_bpadmin_get_bp_version(tnvc_t *parms);
-
-
-/* Control Functions */
-tnv_t *dtn_ion_bpadmin_ctrl_endpoint_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_endpoint_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_endpoint_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_induct_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_induct_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_induct_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_induct_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_induct_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_manage_heap_max(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_block(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_unblock(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_outduct_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_protocol_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_protocol_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_protocol_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_protocol_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_scheme_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_bpadmin_ctrl_watch(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-
-
-/* OP Functions */
-
-
-/* Table Build Functions */
-tbl_t *dtn_ion_bpadmin_tblt_endpoints(ari_t *id);
-tbl_t *dtn_ion_bpadmin_tblt_inducts(ari_t *id);
-tbl_t *dtn_ion_bpadmin_tblt_outducts(ari_t *id);
-tbl_t *dtn_ion_bpadmin_tblt_protocols(ari_t *id);
-tbl_t *dtn_ion_bpadmin_tblt_schemes(ari_t *id);
-tbl_t *dtn_ion_bpadmin_tblt_egress_plans(ari_t *id);
-
-#endif //ADM_ION_BP_ADMIN_IMPL_H_
diff -ru --new-file ion-sf/bpv7/adm/adm_ion_bp_admin_mgr.c ion-anms/bpv7/adm/adm_ion_bp_admin_mgr.c
--- ion-sf/bpv7/adm/adm_ion_bp_admin_mgr.c	2023-05-30 10:55:36.733112555 -0400
+++ ion-anms/bpv7/adm/adm_ion_bp_admin_mgr.c	1969-12-31 19:00:00.000000000 -0500
@@ -1,424 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_bp_admin_mgr.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ion_bp_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "metadata.h"
-#include "nm_mgr_ui.h"
-
-
-
-
-#define _HAVE_DTN_ION_BPADMIN_ADM_
-#ifdef _HAVE_DTN_ION_BPADMIN_ADM_
-static vec_idx_t g_dtn_ion_bpadmin_idx[11];
-
-void dtn_ion_bpadmin_init()
-{
-	adm_add_adm_info("dtn_ion_bpadmin", ADM_ENUM_DTN_ION_BPADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_bpadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_bpadmin_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_bpadmin_init_meta();
-	dtn_ion_bpadmin_init_cnst();
-	dtn_ion_bpadmin_init_edd();
-	dtn_ion_bpadmin_init_op();
-	dtn_ion_bpadmin_init_var();
-	dtn_ion_bpadmin_init_ctrl();
-	dtn_ion_bpadmin_init_mac();
-	dtn_ion_bpadmin_init_rpttpl();
-	dtn_ion_bpadmin_init_tblt();
-}
-
-void dtn_ion_bpadmin_init_meta()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_NAME);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "name", "The human-readable name of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_NAMESPACE);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "namespace", "The namespace of the ADM");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_VERSION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "version", "The version of the ADM");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_ORGANIZATION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "organization", "The name of the issuing organization of the ADM");
-
-}
-
-void dtn_ion_bpadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_bpadmin_init_edd()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_bpadmin_idx[ADM_EDD_IDX], DTN_ION_BPADMIN_EDD_BP_VERSION);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "bp_version", "Version of installed ION BP Admin utility.");
-
-}
-
-void dtn_ion_bpadmin_init_op()
-{
-
-}
-
-void dtn_ion_bpadmin_init_var()
-{
-
-}
-
-void dtn_ion_bpadmin_init_ctrl()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-
-	/* ENDPOINT_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_ADD);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "endpoint_add", "Establish DTN endpoint named endpointId on the local node. The remaining parameters indicate what is to be done when bundles destined for this endpoint arrive at a time when no application has the endpoint open for bundle reception. If type is 'x', then such bundles are to be discarded silently and immediately. If type is 'q', then such bundles are to be enqueued for later delivery and, if recvScript is provided, recvScript is to be executed.");
-
-	meta_add_parm(meta, "endpoint_id", AMP_TYPE_STR);
-	meta_add_parm(meta, "type", AMP_TYPE_UINT);
-	meta_add_parm(meta, "rcv_script", AMP_TYPE_STR);
-
-	/* ENDPOINT_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_CHANGE);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "endpoint_change", "Change the action taken when bundles destined for this endpoint arrive at a time when no application has the endpoint open for bundle reception.");
-
-	meta_add_parm(meta, "endpoint_id", AMP_TYPE_STR);
-	meta_add_parm(meta, "type", AMP_TYPE_UINT);
-	meta_add_parm(meta, "rcv_script", AMP_TYPE_STR);
-
-	/* ENDPOINT_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_DEL);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "endpoint_del", "Delete the endpoint identified by endpointId. The control will fail if any bundles are currently pending delivery to this endpoint.");
-
-	meta_add_parm(meta, "endpoint_id", AMP_TYPE_STR);
-
-	/* INDUCT_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_ADD);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_add", "Establish a duct for reception of bundles via the indicated CL protocol. The duct's data acquisition structure is used and populated by the induct task whose operation is initiated by cliControl at the time the duct is started.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "cli_control", AMP_TYPE_STR);
-
-	/* INDUCT_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_CHANGE);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_change", "Change the control used to initiate operation of the induct task for the indicated duct.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "cli_control", AMP_TYPE_STR);
-
-	/* INDUCT_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_DEL);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_del", "Delete the induct identified by protocolName and ductName. The control will fail if any bundles are currently pending acquisition via this induct.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-
-	/* INDUCT_START */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_START);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_start", "Start the indicated induct task as defined for the indicated CL protocol on the local node.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-
-	/* INDUCT_STOP */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_STOP);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_stop", "Stop the indicated induct task as defined for the indicated CL protocol on the local node.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-
-	/* MANAGE_HEAP_MAX */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_MANAGE_HEAP_MAX);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "manage_heap_max", "Declare the maximum number of bytes of SDR heap space that will be occupied by any single bundle acquisition activity (nominally the acquisition of a single bundle, but this is at the discretion of the convergence-layer input task). All data acquired in excess of this limit will be written to a temporary file pending extraction and dispatching of the acquired bundle or bundles. The default is the minimum allowed value (560 bytes), which is the approximate size of a ZCO file reference object; this is the minimum SDR heap space occupancy in the event that all acquisition is into a file.");
-
-	meta_add_parm(meta, "max_database_heap_per_acquisition", AMP_TYPE_UINT);
-
-	/* OUTDUCT_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_ADD);
-	adm_add_ctrldef_ari(id, 4, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_add", "Establish a duct for transmission of bundles via the indicated CL protocol. the duct's data transmission structure is serviced by the outduct task whose operation is initiated by CLOcommand at the time the duct is started. A value of zero for maxPayloadLength indicates that bundles of any size can be accomodated; this is the default.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "clo_command", AMP_TYPE_STR);
-	meta_add_parm(meta, "max_payload_length", AMP_TYPE_UINT);
-
-	/* OUTDUCT_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_CHANGE);
-	adm_add_ctrldef_ari(id, 4, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_change", "Set new values for the indicated duct's payload size limit and the control that is used to initiate operation of the outduct task for this duct.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "clo_control", AMP_TYPE_STR);
-	meta_add_parm(meta, "max_payload_length", AMP_TYPE_UINT);
-
-	/* OUTDUCT_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_DEL);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_del", "Delete the outduct identified by protocolName and ductName. The control will fail if any bundles are currently pending transmission via this outduct.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-
-	/* OUTDUCT_START */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_START);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_start", "Start the indicated outduct task as defined for the indicated CL protocol on the local node.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-
-	/* EGRESS_PLAN_BLOCK */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_BLOCK);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plan_block", "Disable transmission of bundles queued for transmission to the indicated node and reforwards all non-critical bundles currently queued for transmission to this node. This may result in some or all of these bundles being enqueued for transmission to the psuedo-node limbo.");
-
-	meta_add_parm(meta, "plan_name", AMP_TYPE_STR);
-
-	/* EGRESS_PLAN_UNBLOCK */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_UNBLOCK);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plan_unblock", "Re-enable transmission of bundles to the indicated node and reforwards all bundles in limbo in the hope that the unblocking of this egress plan will enable some of them to be transmitted.");
-
-	meta_add_parm(meta, "plan_name", AMP_TYPE_STR);
-
-	/* OUTDUCT_STOP */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_STOP);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_stop", "Stop the indicated outduct task as defined for the indicated CL protocol on the local node.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
-
-	/* PROTOCOL_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_ADD);
-	adm_add_ctrldef_ari(id, 4, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "protocol_add", "Establish access to the named convergence layer protocol at the local node. The optional protocolClass argument indicates the reliability of the protocol, in the event that the protocol is not one for which protocol class is already hard-coded in ION.");
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "protocol_class", AMP_TYPE_UINT);
-
-	/* PROTOCOL_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_DEL);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "protocol_del", "Delete the convergence layer protocol identified by protocolName. The control will fail if any ducts are still locally declared for this protocol.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-
-	/* PROTOCOL_START */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_START);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "protocol_start", "Start all induct and outduct tasks for inducts and outducts that have been defined for the indicated CL protocol on the local node.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-
-	/* PROTOCOL_STOP */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_STOP);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "protocol_stop", "Stop all induct and outduct tasks for inducts and outducts that have been defined for the indicated CL protocol on the local node.");
-
-	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
-
-	/* SCHEME_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_ADD);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_add", "Declares an endpoint naming scheme for use in endpoint IDs, which are structured as URIs: schemeName:schemeSpecificPart. forwarderControl will be executed when the scheme is started on this node, to initiate operation of a forwarding daemon for this scheme. adminAppControl will also be executed when the scheme is started on this node, to initiate operation of a daemon that opens a custodian endpoint identified within this scheme so that it can recieve and process custody signals and bundle status reports.");
-
-	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "forwarder_control", AMP_TYPE_STR);
-	meta_add_parm(meta, "admin_app_control", AMP_TYPE_STR);
-
-	/* SCHEME_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_CHANGE);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_change", "Set the indicated scheme's forwarderControl and adminAppControl to the strings provided as arguments.");
-
-	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "forwarder_control", AMP_TYPE_STR);
-	meta_add_parm(meta, "admin_app_control", AMP_TYPE_STR);
-
-	/* SCHEME_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_DEL);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_del", "Delete the scheme identified by schemeName. The control will fail if any bundles identified in this scheme are pending forwarding, transmission, or delivery.");
-
-	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
-
-	/* SCHEME_START */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_START);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_start", "Start the forwarder and administrative endpoint tasks for the indicated scheme task on the local node.");
-
-	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
-
-	/* SCHEME_STOP */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_STOP);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_stop", "Stop the forwarder and administrative endpoint tasks for the indicated scheme task on the local node.");
-
-	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
-
-	/* WATCH */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_WATCH);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "watch", "Enable/Disable production of a continuous stream of user selected Bundle Protocol activity indication characters. A watch parameter of 1 selects all BP activity indication characters, 0 deselects allBP activity indication characters; any other activitySpec such as acz~ selects all activity indication characters in the string, deselecting all others. BP will print each selected activity indication character to stdout every time a processing event of the associated type occurs: a new bundle is queued for forwarding, b bundle is queued for transmission, c bundle is popped from its transmission queue, m custody acceptance signal is recieved, w custody of bundle is accepted, x custody of bundle is refused, y bundle is accepted upon arrival, z bundle is queued for delivery to an application, ~ bundle is abandoned (discarded) on attempt to forward it, ! bundle is destroyed due to TTL expiration, &amp; custody refusal signal is recieved, # bundle is queued for re-forwarding due to CL protocol failures, j bundle is placed in 'limbo' for possible future reforwarding, k bundle is removed from 'limbo' and queued for reforwarding, $ bundle's custodial retransmission timeout interval expired.");
-
-	meta_add_parm(meta, "status", AMP_TYPE_UINT);
-	meta_add_parm(meta, "activity_spec", AMP_TYPE_STR);
-}
-
-void dtn_ion_bpadmin_init_mac()
-{
-
-}
-
-void dtn_ion_bpadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_bpadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* ENDPOINTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_ENDPOINTS), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "scheme_name");
-	tblt_add_col(def, AMP_TYPE_STR, "endpoint_nss");
-	tblt_add_col(def, AMP_TYPE_UINT, "app_pid");
-	tblt_add_col(def, AMP_TYPE_STR, "recv_rule");
-	tblt_add_col(def, AMP_TYPE_STR, "rcv_script");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "endpoints", "Local endpoints, regardless of scheme name.");
-
-	/* INDUCTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_INDUCTS), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "protocol_name");
-	tblt_add_col(def, AMP_TYPE_STR, "duct_name");
-	tblt_add_col(def, AMP_TYPE_STR, "cli_control");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "inducts", "Inducts established locally for the indicated CL protocol.");
-
-	/* OUTDUCTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_OUTDUCTS), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "protocol_name");
-	tblt_add_col(def, AMP_TYPE_STR, "duct_name");
-	tblt_add_col(def, AMP_TYPE_UINT, "clo_pid");
-	tblt_add_col(def, AMP_TYPE_STR, "clo_control");
-	tblt_add_col(def, AMP_TYPE_UINT, "max_payload_length");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "outducts", "If protocolName is specified, this table lists all outducts established locally for the indicated CL protocol. Otherwise, it lists all locally established outducts, regardless of their protocol.");
-
-	/* PROTOCOLS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_PROTOCOLS), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "name");
-	tblt_add_col(def, AMP_TYPE_UINT, "payload_bpf");
-	tblt_add_col(def, AMP_TYPE_UINT, "overhead_bpf");
-	tblt_add_col(def, AMP_TYPE_UINT, "protocol class");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "protocols", "Convergence layer protocols that can currently be utilized at the local node.");
-
-	/* SCHEMES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_SCHEMES), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "scheme_name");
-	tblt_add_col(def, AMP_TYPE_UINT, "fwd_pid");
-	tblt_add_col(def, AMP_TYPE_STR, "fwd_cmd");
-	tblt_add_col(def, AMP_TYPE_UINT, "admin_app_pid");
-	tblt_add_col(def, AMP_TYPE_STR, "admin_app_cmd");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "schemes", "Declared endpoint naming schemes.");
-
-	/* EGRESS_PLANS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_EGRESS_PLANS), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "neighbor_eid");
-	tblt_add_col(def, AMP_TYPE_UINT, "clm_pid");
-	tblt_add_col(def, AMP_TYPE_UINT, "nominal_rate");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plans", "Egress plans.");
-}
-
-#endif // _HAVE_DTN_ION_BPADMIN_ADM_
diff -ru --new-file ion-sf/bpv7/nm/agent/adm_bp_agent_agent.c ion-anms/bpv7/nm/agent/adm_bp_agent_agent.c
--- ion-sf/bpv7/nm/agent/adm_bp_agent_agent.c	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/agent/adm_bp_agent_agent.c	2023-05-15 12:59:40.781869527 -0400
@@ -0,0 +1,190 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bp_agent_agent.c
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated c file 
+ **
+ ****************************************************************************/
+
+
+#include "ion.h"
+#include "platform.h"
+#include "adm_bp_agent.h"
+#include "shared/utils/utils.h"
+#include "shared/primitives/report.h"
+#include "shared/primitives/blob.h"
+#include "adm_bp_agent_impl.h"
+#include "agent/rda.h"
+
+
+
+#define _HAVE_DTN_BP_AGENT_ADM_
+#ifdef _HAVE_DTN_BP_AGENT_ADM_
+
+static vec_idx_t g_dtn_bp_agent_idx[11];
+
+void dtn_bp_agent_init()
+{
+	adm_add_adm_info("dtn_bp_agent", ADM_ENUM_DTN_BP_AGENT);
+
+	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_META_IDX), &(g_dtn_bp_agent_idx[ADM_META_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_RPTT_IDX), &(g_dtn_bp_agent_idx[ADM_RPTT_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_EDD_IDX), &(g_dtn_bp_agent_idx[ADM_EDD_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_CTRL_IDX), &(g_dtn_bp_agent_idx[ADM_CTRL_IDX]));
+
+
+	dtn_bp_agent_setup();
+	dtn_bp_agent_init_meta();
+	dtn_bp_agent_init_cnst();
+	dtn_bp_agent_init_edd();
+	dtn_bp_agent_init_op();
+	dtn_bp_agent_init_var();
+	dtn_bp_agent_init_ctrl();
+	dtn_bp_agent_init_mac();
+	dtn_bp_agent_init_rpttpl();
+	dtn_bp_agent_init_tblt();
+}
+
+void dtn_bp_agent_init_meta()
+{
+
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAME), dtn_bp_agent_meta_name);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAMESPACE), dtn_bp_agent_meta_namespace);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_VERSION), dtn_bp_agent_meta_version);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_ORGANIZATION), dtn_bp_agent_meta_organization);
+}
+
+void dtn_bp_agent_init_cnst()
+{
+
+}
+
+void dtn_bp_agent_init_edd()
+{
+
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_ID), dtn_bp_agent_get_bp_node_id);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_VERSION), dtn_bp_agent_get_bp_node_version);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_AVAILABLE_STORAGE), dtn_bp_agent_get_available_storage);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_LAST_RESET_TIME), dtn_bp_agent_get_last_reset_time);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_REGISTRATIONS), dtn_bp_agent_get_num_registrations);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_FWD), dtn_bp_agent_get_num_pend_fwd);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_DIS), dtn_bp_agent_get_num_pend_dis);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_IN_CUST), dtn_bp_agent_get_num_in_cust);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY), dtn_bp_agent_get_num_pend_reassembly);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY), dtn_bp_agent_get_bundles_by_priority);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY), dtn_bp_agent_get_bytes_by_priority);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY), dtn_bp_agent_get_src_bundles_by_priority);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY), dtn_bp_agent_get_src_bytes_by_priority);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES), dtn_bp_agent_get_num_fragmented_bundles);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED), dtn_bp_agent_get_num_fragments_produced);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON), dtn_bp_agent_get_num_failed_by_reason);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED), dtn_bp_agent_get_num_bundles_deleted);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES), dtn_bp_agent_get_failed_custody_bundles);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES), dtn_bp_agent_get_failed_custody_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES), dtn_bp_agent_get_failed_forward_bundles);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES), dtn_bp_agent_get_failed_forward_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BUNDLES), dtn_bp_agent_get_abandoned_bundles);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BYTES), dtn_bp_agent_get_abandoned_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BUNDLES), dtn_bp_agent_get_discarded_bundles);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BYTES), dtn_bp_agent_get_discarded_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_NAMES), dtn_bp_agent_get_endpoint_names);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE), dtn_bp_agent_get_endpoint_active);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON), dtn_bp_agent_get_endpoint_singleton);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_POLICY), dtn_bp_agent_get_endpoint_policy);
+}
+
+void dtn_bp_agent_init_op()
+{
+
+}
+
+void dtn_bp_agent_init_var()
+{
+
+}
+
+void dtn_bp_agent_init_ctrl()
+{
+
+	adm_add_ctrldef(g_dtn_bp_agent_idx[ADM_CTRL_IDX], DTN_BP_AGENT_CTRL_RESET_ALL_COUNTS, 0, dtn_bp_agent_ctrl_reset_all_counts);
+}
+
+void dtn_bp_agent_init_mac()
+{
+
+}
+
+void dtn_bp_agent_init_rpttpl()
+{
+
+	rpttpl_t *def = NULL;
+
+	/* FULL_REPORT */
+	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_dtn_bp_agent_idx[ADM_RPTT_IDX], DTN_BP_AGENT_RPTTPL_FULL_REPORT));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAME));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_VERSION));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_ID));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_VERSION));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_AVAILABLE_STORAGE));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_LAST_RESET_TIME));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_REGISTRATIONS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_FWD));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_DIS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_IN_CUST));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(4)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(4)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(4)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(4)));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(4)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(8)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(16)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(32)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(64)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(128)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(256)));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_NAMES));
+	adm_add_rpttpl(def);
+	/* ENDPOINT_REPORT */
+	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_bp_agent_idx[ADM_RPTT_IDX], DTN_BP_AGENT_RPTTPL_ENDPOINT_REPORT));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_POLICY, tnv_from_map(AMP_TYPE_STR, 0)));
+	adm_add_rpttpl(def);
+}
+
+void dtn_bp_agent_init_tblt()
+{
+
+}
+
+#endif // _HAVE_DTN_BP_AGENT_ADM_
diff -ru --new-file ion-sf/bpv7/nm/agent/adm_bp_agent_impl.c ion-anms/bpv7/nm/agent/adm_bp_agent_impl.c
--- ion-sf/bpv7/nm/agent/adm_bp_agent_impl.c	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/agent/adm_bp_agent_impl.c	2023-05-15 12:59:40.781869527 -0400
@@ -0,0 +1,1002 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bp_agent_impl.c
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated c file 
+ **
+ ****************************************************************************/
+
+/*   START CUSTOM INCLUDES HERE  */
+#include "ion.h"
+#include "bp.h"
+#include "bpP.h"
+#include "bpnm.h"
+
+
+/*   STOP CUSTOM INCLUDES HERE  */
+
+
+#include "shared/adm/adm.h"
+#include "adm_bp_agent_impl.h"
+
+/*   START CUSTOM FUNCTIONS HERE */
+/*             TODO              */
+/*   STOP CUSTOM FUNCTIONS HERE  */
+
+void dtn_bp_agent_setup()
+{
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION setup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION setup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+}
+
+void dtn_bp_agent_cleanup()
+{
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION cleanup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION cleanup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+}
+
+
+/* Metadata Functions */
+
+
+tnv_t *dtn_bp_agent_meta_name(tnvc_t *parms)
+{
+	return tnv_from_str("bp_agent");
+}
+
+
+tnv_t *dtn_bp_agent_meta_namespace(tnvc_t *parms)
+{
+	return tnv_from_str("DTN/bp_agent");
+}
+
+
+tnv_t *dtn_bp_agent_meta_version(tnvc_t *parms)
+{
+	return tnv_from_str("v0.1");
+}
+
+
+tnv_t *dtn_bp_agent_meta_organization(tnvc_t *parms)
+{
+	return tnv_from_str("JHUAPL");
+}
+
+
+/* Constant Functions */
+/* Table Functions */
+
+
+/* Collect Functions */
+/*
+ * The node administration endpoint
+ */
+tnv_t *dtn_bp_agent_get_bp_node_id(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_bp_node_id BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpNode node_state;
+	bpnm_node_get(&node_state);
+
+	result = tnv_from_str((char *) node_state.nodeID);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_bp_node_id BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * The latest version of the BP supported by this node
+ */
+tnv_t *dtn_bp_agent_get_bp_node_version(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_bp_node_version BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpNode node_state;
+	bpnm_node_get(&node_state);
+
+	result = tnv_from_str((char *) node_state.bpVersionNbr);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_bp_node_version BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Bytes available for bundle storage
+ */
+tnv_t *dtn_bp_agent_get_available_storage(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_available_storage BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpNode node_state;
+	bpnm_node_get(&node_state);
+
+	result = tnv_from_uvast(node_state.avblStorage);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_available_storage BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * The last time that BP counters were reset, either due to execution of a reset control or a restart o
+ * f the node itself
+ */
+tnv_t *dtn_bp_agent_get_last_reset_time(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_last_reset_time BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	Sdr sdr = getIonsdr();
+	Object dbobj = getBpDbObject();
+	BpDB db;
+
+	// TODO Check return call for sdr_begin_xn
+	CHKNULL(sdr_begin_xn(sdr));
+	sdr_stage(sdr, (char *) &db, dbobj, sizeof(BpDB));
+
+	result = tnv_from_uvast(db.resetTime);
+	oK(sdr_end_xn(sdr));
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_last_reset_time BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of registrations
+ */
+tnv_t *dtn_bp_agent_get_num_registrations(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_registrations BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpNode node_state;
+	bpnm_node_get(&node_state);
+
+	result = tnv_from_uint(node_state.nbrOfRegistrations);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_registrations BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles pending forwarding
+ */
+tnv_t *dtn_bp_agent_get_num_pend_fwd(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_pend_fwd BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.currentForwardPending);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_pend_fwd BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles awaiting dispatch
+ */
+tnv_t *dtn_bp_agent_get_num_pend_dis(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_pend_dis BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.currentDispatchPending);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_pend_dis BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles
+ */
+tnv_t *dtn_bp_agent_get_num_in_cust(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_in_cust BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.currentInCustody);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_in_cust BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles pending reassembly
+ */
+tnv_t *dtn_bp_agent_get_num_pend_reassembly(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_pend_reassembly BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.currentReassemblyPending);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_pend_reassembly BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles for the given priority. Priority is given as a priority mask where Bulk=0x1, norma
+ * l=0x2, express=0x4. Any bundles matching any of the masked priorities will be included in the return
+ * ed count
+ */
+tnv_t *dtn_bp_agent_get_bundles_by_priority(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_bundles_by_priority BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	int success = 0;
+
+	bpnm_disposition_get(&state);
+	uvast val = 0;
+	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
+
+	if(mask & 0x1)
+	{
+		val += state.currentResidentCount[0];
+	}
+	if(mask & 0x2)
+	{
+		val += state.currentResidentCount[1];
+	}
+	if(mask & 0x4)
+	{
+		val += state.currentResidentCount[2];
+	}
+
+	result = tnv_from_uvast(val);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_bundles_by_priority BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bytes of the given priority. Priority is given as a priority mask where bulk=0x1, normal=0
+ * x2, express=0x4. Any bundles matching any of the masked priorities will be included in the returned 
+ * count.
+ */
+tnv_t *dtn_bp_agent_get_bytes_by_priority(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_bytes_by_priority BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	int success = 0;
+	bpnm_disposition_get(&state);
+	uvast val = 0;
+	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
+
+	if(mask & 0x1)
+	{
+		val += state.currentResidentBytes[0];
+	}
+	if(mask & 0x2)
+	{
+		val += state.currentResidentBytes[1];
+	}
+	if(mask & 0x4)
+	{
+		val += state.currentResidentBytes[2];
+	}
+
+	result = tnv_from_uvast(val);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_bytes_by_priority BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles sourced by this node of the given priority. Priority is given as a priority mask w
+ * here bulk=0x1, normal=0x2, express=0x4. Any bundles sourced by this node and matching any of the mas
+ * ked priorities will be included in the returned count.
+ */
+tnv_t *dtn_bp_agent_get_src_bundles_by_priority(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_src_bundles_by_priority BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	int success = 0;
+	bpnm_disposition_get(&state);
+
+	uvast val = 0;
+	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
+
+	if(mask & 0x1)
+	{
+		val += state.bundleSourceCount[0];
+	}
+	if(mask & 0x2)
+	{
+		val += state.bundleSourceCount[1];
+	}
+	if(mask & 0x4)
+	{
+		val += state.bundleSourceCount[2];
+	}
+
+	result = tnv_from_uvast(val);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_src_bundles_by_priority BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bytes sourced by this node of the given priority. Priority is given as a priority mask whe
+ * re bulk=0x1, normal=0x2, express=0x4. Any bundles sourced by this node and matching any of the maske
+ * d priorities will be included in the returned count
+ */
+tnv_t *dtn_bp_agent_get_src_bytes_by_priority(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_src_bytes_by_priority BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	int success = 0;
+	bpnm_disposition_get(&state);
+
+	uvast val = 0;
+	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
+
+	if(mask & 0x1)
+	{
+		val += state.bundleSourceBytes[0];
+	}
+	if(mask & 0x2)
+	{
+		val += state.bundleSourceBytes[1];
+	}
+	if(mask & 0x4)
+	{
+		val += state.bundleSourceBytes[2];
+	}
+
+	result = tnv_from_uvast(val);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_src_bytes_by_priority BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of fragmented bundles
+ */
+tnv_t *dtn_bp_agent_get_num_fragmented_bundles(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fragmented_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.bundlesFragmented);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fragmented_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles with fragmentary payloads produced by this node
+ */
+tnv_t *dtn_bp_agent_get_num_fragments_produced(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fragments_produced BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.fragmentsProduced);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fragments_produced BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles failed for any of the given reasons. (noInfo=0x1, Expired=0x2, UniFwd=0x4, Cancell
+ * ed=0x8, NoStorage=0x10, BadEID=0x20, NoRoute=0x40, NoContact=0x80, BadBlock=0x100)
+ */
+tnv_t *dtn_bp_agent_get_num_failed_by_reason(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_failed_by_reason BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	int success = 0;
+	bpnm_disposition_get(&state);
+
+	uint32_t mask = adm_get_parm_uint(parms, 0, &success);
+	uvast val = 0;
+
+	if(mask & 0x01)
+	{
+		val += state.delNoneCount;
+	}
+	if(mask & 0x02)
+	{
+		val += state.delExpiredCount;
+	}
+	if(mask & 0x04)
+	{
+		val += state.delFwdUnidirCount;
+	}
+	if(mask & 0x08)
+	{
+		val += state.delCanceledCount;
+	}
+	if(mask & 0x10)
+	{
+		val += state.delDepletionCount;
+	}
+	if(mask & 0x20)
+	{
+		val += state.delEidMalformedCount;
+	}
+	if(mask & 0x40)
+	{
+		val += state.delNoRouteCount;
+	}
+	if(mask & 0x80)
+	{
+		val += state.delNoContactCount;
+	}
+	if(mask & 0x100)
+	{
+		val += state.delBlkMalformedCount;
+	}
+
+	result = tnv_from_uvast(val);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_failed_by_reason BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles deleted by this node
+ */
+tnv_t *dtn_bp_agent_get_num_bundles_deleted(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bundles_deleted BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.delNoneCount + state.delExpiredCount + state.delFwdUnidirCount + state.delCanceledCount + state.delDepletionCount + state.delEidMalformedCount + state.delNoRouteCount + state.delNoContactCount + state.delBlkMalformedCount);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bundles_deleted BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundle fails at this node
+ */
+tnv_t *dtn_bp_agent_get_failed_custody_bundles(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_failed_custody_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.custodyRefusedCount);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_failed_custody_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number bytes of fails at this node
+ */
+tnv_t *dtn_bp_agent_get_failed_custody_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_failed_custody_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.custodyRefusedBytes);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_failed_custody_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number bundles not forwarded by this node
+ */
+tnv_t *dtn_bp_agent_get_failed_forward_bundles(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_failed_forward_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.bundleFwdFailedCount);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_failed_forward_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bytes not forwaded by this node
+ */
+tnv_t *dtn_bp_agent_get_failed_forward_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_failed_forward_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.bundleFwdFailedBytes);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_failed_forward_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles abandoned by this node
+ */
+tnv_t *dtn_bp_agent_get_abandoned_bundles(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_abandoned_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.bundleAbandonCount);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_abandoned_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bytes abandoned by this node
+ */
+tnv_t *dtn_bp_agent_get_abandoned_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_abandoned_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.bundleAbandonBytes);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_abandoned_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bundles discarded by this node
+ */
+tnv_t *dtn_bp_agent_get_discarded_bundles(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_discarded_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.bundleDiscardCount);
+	
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_discarded_bundles BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * number of bytes discarded by this node
+ */
+tnv_t *dtn_bp_agent_get_discarded_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_discarded_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	NmbpDisposition state;
+	bpnm_disposition_get(&state);
+
+	result = tnv_from_uvast(state.bundleDiscardBytes);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_discarded_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * CSV list of endpoint names for this node
+ */
+tnv_t *dtn_bp_agent_get_endpoint_names(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_endpoint_names BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char names[2049];
+	char *ptrs[128];
+	int num = 0;
+	int i = 0;
+
+	bpnm_endpointNames_get((char *) names, 2048, ptrs, &num);
+
+	for(i = 0; i < (num-1); i++)
+	{
+		*(ptrs[i+1]-sizeof(char)) = ',';
+	}
+
+	result = tnv_from_str(names);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_endpoint_names BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * is the given endpoint active? (0=no)
+ */
+tnv_t *dtn_bp_agent_get_endpoint_active(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_endpoint_active BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	NmbpEndpoint endpoint;
+	int success = 0;
+
+	bpnm_endpoint_get(name, &endpoint, &success);
+	if(success != 0)
+	{
+		result = tnv_from_uint(endpoint.active);
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_endpoint_active BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * is the given endpoint singleton? (0=no)
+ */
+tnv_t *dtn_bp_agent_get_endpoint_singleton(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_endpoint_singleton BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	NmbpEndpoint endpoint;
+	int success = 0;
+
+	bpnm_endpoint_get(name, &endpoint, &success);
+	if(success != 0)
+	{
+		result = tnv_from_uint(endpoint.singleton);
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_endpoint_singleton BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Does the endpoint abandon on fail (0=no)
+ */
+tnv_t *dtn_bp_agent_get_endpoint_policy(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_endpoint_policy BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	NmbpEndpoint endpoint;
+	int success = 0;
+
+	bpnm_endpoint_get(name, &endpoint, &success);
+	if(success != 0)
+	{
+		result = tnv_from_uint(endpoint.abandonOnDelivFailure);
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_endpoint_policy BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+
+/* Control Functions */
+
+/*
+ * This control causes the Agent to reset all counts associated with bundle or byte statistics and to s
+ * et the last reset time of the BP primitive data to the time when the control was run
+ */
+tnv_t *dtn_bp_agent_ctrl_reset_all_counts(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_reset_all_counts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	bpnm_disposition_reset();
+	*status = CTRL_SUCCESS;
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_reset_all_counts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+
+/* OP Functions */
diff -ru --new-file ion-sf/bpv7/nm/agent/adm_bp_agent_impl.h ion-anms/bpv7/nm/agent/adm_bp_agent_impl.h
--- ion-sf/bpv7/nm/agent/adm_bp_agent_impl.h	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/agent/adm_bp_agent_impl.h	2023-05-15 12:59:40.785869565 -0400
@@ -0,0 +1,101 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bp_agent_impl.h
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated header file 
+ **
+ ****************************************************************************/
+
+#ifndef ADM_BP_AGENT_IMPL_H_
+#define ADM_BP_AGENT_IMPL_H_
+
+/*   START CUSTOM INCLUDES HERE  */
+/*             TODO              */
+/*   STOP CUSTOM INCLUDES HERE  */
+
+
+#include "shared/utils/utils.h"
+#include "shared/primitives/ctrl.h"
+#include "shared/primitives/table.h"
+#include "shared/primitives/tnv.h"
+
+/*   START typeENUM */
+/*             TODO              */
+/*   STOP typeENUM  */
+
+void name_adm_init_agent();
+
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                     Retrieval Functions                                     +
+ * +---------------------------------------------------------------------------------------------+
+ */
+/*   START CUSTOM FUNCTIONS HERE */
+/*             TODO              */
+/*   STOP CUSTOM FUNCTIONS HERE  */
+
+void dtn_bp_agent_setup();
+void dtn_bp_agent_cleanup();
+
+
+/* Metadata Functions */
+tnv_t *dtn_bp_agent_meta_name(tnvc_t *parms);
+tnv_t *dtn_bp_agent_meta_namespace(tnvc_t *parms);
+tnv_t *dtn_bp_agent_meta_version(tnvc_t *parms);
+tnv_t *dtn_bp_agent_meta_organization(tnvc_t *parms);
+
+/* Constant Functions */
+
+/* Collect Functions */
+tnv_t *dtn_bp_agent_get_bp_node_id(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_bp_node_version(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_available_storage(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_last_reset_time(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_num_registrations(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_num_pend_fwd(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_num_pend_dis(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_num_in_cust(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_num_pend_reassembly(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_bundles_by_priority(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_bytes_by_priority(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_src_bundles_by_priority(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_src_bytes_by_priority(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_num_fragmented_bundles(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_num_fragments_produced(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_num_failed_by_reason(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_num_bundles_deleted(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_failed_custody_bundles(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_failed_custody_bytes(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_failed_forward_bundles(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_failed_forward_bytes(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_abandoned_bundles(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_abandoned_bytes(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_discarded_bundles(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_discarded_bytes(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_endpoint_names(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_endpoint_active(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_endpoint_singleton(tnvc_t *parms);
+tnv_t *dtn_bp_agent_get_endpoint_policy(tnvc_t *parms);
+
+
+/* Control Functions */
+tnv_t *dtn_bp_agent_ctrl_reset_all_counts(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+
+
+/* OP Functions */
+
+
+/* Table Build Functions */
+
+#endif //ADM_BP_AGENT_IMPL_H_
diff -ru --new-file ion-sf/bpv7/nm/agent/adm_bpsec_agent.c ion-anms/bpv7/nm/agent/adm_bpsec_agent.c
--- ion-sf/bpv7/nm/agent/adm_bpsec_agent.c	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/agent/adm_bpsec_agent.c	2023-05-15 12:59:40.813869825 -0400
@@ -0,0 +1,282 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bpsec_agent.c
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated c file 
+ **
+ ****************************************************************************/
+
+
+#include "ion.h"
+#include "platform.h"
+#include "adm_bpsec.h"
+#include "shared/utils/utils.h"
+#include "shared/primitives/report.h"
+#include "shared/primitives/blob.h"
+#include "adm_bpsec_impl.h"
+#include "agent/rda.h"
+
+
+#include "adm_amp_agent.h"
+
+#define _HAVE_DTN_BPSEC_ADM_
+#ifdef _HAVE_DTN_BPSEC_ADM_
+
+static vec_idx_t g_dtn_bpsec_idx[11];
+
+void dtn_bpsec_init()
+{
+	adm_add_adm_info("dtn_bpsec", ADM_ENUM_DTN_BPSEC);
+
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_RPTT_IDX), &(g_dtn_bpsec_idx[ADM_RPTT_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_EDD_IDX), &(g_dtn_bpsec_idx[ADM_EDD_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_CTRL_IDX), &(g_dtn_bpsec_idx[ADM_CTRL_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_META_IDX), &(g_dtn_bpsec_idx[ADM_META_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_TBLT_IDX), &(g_dtn_bpsec_idx[ADM_TBLT_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_VAR_IDX), &(g_dtn_bpsec_idx[ADM_VAR_IDX]));
+
+
+	dtn_bpsec_setup();
+	dtn_bpsec_init_meta();
+	dtn_bpsec_init_cnst();
+	dtn_bpsec_init_edd();
+	dtn_bpsec_init_op();
+	dtn_bpsec_init_var();
+	dtn_bpsec_init_ctrl();
+	dtn_bpsec_init_mac();
+	dtn_bpsec_init_rpttpl();
+	dtn_bpsec_init_tblt();
+}
+
+void dtn_bpsec_init_meta()
+{
+
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_NAME), dtn_bpsec_meta_name);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_NAMESPACE), dtn_bpsec_meta_namespace);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_VERSION), dtn_bpsec_meta_version);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_ORGANIZATION), dtn_bpsec_meta_organization);
+}
+
+void dtn_bpsec_init_cnst()
+{
+
+}
+
+void dtn_bpsec_init_edd()
+{
+
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK), dtn_bpsec_get_num_good_tx_bcb_blk);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK), dtn_bpsec_get_num_bad_tx_bcb_blk);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK), dtn_bpsec_get_num_good_rx_bcb_blk);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK), dtn_bpsec_get_num_bad_rx_bcb_blk);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS), dtn_bpsec_get_num_missing_rx_bcb_blks);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS), dtn_bpsec_get_num_fwd_bcb_blks);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES), dtn_bpsec_get_num_good_tx_bcb_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES), dtn_bpsec_get_num_bad_tx_bcb_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS), dtn_bpsec_get_num_bad_tx_bcb_blks);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES), dtn_bpsec_get_num_good_rx_bcb_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES), dtn_bpsec_get_num_bad_rx_bcb_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES), dtn_bpsec_get_num_missing_rx_bcb_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES), dtn_bpsec_get_num_fwd_bcb_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS), dtn_bpsec_get_num_good_tx_bib_blks);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS), dtn_bpsec_get_num_bad_tx_bib_blks);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS), dtn_bpsec_get_num_good_rx_bib_blks);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS), dtn_bpsec_get_num_bad_rx_bib_blks);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS), dtn_bpsec_get_num_miss_rx_bib_blks);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS), dtn_bpsec_get_num_fwd_bib_blks);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES), dtn_bpsec_get_num_good_tx_bib_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES), dtn_bpsec_get_num_bad_tx_bib_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES), dtn_bpsec_get_num_good_rx_bib_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES), dtn_bpsec_get_num_bad_rx_bib_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES), dtn_bpsec_get_num_miss_rx_bib_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES), dtn_bpsec_get_num_fwd_bib_bytes);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE), dtn_bpsec_get_last_update);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_KNOWN_KEYS), dtn_bpsec_get_num_known_keys);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_KEY_NAMES), dtn_bpsec_get_key_names);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_CIPHERSUITE_NAMES), dtn_bpsec_get_ciphersuite_names);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_RULE_SOURCE), dtn_bpsec_get_rule_source);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC), dtn_bpsec_get_num_good_tx_bcb_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC), dtn_bpsec_get_num_bad_tx_bcb_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC), dtn_bpsec_get_num_good_rx_bcb_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC), dtn_bpsec_get_num_bad_rx_bcb_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC), dtn_bpsec_get_num_missing_rx_bcb_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC), dtn_bpsec_get_num_fwd_bcb_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC), dtn_bpsec_get_num_good_tx_bcb_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC), dtn_bpsec_get_num_bad_tx_bcb_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC), dtn_bpsec_get_num_good_rx_bcb_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC), dtn_bpsec_get_num_bad_rx_bcb_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC), dtn_bpsec_get_num_missing_rx_bcb_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC), dtn_bpsec_get_num_fwd_bcb_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC), dtn_bpsec_get_num_good_tx_bib_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC), dtn_bpsec_get_num_bad_tx_bib_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC), dtn_bpsec_get_num_good_rx_bib_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC), dtn_bpsec_get_num_bad_rx_bib_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC), dtn_bpsec_get_num_miss_rx_bib_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC), dtn_bpsec_get_num_fwd_bib_blks_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC), dtn_bpsec_get_num_good_tx_bib_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC), dtn_bpsec_get_num_bad_tx_bib_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC), dtn_bpsec_get_num_good_rx_bib_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC), dtn_bpsec_get_num_bad_rx_bib_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC), dtn_bpsec_get_num_missing_rx_bib_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC), dtn_bpsec_get_num_fwd_bib_bytes_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE_SRC), dtn_bpsec_get_last_update_src);
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_RESET), dtn_bpsec_get_last_reset);
+}
+
+void dtn_bpsec_init_op()
+{
+
+}
+
+void dtn_bpsec_init_var()
+{
+
+	ari_t *id = NULL;
+
+	expr_t *expr = NULL;
+
+
+	/* TOTAL_BAD_TX_BLKS */
+
+	id = adm_build_ari(AMP_TYPE_VAR, 0, g_dtn_bpsec_idx[ADM_VAR_IDX], DTN_BPSEC_VAR_TOTAL_BAD_TX_BLKS);
+	expr = expr_create(AMP_TYPE_UINT);
+	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS));
+	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS));
+	expr_add_item(expr, adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUINT));
+	adm_add_var_from_expr(id, AMP_TYPE_UINT, expr);
+}
+
+void dtn_bpsec_init_ctrl()
+{
+
+	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_RST_ALL_CNTS, 0, dtn_bpsec_ctrl_rst_all_cnts);
+	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_RST_SRC_CNTS, 1, dtn_bpsec_ctrl_rst_src_cnts);
+	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DELETE_KEY, 1, dtn_bpsec_ctrl_delete_key);
+	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_KEY, 2, dtn_bpsec_ctrl_add_key);
+	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_BIB_RULE, 5, dtn_bpsec_ctrl_add_bib_rule);
+	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DEL_BIB_RULE, 3, dtn_bpsec_ctrl_del_bib_rule);
+	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_BCB_RULE, 5, dtn_bpsec_ctrl_add_bcb_rule);
+	adm_add_ctrldef(g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DEL_BCB_RULE, 3, dtn_bpsec_ctrl_del_bcb_rule);
+}
+
+void dtn_bpsec_init_mac()
+{
+
+}
+
+void dtn_bpsec_init_rpttpl()
+{
+
+	rpttpl_t *def = NULL;
+
+	/* FULL_REPORT */
+	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_dtn_bpsec_idx[ADM_RPTT_IDX], DTN_BPSEC_RPTTPL_FULL_REPORT));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_KNOWN_KEYS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_KEY_NAMES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_CIPHERSUITE_NAMES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_RULE_SOURCE));
+	adm_add_rpttpl(def);
+	/* SOURCE_REPORT */
+	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_bpsec_idx[ADM_RPTT_IDX], DTN_BPSEC_RPTTPL_SOURCE_REPORT));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_RESET, tnv_from_map(AMP_TYPE_STR, 0)));
+	adm_add_rpttpl(def);
+}
+
+void dtn_bpsec_init_tblt()
+{
+
+	tblt_t *def = NULL;
+
+	/* KEYS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_KEYS), dtn_bpsec_tblt_keys);
+	tblt_add_col(def, AMP_TYPE_STR, "key_name");
+	adm_add_tblt(def);
+
+	/* CIPHERSUITES */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_CIPHERSUITES), dtn_bpsec_tblt_ciphersuites);
+	tblt_add_col(def, AMP_TYPE_STR, "csname");
+	adm_add_tblt(def);
+
+	/* BIB_RULES */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_BIB_RULES), dtn_bpsec_tblt_bib_rules);
+	tblt_add_col(def, AMP_TYPE_STR, "SrcEid");
+	tblt_add_col(def, AMP_TYPE_STR, "DestEid");
+	tblt_add_col(def, AMP_TYPE_UINT, "TgtBlk");
+	tblt_add_col(def, AMP_TYPE_STR, "csName");
+	tblt_add_col(def, AMP_TYPE_STR, "keyName");
+	adm_add_tblt(def);
+
+	/* BCB_RULES */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_BCB_RULES), dtn_bpsec_tblt_bcb_rules);
+	tblt_add_col(def, AMP_TYPE_STR, "SrcEid");
+	tblt_add_col(def, AMP_TYPE_STR, "DestEid");
+	tblt_add_col(def, AMP_TYPE_UINT, "TgtBlk");
+	tblt_add_col(def, AMP_TYPE_STR, "csName");
+	tblt_add_col(def, AMP_TYPE_STR, "keyName");
+	adm_add_tblt(def);
+}
+
+#endif // _HAVE_DTN_BPSEC_ADM_
diff -ru --new-file ion-sf/bpv7/nm/agent/adm_bpsec_impl.c ion-anms/bpv7/nm/agent/adm_bpsec_impl.c
--- ion-sf/bpv7/nm/agent/adm_bpsec_impl.c	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/agent/adm_bpsec_impl.c	2023-05-15 12:59:40.813869825 -0400
@@ -0,0 +1,1995 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bpsec_impl.c
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated c file 
+ **
+ ****************************************************************************/
+
+/*   START CUSTOM INCLUDES HERE  */
+#include <math.h>
+
+#include "adm_bpsec_impl.h"
+#include "shared/primitives/report.h"
+#include "agent/rda.h"
+#include "shared/primitives/ctrl.h"
+#include "shared/primitives/table.h"
+
+#include "adm_bpsec.h"
+#include "profiles.h"
+/*   STOP CUSTOM INCLUDES HERE  */
+
+
+#include "shared/adm/adm.h"
+#include "adm_bpsec_impl.h"
+
+/*   START CUSTOM FUNCTIONS HERE */
+
+
+static tnv_t *adm_bpsec_get_src_val(tnvc_t *parms, bpsec_instr_type_e type, query_type_e query)
+{
+    tnv_t *result = tnv_create();
+	char *eid_id = NULL;
+	uvast num = 0;
+	int success = ERROR;
+
+	result->type = AMP_TYPE_UNK;
+
+
+	if((eid_id = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) == NULL)
+	{
+		return result;
+	}
+
+	switch(query)
+	{
+	case SRC_BLK:     success = bpsec_instr_get_src_blk(eid_id, type, &num); break;
+	case SRC_BYTES:   success = bpsec_instr_get_src_bytes(eid_id, type, &num); break;
+	default: success = ERROR; break;
+	}
+
+	if(success != ERROR)
+	{
+		result->type = AMP_TYPE_UVAST;
+		result->value.as_uvast = num;
+	}
+
+	return result;
+}
+
+static tnv_t *adm_bpsec_get_tot_val(bpsec_instr_type_e type, query_type_e query)
+{
+        tnv_t *result = tnv_create();
+	uvast num = 0;
+	int8_t success = 0;
+
+	switch(query)
+	{
+	case TOTAL_BLK:   success = bpsec_instr_get_total_blk(type, &num); break;
+	case TOTAL_BYTES: success = bpsec_instr_get_total_bytes(type, &num); break;
+	default: success = ERROR; break;
+	}
+
+	if(success == ERROR)
+	{
+		result->type = AMP_TYPE_UNK;
+	}
+	else
+	{
+
+		result->type = AMP_TYPE_UVAST;
+		result->value.as_uvast = num;
+	}
+
+	return result;
+}
+
+/*   STOP CUSTOM FUNCTIONS HERE  */
+
+void dtn_bpsec_setup()
+{
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION setup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION setup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+}
+
+void dtn_bpsec_cleanup()
+{
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION cleanup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION cleanup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+}
+
+
+/* Metadata Functions */
+
+
+tnv_t *dtn_bpsec_meta_name(tnvc_t *parms)
+{
+	return tnv_from_str("bpsec");
+}
+
+
+tnv_t *dtn_bpsec_meta_namespace(tnvc_t *parms)
+{
+	return tnv_from_str("DTN/bpsec");
+}
+
+
+tnv_t *dtn_bpsec_meta_version(tnvc_t *parms)
+{
+	return tnv_from_str("v1.0");
+}
+
+
+tnv_t *dtn_bpsec_meta_organization(tnvc_t *parms)
+{
+	return tnv_from_str("JHUAPL");
+}
+
+
+/* Constant Functions */
+/* Table Functions */
+
+
+/*
+ * This table lists all keys in the security policy database.
+ */
+tbl_t *dtn_bpsec_tblt_keys(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_keys BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_keys BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/*
+ * This table lists supported ciphersuites.
+ */
+tbl_t *dtn_bpsec_tblt_ciphersuites(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_ciphersuites BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_ciphersuites BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/*
+ * BIB Rules.
+ */
+tbl_t *dtn_bpsec_tblt_bib_rules(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_bib_rules BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	Sdr sdr = getIonsdr();
+	Object listObj = 0;
+	Object	elt = 0;
+	OBJ_POINTER(BPsecBibRule, rule);
+	char strBuffer[SDRSTRING_BUFSZ];
+	tnvc_t *cur_row = NULL;
+	int len = 0;
+
+	if((listObj = sec_get_bpsecBibRuleList()) == 0)
+	{
+		AMP_DEBUG_ERR("dtn_bpsec_tblt_bib_rules","Cannot get list.", NULL);
+		tbl_release(table, 1);
+		return NULL;
+	}
+
+	if (sdr_begin_xn(sdr) < 0)
+	{
+		AMP_DEBUG_ERR("dtn_bpsec_tblt_bib_rules","Can't start transaction.", NULL);
+		tbl_release(table, 1);
+		return NULL;
+	}
+
+	for (elt = sdr_list_first(sdr, listObj); elt; elt = sdr_list_next(sdr, elt))
+	{
+
+		if((cur_row = tnvc_create(5)) != NULL)
+		{
+			GET_OBJ_POINTER(sdr, BPsecBibRule, rule, sdr_list_data(sdr, elt));
+
+			if(rule != NULL)
+			{
+				len = sdr_string_read(sdr, strBuffer, rule->securitySrcEid);
+				tnvc_insert(cur_row, tnv_from_str( (len > 0) ? strBuffer : "unk"));
+
+				len = sdr_string_read(sdr, strBuffer, rule->destEid);
+				tnvc_insert(cur_row, tnv_from_str( (len > 0) ? strBuffer : "unk"));
+
+				tnvc_insert(cur_row, tnv_from_uint(rule->blockType));
+				tnvc_insert(cur_row, tnv_from_str(rule->profileName));
+				tnvc_insert(cur_row, tnv_from_str(rule->keyName));
+
+				tbl_add_row(table, cur_row);
+			}
+			else
+			{
+				AMP_DEBUG_WARN("dtn_bpsec_tblt_bib_rules", "NULL rule?", NULL);
+			}
+		}
+		else
+		{
+			AMP_DEBUG_WARN("dtn_bpsec_tblt_bib_rules", "Can't allocate row. Skipping.", NULL);
+		}
+	}
+
+	sdr_exit_xn(sdr);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_bib_rules BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/*
+ * BCB Rules.
+ */
+tbl_t *dtn_bpsec_tblt_bcb_rules(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_bcb_rules BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	Sdr sdr = getIonsdr();
+	Object listObj = 0;
+	Object	elt = 0;
+	OBJ_POINTER(BPsecBcbRule, rule);
+	char strBuffer[SDRSTRING_BUFSZ];
+	tnvc_t *cur_row = NULL;
+	int len = 0;
+
+	if((listObj = sec_get_bpsecBcbRuleList()) == 0)
+	{
+		AMP_DEBUG_ERR("dtn_bpsec_tblt_bcb_rules","Cannot get list.", NULL);
+		tbl_release(table, 1);
+		return NULL;
+	}
+
+	if (sdr_begin_xn(sdr) < 0)
+	{
+		AMP_DEBUG_ERR("dtn_bpsec_tblt_bcb_rules","Can't start transaction.", NULL);
+		tbl_release(table, 1);
+		return NULL;
+	}
+
+	for (elt = sdr_list_first(sdr, listObj); elt; elt = sdr_list_next(sdr, elt))
+	{
+		if((cur_row = tnvc_create(5)) != NULL)
+		{
+			GET_OBJ_POINTER(sdr, BPsecBcbRule, rule, sdr_list_data(sdr, elt));
+
+			if(rule != NULL)
+			{
+				len = sdr_string_read(sdr, strBuffer, rule->securitySrcEid);
+				tnvc_insert(cur_row, tnv_from_str( (len > 0) ? strBuffer : "unk"));
+
+				len = sdr_string_read(sdr, strBuffer, rule->destEid);
+				tnvc_insert(cur_row, tnv_from_str( (len > 0) ? strBuffer : "unk"));
+
+				tnvc_insert(cur_row, tnv_from_uint(rule->blockType));
+				tnvc_insert(cur_row, tnv_from_str(rule->profileName));
+				tnvc_insert(cur_row, tnv_from_str(rule->keyName));
+
+				tbl_add_row(table, cur_row);
+			}
+			else
+			{
+				AMP_DEBUG_WARN("dtn_bpsec_tblt_bcb_rules", "NULL rule?", NULL);
+			}
+		}
+		else
+		{
+			AMP_DEBUG_WARN("dtn_bpsec_tblt_bcb_rules", "Can't allocate row. Skipping.", NULL);
+		}
+	}
+
+	sdr_exit_xn(sdr);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_bcb_rules BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/* Collect Functions */
+/*
+ * Total successfully Tx Bundle Confidentiality blocks
+ */
+tnv_t *dtn_bpsec_get_num_good_tx_bcb_blk(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_tx_bcb_blk BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_TX_PASS, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_tx_bcb_blk BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total unsuccessfully Tx Block Confidentiality Block (BCB) blocks
+ */
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blk(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_blk BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_TX_FAIL, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_blk BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total successfully Rx BCB blocks
+ */
+tnv_t *dtn_bpsec_get_num_good_rx_bcb_blk(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_rx_bcb_blk BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_RX_PASS, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_rx_bcb_blk BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total unsuccessfully Rx BCB blocks
+ */
+tnv_t *dtn_bpsec_get_num_bad_rx_bcb_blk(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_rx_bcb_blk BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_RX_FAIL, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bcb_blk BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total missing-on-RX BCB blocks
+ */
+tnv_t *dtn_bpsec_get_num_missing_rx_bcb_blks(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_missing_rx_bcb_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_RX_MISS, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bcb_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total forward BCB blocks
+ */
+tnv_t *dtn_bpsec_get_num_fwd_bcb_blks(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fwd_bcb_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_FWD, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fwd_bcb_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total successfully Tx BCB bytes
+ */
+tnv_t *dtn_bpsec_get_num_good_tx_bcb_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_tx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_TX_PASS, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_tx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total unsuccessfully Tx BCB bytes
+ */
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_TX_FAIL, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total unsuccessfully Tx BCB blocks
+ */
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blks(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_TX_FAIL, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total successfully Rx BCB bytes
+ */
+tnv_t *dtn_bpsec_get_num_good_rx_bcb_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_rx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_RX_PASS, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_rx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total unsuccessfully Rx BCB bytes
+ */
+tnv_t *dtn_bpsec_get_num_bad_rx_bcb_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_rx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_RX_FAIL, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total missing-on-Rx BCB bytes
+ */
+tnv_t *dtn_bpsec_get_num_missing_rx_bcb_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_missing_rx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_RX_MISS, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total forwarded BCB bytes
+ */
+tnv_t *dtn_bpsec_get_num_fwd_bcb_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fwd_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BCB_FWD, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fwd_bcb_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total successfully Tx Block Integrity Block (BIB) blocks
+ */
+tnv_t *dtn_bpsec_get_num_good_tx_bib_blks(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_tx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_TX_PASS, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_tx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total unsuccessfully Tx BIB blocks
+ */
+tnv_t *dtn_bpsec_get_num_bad_tx_bib_blks(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_tx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_TX_FAIL, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total successfully Rx BIB blocks
+ */
+tnv_t *dtn_bpsec_get_num_good_rx_bib_blks(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_rx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_RX_PASS, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_rx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total unsuccessfully Rx BIB blocks
+ */
+tnv_t *dtn_bpsec_get_num_bad_rx_bib_blks(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_rx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_RX_FAIL, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total missing-on-Rx BIB blocks
+ */
+tnv_t *dtn_bpsec_get_num_miss_rx_bib_blks(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_miss_rx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_RX_MISS, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_miss_rx_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total forwarded BIB blocks
+ */
+tnv_t *dtn_bpsec_get_num_fwd_bib_blks(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fwd_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_FWD, TOTAL_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fwd_bib_blks BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total successfully Tx BIB bytes
+ */
+tnv_t *dtn_bpsec_get_num_good_tx_bib_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_tx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_TX_PASS, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_tx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total unsuccessfully Tx BIB bytes
+ */
+tnv_t *dtn_bpsec_get_num_bad_tx_bib_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_tx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_TX_FAIL, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total successfully Rx BIB bytes
+ */
+tnv_t *dtn_bpsec_get_num_good_rx_bib_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_rx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_RX_PASS, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_rx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total unsuccessfully Rx BIB bytes
+ */
+tnv_t *dtn_bpsec_get_num_bad_rx_bib_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_rx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_RX_FAIL, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total missing-on-Rx BIB bytes
+ */
+tnv_t *dtn_bpsec_get_num_miss_rx_bib_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_miss_rx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_RX_MISS, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_miss_rx_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Total forwarded BIB bytes
+ */
+tnv_t *dtn_bpsec_get_num_fwd_bib_bytes(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fwd_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_tot_val( BIB_FWD, TOTAL_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fwd_bib_bytes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Last BPSEC update
+ */
+tnv_t *dtn_bpsec_get_last_update(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_last_update BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = tnv_create();
+	result->type = AMP_TYPE_UNK;
+	if(bpsec_instr_get_tot_update((time_t*)&(result->value.as_uint)) != ERROR)
+	{
+		result->type = AMP_TYPE_TS;
+	}
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_last_update BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of known keys
+ */
+tnv_t *dtn_bpsec_get_num_known_keys(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_known_keys BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	uint32_t size = 0;
+	result = tnv_create();
+	result->type = AMP_TYPE_UINT;
+	result->value.as_uint = bpsec_instr_get_num_keys((int*)&size);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_known_keys BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Known key names
+ */
+tnv_t *dtn_bpsec_get_key_names(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_key_names BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *tmp = bpsec_instr_get_keynames();
+
+	result = tnv_create();
+	result->type = AMP_TYPE_UNK;
+	/* TMP is allocated using MTAKE. We need to move it to
+	 * something using STAKE.
+	 */
+	if(tmp != NULL)
+	{
+		uint32_t size = strlen(tmp) + 1;
+		if((result->value.as_ptr = STAKE(size)) == NULL)
+		{
+			MRELEASE(tmp);
+			return result;
+		}
+		memcpy(result->value.as_ptr, tmp, size);
+		MRELEASE(tmp);
+
+		result->type = AMP_TYPE_STR;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_key_names BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Known ciphersuite names
+ */
+tnv_t *dtn_bpsec_get_ciphersuite_names(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_ciphersuite_names BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *tmp = bpsec_instr_get_csnames();
+
+	result = tnv_create();
+	result->type = AMP_TYPE_UNK;
+	/* TMP is allocated using MTAKE. We need to move it to
+	 * something using STAKE.
+	 */
+	if(tmp != NULL)
+	{
+		uint32_t size = strlen(tmp) + 1;
+		if((result->value.as_ptr = STAKE(size)) == NULL)
+		{
+			MRELEASE(tmp);
+			return result;
+		}
+		memcpy(result->value.as_ptr, tmp, size);
+		MRELEASE(tmp);
+
+		result->type = AMP_TYPE_STR;
+	}
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_ciphersuite_names BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Known rule sources
+ */
+tnv_t *dtn_bpsec_get_rule_source(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_rule_source BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *tmp = bpsec_instr_get_srcnames();
+
+	result = tnv_create();
+	result->type = AMP_TYPE_UNK;
+	/* TMP is allocated using MTAKE. We need to move it to
+	 * something using STAKE.
+	 */
+	if(tmp != NULL)
+	{
+		uint32_t size = strlen(tmp) + 1;
+		if((result->value.as_ptr = STAKE(size)) == NULL)
+		{
+			MRELEASE(tmp);
+			return result;
+		}
+		memcpy(result->value.as_ptr, tmp, size);
+		result->type = AMP_TYPE_STR;
+	}
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_rule_source BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of successfully Tx BCB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_good_tx_bcb_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_tx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_TX_PASS, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_tx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of failed TX BCB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_TX_FAIL, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of successfully Rx BCB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_good_rx_bcb_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_rx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_RX_PASS, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_rx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of failed RX BCB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_bad_rx_bcb_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_rx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_RX_FAIL, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of missing-onRX BCB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_missing_rx_bcb_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_missing_rx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_RX_MISS, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of forwarded BCB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_fwd_bcb_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fwd_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_FWD, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fwd_bcb_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of successfully Tx bcb bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_good_tx_bcb_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_tx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_TX_PASS, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_tx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of failed Tx bcb bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_tx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_TX_FAIL, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of successfully Rx bcb bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_good_rx_bcb_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_rx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_RX_PASS, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_rx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of failed Rx bcb bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_bad_rx_bcb_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_rx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_RX_FAIL, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of missing-on-Rx bcb bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_missing_rx_bcb_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_missing_rx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_RX_MISS, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of forwarded bcb bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_fwd_bcb_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fwd_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BCB_FWD, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fwd_bcb_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of successfully Tx BIB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_good_tx_bib_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_tx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_TX_PASS, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_tx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of failed Tx BIB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_bad_tx_bib_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_tx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_TX_FAIL, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of successfully Rx BIB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_good_rx_bib_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_rx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_RX_PASS, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_rx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of failed Rx BIB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_bad_rx_bib_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_rx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_RX_FAIL, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of missing-on-Rx BIB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_miss_rx_bib_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_miss_rx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_RX_MISS, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_miss_rx_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of forwarded BIB blocks from SRC
+ */
+tnv_t *dtn_bpsec_get_num_fwd_bib_blks_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fwd_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_FWD, SRC_BLK);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fwd_bib_blks_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of successfully Tx BIB bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_good_tx_bib_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_tx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_TX_PASS, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_tx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of failed Tx BIB bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_bad_tx_bib_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_tx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_TX_FAIL, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_tx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of successfully Rx BIB bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_good_rx_bib_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_good_rx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_RX_PASS, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_good_rx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of failed Rx BIB bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_bad_rx_bib_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_bad_rx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_RX_FAIL, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_bad_rx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of missing-on-Rx BIB bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_missing_rx_bib_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_missing_rx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return adm_bpsec_get_src_val(parms, BIB_RX_MISS, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_missing_rx_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Number of forwarded BIB bytes from SRC
+ */
+tnv_t *dtn_bpsec_get_num_fwd_bib_bytes_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_num_fwd_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	result = adm_bpsec_get_src_val(parms, BIB_FWD, SRC_BYTES);
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_num_fwd_bib_bytes_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Last BPSEC update from SRC
+ */
+tnv_t *dtn_bpsec_get_last_update_src(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_last_update_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	time_t time = 0;
+	char *name = NULL;
+	int success = 0;
+
+	result = tnv_create();
+	result->type = AMP_TYPE_UNK;
+
+	if((name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) == NULL)
+	{
+		return result;
+	}
+
+	if(bpsec_instr_get_src_update(name, &time) != ERROR)
+	{
+		result->type = AMP_TYPE_TS;
+		result->value.as_uint = time;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_last_update_src BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Last reset
+ */
+tnv_t *dtn_bpsec_get_last_reset(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_last_reset BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	bpsec_instr_misc_t misc;
+
+	result = tnv_create();
+	if(bpsec_instr_get_misc(&misc) == ERROR)
+	{
+		result->type = AMP_TYPE_UNK;
+		return result;
+	}
+
+	result->type = AMP_TYPE_TS;
+	result->value.as_uint = misc.last_reset;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_last_reset BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+
+/* Control Functions */
+
+/*
+ * This control causes the Agent to reset all counts associated with block or byte statistics and to se
+ * t the Last Reset Time of the BPsec EDD data to the time when the control was run.
+ */
+tnv_t *dtn_bpsec_ctrl_rst_all_cnts(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_rst_all_cnts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	bpsec_instr_reset();
+	*status = CTRL_SUCCESS;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_rst_all_cnts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * This control causes the Agent to reset all counts (blocks and bytes) associated with a given bundle 
+ * source and set the Last Reset Time of the source statistics to the time when the control was run.
+ */
+tnv_t *dtn_bpsec_ctrl_rst_src_cnts(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_rst_src_cnts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *src = NULL;
+	int success = 0;
+
+	/* Step 1: Grab the MID defining the new computed definition. */
+	if((src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) != NULL)
+	{
+		bpsec_instr_reset_src(src);
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_rst_src_cnts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * This control deletes a key from the BPsec system.
+ */
+tnv_t *dtn_bpsec_ctrl_delete_key(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_delete_key BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *name = NULL;
+	int success = 0;
+	/* Step 1: Grab the name of the key to delete. */
+	if((name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * Step 2: Make sure key to be deleted is not an active key. Deleting
+	 * an active key can lock someone out of the system
+	 */
+	if(sec_activeKey(name) != 0)
+	{
+		AMP_DEBUG_WARN("adm_bpsec_ctrl_delete_key","Can't remove active key %s", name);
+		return NULL;
+	}
+
+	if(sec_removeKey(name) == 1)
+	{
+		*status = CTRL_SUCCESS;
+	}
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_delete_key BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * This control adds a key to the BPsec system.
+ */
+tnv_t *dtn_bpsec_ctrl_add_key(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_add_key BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *name = NULL;
+	blob_t *value = NULL;
+	int success = 0;
+	/* Step 1: Grab the name of the new key. */
+	if((name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR)) == NULL)
+	{
+		return NULL;
+	}
+
+	/* Step 2: Grab the key value. */
+	if((value = adm_get_parm_obj(parms, 1, AMP_TYPE_STR)) == NULL)
+	{
+		return NULL;
+	}
+
+	if(sec_addKeyValue(name, (char *)value->value, value->length) == 1)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_add_key BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * This control configures policy on the BPsec protocol implementation that describes how BIB blocks sh
+ * ould be applied to bundles in the system. This policy is captured as a rule which states when transm
+ * itting a bundle from the given source endpoint ID to the given destination endpoint ID, blocks of ty
+ * pe target should have a BIB added to them using the given ciphersuite and the given key.
+ */
+tnv_t *dtn_bpsec_ctrl_add_bib_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_add_bib_rule BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *src = NULL;
+	char *dst = NULL;
+	uint32_t tgt = 0;
+	char *cs = NULL;
+	char *key = NULL;
+	int success = 0;
+	/* Step 1: Grab the name of the new key. */
+	src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	dst = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	tgt = adm_get_parm_uint(parms, 2, &success);
+	cs = adm_get_parm_obj(parms, 3, AMP_TYPE_STR);
+	key = adm_get_parm_obj(parms, 4, AMP_TYPE_STR);
+
+	if(get_bib_prof_by_name(cs) != NULL)
+	{
+		Object addr;
+		Object elt;
+
+		/* Step 3: Check to see if key exists. */
+		sec_findKey(key, &addr, &elt);
+		if(elt != 0)
+		{
+			/* Step 4: Update the BCB Rule. */
+			if(sec_addBPsecBibRule(src, dst, tgt, cs, key) == 1)
+			{
+				*status = CTRL_SUCCESS;
+			}
+			else
+			{
+				AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bib_rule", "Can't update rule.", NULL);
+			}
+		}
+		else
+		{
+			AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bib_rule", "Key %s doesn't exist.", key);
+		}
+	}
+	else
+	{
+		AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bib_rule", "CIphersuite %s not supported.", cs);
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_add_bib_rule BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * This control removes any configured policy on the BPsec protocol implementation that describes how B
+ * IB blocks should be applied to bundles in the system. A BIB policy is uniquely identified by a sourc
+ * e endpoint Id, a destination Id, and a target block type.
+ */
+tnv_t *dtn_bpsec_ctrl_del_bib_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_del_bib_rule BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *src = NULL;
+	char *dst = NULL;
+	uint32_t tgt = 0;
+	int success = 0;
+	/* Step 1: Grab the name of the new key. */
+	src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	dst = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	tgt = adm_get_parm_uint(parms, 2, &success);
+
+
+	if(sec_removeBPsecBibRule(src, dst, tgt) == 1)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_del_bib_rule BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * This control configures policy on the BPsec protocol implementation that describes how BCB blocks sh
+ * ould be applied to bundles in the system. This policy is captured as a rule which states when transm
+ * itting a bundle from the given source endpoint id to the given destination endpoint id, blocks of ty
+ * pe target should have a bcb added to them using the given ciphersuite and the given key.
+ */
+tnv_t *dtn_bpsec_ctrl_add_bcb_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_add_bcb_rule BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *src = NULL;
+	char *dst = NULL;
+	uint32_t tgt = 0;
+	char *cs = NULL;
+	char *key = NULL;
+	int success = 0;
+
+	/* Step 1: Grab the name of the new key. */
+	src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	dst = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	tgt = adm_get_parm_int(parms, 2, &success);
+	cs = adm_get_parm_obj(parms, 3, AMP_TYPE_STR);
+	key = adm_get_parm_obj(parms, 4, AMP_TYPE_STR);
+
+
+	if(get_bcb_prof_by_name(cs) != NULL)
+	{
+		Object addr;
+		Object elt;
+
+		/* Step 3: Check to see if key exists. */
+		sec_findKey(key, &addr, &elt);
+		if(elt != 0)
+		{
+			/* Step 4: Update the BCB Rule. */
+			if(sec_addBPsecBcbRule(src, dst, tgt, cs, key) == 1)
+			{
+				*status = CTRL_SUCCESS;
+			}
+			else
+			{
+				AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bcbrule", "Can't add rule.", NULL);
+			}
+		}
+		else
+		{
+			AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bcbrule", "Key %s doesn't exist.", key);
+		}
+	}
+	else
+	{
+		AMP_DEBUG_ERR("dtn_bpsec_ctrl_add_bcbrule", "Ciphersuite %s not supported.", cs);
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_add_bcb_rule BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * This control removes any configured policy on the BPsec protocol implementation that describes how B
+ * CB blocks should be applied to bundles in the system. A bcb policy is uniquely identified by a sourc
+ * e endpoint id, a destination endpoint id, and a target block type.
+ */
+tnv_t *dtn_bpsec_ctrl_del_bcb_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_del_bcb_rule BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *src = NULL;
+	char *dst = NULL;
+	uint32_t tgt = 0;
+	int success = 0;
+
+	/* Step 1: Grab the name of the new key. */
+	src = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	dst = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	tgt = adm_get_parm_int(parms, 2, &success);
+
+	if(sec_removeBPsecBcbRule(src, dst, tgt) == 1)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_del_bcb_rule BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+
+/* OP Functions */
diff -ru --new-file ion-sf/bpv7/nm/agent/adm_bpsec_impl.h ion-anms/bpv7/nm/agent/adm_bpsec_impl.h
--- ion-sf/bpv7/nm/agent/adm_bpsec_impl.h	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/agent/adm_bpsec_impl.h	2023-05-15 12:59:40.813869825 -0400
@@ -0,0 +1,156 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bpsec_impl.h
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated header file 
+ **
+ ****************************************************************************/
+
+#ifndef ADM_BPSEC_IMPL_H_
+#define ADM_BPSEC_IMPL_H_
+
+/*   START CUSTOM INCLUDES HERE  */
+#include "adm_bpsec.h"
+//#include "shared/adm/adm_bp.h"
+#include "shared/primitives/expr.h"
+
+#include "library/ext/bpsec/bpsec_instr.h"
+/*   STOP CUSTOM INCLUDES HERE  */
+
+
+#include "shared/utils/utils.h"
+#include "shared/primitives/ctrl.h"
+#include "shared/primitives/table.h"
+#include "shared/primitives/tnv.h"
+
+/*   START typeENUM */
+
+typedef enum
+{
+	TOTAL_BLK,
+	TOTAL_BYTES,
+	SRC_BLK,
+	SRC_BYTES
+} query_type_e;
+
+typedef enum
+{
+    BIB_RULE,
+	BCB_RULE
+} bpsec_rule_type_e;
+
+/*   STOP typeENUM  */
+
+void name_adm_init_agent();
+
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                     Retrieval Functions                                     +
+ * +---------------------------------------------------------------------------------------------+
+ */
+/*   START CUSTOM FUNCTIONS HERE */
+/*   STOP CUSTOM FUNCTIONS HERE  */
+
+void dtn_bpsec_setup();
+void dtn_bpsec_cleanup();
+
+
+/* Metadata Functions */
+tnv_t *dtn_bpsec_meta_name(tnvc_t *parms);
+tnv_t *dtn_bpsec_meta_namespace(tnvc_t *parms);
+tnv_t *dtn_bpsec_meta_version(tnvc_t *parms);
+tnv_t *dtn_bpsec_meta_organization(tnvc_t *parms);
+
+/* Constant Functions */
+
+/* Collect Functions */
+tnv_t *dtn_bpsec_get_num_good_tx_bcb_blk(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blk(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_rx_bcb_blk(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_rx_bcb_blk(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_missing_rx_bcb_blks(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_fwd_bcb_blks(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_tx_bcb_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blks(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_rx_bcb_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_rx_bcb_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_missing_rx_bcb_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_fwd_bcb_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_tx_bib_blks(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_tx_bib_blks(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_rx_bib_blks(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_rx_bib_blks(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_miss_rx_bib_blks(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_fwd_bib_blks(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_tx_bib_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_tx_bib_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_rx_bib_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_rx_bib_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_miss_rx_bib_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_fwd_bib_bytes(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_last_update(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_known_keys(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_key_names(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_ciphersuite_names(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_rule_source(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_tx_bcb_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_rx_bcb_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_rx_bcb_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_missing_rx_bcb_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_fwd_bcb_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_tx_bcb_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_tx_bcb_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_rx_bcb_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_rx_bcb_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_missing_rx_bcb_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_fwd_bcb_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_tx_bib_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_tx_bib_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_rx_bib_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_rx_bib_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_miss_rx_bib_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_fwd_bib_blks_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_tx_bib_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_tx_bib_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_good_rx_bib_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_bad_rx_bib_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_missing_rx_bib_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_num_fwd_bib_bytes_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_last_update_src(tnvc_t *parms);
+tnv_t *dtn_bpsec_get_last_reset(tnvc_t *parms);
+
+
+/* Control Functions */
+tnv_t *dtn_bpsec_ctrl_rst_all_cnts(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_bpsec_ctrl_rst_src_cnts(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_bpsec_ctrl_delete_key(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_bpsec_ctrl_add_key(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_bpsec_ctrl_add_bib_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_bpsec_ctrl_del_bib_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_bpsec_ctrl_add_bcb_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_bpsec_ctrl_del_bcb_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+
+
+/* OP Functions */
+
+
+/* Table Build Functions */
+tbl_t *dtn_bpsec_tblt_keys(ari_t *id);
+tbl_t *dtn_bpsec_tblt_ciphersuites(ari_t *id);
+tbl_t *dtn_bpsec_tblt_bib_rules(ari_t *id);
+tbl_t *dtn_bpsec_tblt_bcb_rules(ari_t *id);
+
+#endif //ADM_BPSEC_IMPL_H_
diff -ru --new-file ion-sf/bpv7/nm/agent/adm_ion_bp_admin_agent.c ion-anms/bpv7/nm/agent/adm_ion_bp_admin_agent.c
--- ion-sf/bpv7/nm/agent/adm_ion_bp_admin_agent.c	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/agent/adm_ion_bp_admin_agent.c	2023-05-15 12:59:40.825869936 -0400
@@ -0,0 +1,198 @@
+/****************************************************************************
+ **
+ ** File Name: adm_ion_bp_admin_agent.c
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History:
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2023-04-12  AUTO             Auto-generated c file
+ **
+ ****************************************************************************/
+
+
+#include "ion.h"
+#include "platform.h"
+#include "adm_ion_bp_admin.h"
+#include "shared/utils/utils.h"
+#include "shared/primitives/report.h"
+#include "shared/primitives/blob.h"
+#include "adm_ion_bp_admin_impl.h"
+#include "agent/rda.h"
+
+vec_idx_t g_dtn_ion_bpadmin_idx[11];
+
+static void dtn_ion_bpadmin_init_meta(void);
+static void dtn_ion_bpadmin_init_cnst(void);
+static void dtn_ion_bpadmin_init_edd(void);
+static void dtn_ion_bpadmin_init_op(void);
+static void dtn_ion_bpadmin_init_var(void);
+static void dtn_ion_bpadmin_init_ctrl(void);
+static void dtn_ion_bpadmin_init_mac(void);
+static void dtn_ion_bpadmin_init_rpttpl(void);
+static void dtn_ion_bpadmin_init_tblt(void);
+
+void dtn_ion_bpadmin_init()
+{
+	adm_add_adm_info("dtn_ion_bpadmin", ADM_ENUM_DTN_ION_BPADMIN);
+
+	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_bpadmin_idx[ADM_META_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_bpadmin_idx[ADM_EDD_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX]));
+
+
+	dtn_ion_bpadmin_setup();
+	dtn_ion_bpadmin_init_meta();
+	dtn_ion_bpadmin_init_cnst();
+	dtn_ion_bpadmin_init_edd();
+	dtn_ion_bpadmin_init_op();
+	dtn_ion_bpadmin_init_var();
+	dtn_ion_bpadmin_init_ctrl();
+	dtn_ion_bpadmin_init_mac();
+	dtn_ion_bpadmin_init_rpttpl();
+	dtn_ion_bpadmin_init_tblt();
+}
+
+void dtn_ion_bpadmin_init_meta()
+{
+
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_NAME), dtn_ion_bpadmin_meta_name);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_ENUM), dtn_ion_bpadmin_meta_enum);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_NAMESPACE), dtn_ion_bpadmin_meta_namespace);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_VERSION), dtn_ion_bpadmin_meta_version);
+	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_ORGANIZATION), dtn_ion_bpadmin_meta_organization);
+}
+
+void dtn_ion_bpadmin_init_cnst()
+{
+
+}
+
+void dtn_ion_bpadmin_init_edd()
+{
+
+	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_bpadmin_idx[ADM_EDD_IDX], DTN_ION_BPADMIN_EDD_BP_VERSION), dtn_ion_bpadmin_get_bp_version);
+}
+
+void dtn_ion_bpadmin_init_op()
+{
+
+}
+
+void dtn_ion_bpadmin_init_var()
+{
+
+}
+
+void dtn_ion_bpadmin_init_ctrl()
+{
+
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_ADD, 3, dtn_ion_bpadmin_ctrl_endpoint_add);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_CHANGE, 3, dtn_ion_bpadmin_ctrl_endpoint_change);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_DEL, 1, dtn_ion_bpadmin_ctrl_endpoint_del);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_ADD, 3, dtn_ion_bpadmin_ctrl_induct_add);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_CHANGE, 3, dtn_ion_bpadmin_ctrl_induct_change);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_DEL, 2, dtn_ion_bpadmin_ctrl_induct_del);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_START, 2, dtn_ion_bpadmin_ctrl_induct_start);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_STOP, 2, dtn_ion_bpadmin_ctrl_induct_stop);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_MANAGE_HEAP_MAX, 1, dtn_ion_bpadmin_ctrl_manage_heap_max);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_ADD, 4, dtn_ion_bpadmin_ctrl_outduct_add);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_CHANGE, 4, dtn_ion_bpadmin_ctrl_outduct_change);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_DEL, 2, dtn_ion_bpadmin_ctrl_outduct_del);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_START, 2, dtn_ion_bpadmin_ctrl_outduct_start);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_STOP, 2, dtn_ion_bpadmin_ctrl_outduct_stop);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_ADD, 3, dtn_ion_bpadmin_ctrl_egress_plan_add);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_DEL, 2, dtn_ion_bpadmin_ctrl_egress_plan_del);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_START, 2, dtn_ion_bpadmin_ctrl_egress_plan_start);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_STOP, 2, dtn_ion_bpadmin_ctrl_egress_plan_stop);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_BLOCK, 1, dtn_ion_bpadmin_ctrl_egress_plan_block);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_UNBLOCK, 1, dtn_ion_bpadmin_ctrl_egress_plan_unblock);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_ADD, 4, dtn_ion_bpadmin_ctrl_protocol_add);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_DEL, 1, dtn_ion_bpadmin_ctrl_protocol_del);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_START, 1, dtn_ion_bpadmin_ctrl_protocol_start);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_STOP, 1, dtn_ion_bpadmin_ctrl_protocol_stop);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_ADD, 3, dtn_ion_bpadmin_ctrl_scheme_add);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_CHANGE, 3, dtn_ion_bpadmin_ctrl_scheme_change);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_DEL, 1, dtn_ion_bpadmin_ctrl_scheme_del);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_START, 1, dtn_ion_bpadmin_ctrl_scheme_start);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_STOP, 1, dtn_ion_bpadmin_ctrl_scheme_stop);
+	adm_add_ctrldef(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_WATCH, 2, dtn_ion_bpadmin_ctrl_watch);
+}
+
+void dtn_ion_bpadmin_init_mac()
+{
+
+}
+
+void dtn_ion_bpadmin_init_rpttpl()
+{
+
+}
+
+void dtn_ion_bpadmin_init_tblt()
+{
+
+	tblt_t *def = NULL;
+
+	/* ENDPOINTS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_ENDPOINTS), dtn_ion_bpadmin_tblt_endpoints);
+	tblt_add_col(def, AMP_TYPE_STR, "scheme_name");
+	tblt_add_col(def, AMP_TYPE_STR, "endpoint_nss");
+	tblt_add_col(def, AMP_TYPE_UINT, "app_pid");
+	tblt_add_col(def, AMP_TYPE_STR, "recv_rule");
+	tblt_add_col(def, AMP_TYPE_STR, "rcv_script");
+	adm_add_tblt(def);
+
+	/* INDUCTS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_INDUCTS), dtn_ion_bpadmin_tblt_inducts);
+	tblt_add_col(def, AMP_TYPE_STR, "protocol_name");
+	tblt_add_col(def, AMP_TYPE_STR, "duct_name");
+	tblt_add_col(def, AMP_TYPE_STR, "cli_control");
+	adm_add_tblt(def);
+
+	/* OUTDUCTS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_OUTDUCTS), dtn_ion_bpadmin_tblt_outducts);
+	tblt_add_col(def, AMP_TYPE_STR, "protocol_name");
+	tblt_add_col(def, AMP_TYPE_STR, "duct_name");
+	tblt_add_col(def, AMP_TYPE_UINT, "clo_pid");
+	tblt_add_col(def, AMP_TYPE_STR, "clo_control");
+	tblt_add_col(def, AMP_TYPE_UINT, "max_payload_length");
+	adm_add_tblt(def);
+
+	/* PROTOCOLS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_PROTOCOLS), dtn_ion_bpadmin_tblt_protocols);
+	tblt_add_col(def, AMP_TYPE_STR, "name");
+	tblt_add_col(def, AMP_TYPE_UINT, "payload_bpf");
+	tblt_add_col(def, AMP_TYPE_UINT, "overhead_bpf");
+	tblt_add_col(def, AMP_TYPE_UINT, "protocol class");
+	adm_add_tblt(def);
+
+	/* SCHEMES */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_SCHEMES), dtn_ion_bpadmin_tblt_schemes);
+	tblt_add_col(def, AMP_TYPE_STR, "scheme_name");
+	tblt_add_col(def, AMP_TYPE_UINT, "fwd_pid");
+	tblt_add_col(def, AMP_TYPE_STR, "fwd_cmd");
+	tblt_add_col(def, AMP_TYPE_UINT, "admin_app_pid");
+	tblt_add_col(def, AMP_TYPE_STR, "admin_app_cmd");
+	adm_add_tblt(def);
+
+	/* EGRESS_PLANS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_EGRESS_PLANS), dtn_ion_bpadmin_tblt_egress_plans);
+	tblt_add_col(def, AMP_TYPE_STR, "neighbor_eid");
+	tblt_add_col(def, AMP_TYPE_UINT, "clm_pid");
+	tblt_add_col(def, AMP_TYPE_UINT, "nominal_rate");
+	adm_add_tblt(def);
+}
+
diff -ru --new-file ion-sf/bpv7/nm/agent/adm_ion_bp_admin_impl.c ion-anms/bpv7/nm/agent/adm_ion_bp_admin_impl.c
--- ion-sf/bpv7/nm/agent/adm_ion_bp_admin_impl.c	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/agent/adm_ion_bp_admin_impl.c	2023-05-15 12:59:40.833870011 -0400
@@ -0,0 +1,1618 @@
+/****************************************************************************
+ **
+ ** File Name: adm_ion_bp_admin_impl.c
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History:
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2023-04-12  AUTO             Auto-generated c file
+ **
+ ****************************************************************************/
+
+/*   START CUSTOM INCLUDES HERE  */
+#include "bpP.h"
+#include "csi.h"
+
+/*   STOP CUSTOM INCLUDES HERE  */
+
+
+#include "shared/adm/adm.h"
+#include "adm_ion_bp_admin_impl.h"
+
+/*   START CUSTOM FUNCTIONS HERE */
+/*             TODO              */
+/*   STOP CUSTOM FUNCTIONS HERE  */
+
+void dtn_ion_bpadmin_setup()
+{
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION setup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION setup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+}
+
+void dtn_ion_bpadmin_cleanup()
+{
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION cleanup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION cleanup BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+}
+
+
+/* Metadata Functions */
+
+
+tnv_t *dtn_ion_bpadmin_meta_name(tnvc_t *parms)
+{
+	return tnv_from_str("ion_bp_admin");
+}
+
+
+tnv_t *dtn_ion_bpadmin_meta_enum(tnvc_t *parms)
+{
+	return tnv_from_str("5");
+}
+
+
+tnv_t *dtn_ion_bpadmin_meta_namespace(tnvc_t *parms)
+{
+	return tnv_from_str("DTN/ION/bpadmin");
+}
+
+
+tnv_t *dtn_ion_bpadmin_meta_version(tnvc_t *parms)
+{
+	return tnv_from_str("v0.0");
+}
+
+
+tnv_t *dtn_ion_bpadmin_meta_organization(tnvc_t *parms)
+{
+	return tnv_from_str("JHUAPL");
+}
+
+
+/* Constant Functions */
+/* Table Functions */
+
+
+/*
+ * Local endpoints, regardless of scheme name.
+ */
+tbl_t *dtn_ion_bpadmin_tblt_endpoints(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_endpoints BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	Sdr		sdr = getIonsdr();
+	PsmPartition	ionwm = getIonwm();
+	VScheme		*vscheme;
+	VEndpoint	*vpoint;
+	PsmAddress	scheme_elt;
+	PsmAddress  vpoint_elt;
+	char	recvRule;
+	char	recvScriptBuffer[SDRSTRING_BUFSZ];
+	char	*recvScript = recvScriptBuffer;
+	tnvc_t  *cur_row = NULL;
+
+	OBJ_POINTER(Endpoint, endpoint);
+	OBJ_POINTER(Scheme, scheme);
+
+	CHKNULL(sdr_begin_xn(sdr));
+	for (scheme_elt = sm_list_first(ionwm, (getBpVdb())->schemes); scheme_elt; scheme_elt = sm_list_next(ionwm, scheme_elt))
+	{
+		vscheme = (VScheme *) psp(ionwm, sm_list_data(ionwm, scheme_elt));
+
+		for (vpoint_elt = sm_list_first(ionwm, vscheme->endpoints); vpoint_elt; vpoint_elt = sm_list_next(ionwm, vpoint_elt))
+		{
+			vpoint = (VEndpoint *) psp(ionwm, sm_list_data(ionwm, vpoint_elt));
+
+			GET_OBJ_POINTER(sdr, Endpoint, endpoint, sdr_list_data(sdr, vpoint->endpointElt));
+			GET_OBJ_POINTER(sdr, Scheme, scheme, endpoint->scheme);
+
+			recvRule = (endpoint->recvRule == EnqueueBundle) ? 'q' : 'x';
+
+			if (endpoint->recvScript == 0)
+			{
+				recvScriptBuffer[0] = '\0';
+			}
+			else
+			{
+				if (sdr_string_read(sdr, recvScriptBuffer, endpoint->recvScript)
+					       	< 0)
+				{
+					recvScript = "?";
+				}
+			}
+
+			/* (STR) scheme_name, (STR) endpoint_nss, (UINT) app_pid, (STR) recv_rule, (STR) rcv_script */
+
+			if((cur_row = tnvc_create(5)) != NULL)
+			{
+				char tmp[2];
+				tmp[0] = recvRule;
+				tmp[1] = 0;
+				tnvc_insert(cur_row, tnv_from_str(scheme->name));
+				tnvc_insert(cur_row, tnv_from_str(endpoint->nss));
+				tnvc_insert(cur_row, tnv_from_uint(vpoint->appPid));
+				tnvc_insert(cur_row, tnv_from_str(tmp));
+				tnvc_insert(cur_row, tnv_from_str(recvScript));
+
+				tbl_add_row(table, cur_row);
+			}
+			else
+			{
+				AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_endpoints", "Can't allocate row. Skipping.", NULL);
+			}
+		}
+	}
+
+	sdr_exit_xn(sdr);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_endpoints BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/*
+ * Inducts established locally for the indicated CL protocol.
+ */
+tbl_t *dtn_ion_bpadmin_tblt_inducts(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_inducts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	Sdr		sdr = getIonsdr();
+	PsmPartition	ionwm = getIonwm();
+	ClProtocol	clpbuf;
+	Object		clp_elt;
+	VInduct		*vduct;
+	PsmAddress	vduct_elt;
+	OBJ_POINTER(Induct, duct);
+	OBJ_POINTER(ClProtocol, clp);
+	char	cliCmdBuffer[SDRSTRING_BUFSZ];
+	char	*cliCmd;
+	tnvc_t  *cur_row = NULL;
+
+
+	CHKNULL(sdr_begin_xn(sdr));
+	for (clp_elt = sdr_list_first(sdr, (getBpConstants())->protocols);
+			clp_elt; clp_elt = sdr_list_next(sdr, clp_elt))
+	{
+		sdr_read(sdr, (char *) &clpbuf, sdr_list_data(sdr, clp_elt), sizeof(ClProtocol));
+
+		for (vduct_elt = sm_list_first(ionwm, (getBpVdb())->inducts); vduct_elt;
+				vduct_elt = sm_list_next(ionwm, vduct_elt))
+		{
+			vduct = (VInduct *) psp(ionwm, sm_list_data(ionwm, vduct_elt));
+
+			if (strcmp(vduct->protocolName, clpbuf.name) == 0)
+			{
+				GET_OBJ_POINTER(sdr, Induct, duct, sdr_list_data(sdr, vduct->inductElt));
+				GET_OBJ_POINTER(sdr, ClProtocol, clp, duct->protocol);
+				if (sdr_string_read(sdr, cliCmdBuffer, duct->cliCmd) < 0)
+				{
+					cliCmd = "?";
+				}
+				else
+				{
+					cliCmd = cliCmdBuffer;
+				}
+
+				/* (STR) protocol_name, (STR) duct_name, (STR) cli_control */
+				if((cur_row = tnvc_create(3)) != NULL)
+				{
+					tnvc_insert(cur_row, tnv_from_str(clp->name));
+					tnvc_insert(cur_row, tnv_from_str(duct->name));
+					tnvc_insert(cur_row, tnv_from_str(cliCmd));
+
+					tbl_add_row(table, cur_row);
+				}
+				else
+				{
+					AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_inducts", "Can't allocate row. Skipping.", NULL);
+				}
+
+			}
+		}
+	}
+
+	sdr_exit_xn(sdr);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_inducts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/*
+ * If protocolName is specified, this table lists all outducts established locally for the indicated CL
+ *  protocol. Otherwise, it lists all locally established outducts, regardless of their protocol.
+ */
+tbl_t *dtn_ion_bpadmin_tblt_outducts(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_outducts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	Sdr		sdr = getIonsdr();
+	PsmPartition	ionwm = getIonwm();
+	ClProtocol	clpbuf;
+	Object		clp_elt;
+	VOutduct	*vduct;
+	PsmAddress	vduct_elt;
+	OBJ_POINTER(Outduct, duct);
+	OBJ_POINTER(ClProtocol, clp);
+	char	cloCmdBuffer[SDRSTRING_BUFSZ];
+	char	*cloCmd;
+	tnvc_t  *cur_row = NULL;
+
+
+	CHKNULL(sdr_begin_xn(sdr));
+	for (clp_elt = sdr_list_first(sdr, (getBpConstants())->protocols);
+			clp_elt; clp_elt = sdr_list_next(sdr, clp_elt))
+	{
+		sdr_read(sdr, (char *) &clpbuf, sdr_list_data(sdr, clp_elt), sizeof(ClProtocol));
+
+		for (vduct_elt = sm_list_first(ionwm, (getBpVdb())->outducts); vduct_elt;
+				vduct_elt = sm_list_next(ionwm, vduct_elt))
+		{
+			vduct = (VOutduct *) psp(ionwm, sm_list_data(ionwm, vduct_elt));
+
+			if (strcmp(vduct->protocolName, clpbuf.name) == 0)
+			{
+				GET_OBJ_POINTER(sdr, Outduct, duct, sdr_list_data(sdr, vduct->outductElt));
+				GET_OBJ_POINTER(sdr, ClProtocol, clp, duct->protocol);
+
+				if (duct->cloCmd == 0)
+				{
+					cloCmd = "?";
+				}
+				else if (sdr_string_read(sdr, cloCmdBuffer, duct->cloCmd) < 0)
+				{
+					cloCmd = "?";
+				}
+				else
+				{
+					cloCmd = cloCmdBuffer;
+				}
+
+				/* (STR) protocol_name, (STR) duct_name, (UINT) clo_pid, (STR) clo_control, (STR) max_ayload_len */
+				if((cur_row = tnvc_create(5)) != NULL)
+				{
+					tnvc_insert(cur_row, tnv_from_str(clp->name));
+					tnvc_insert(cur_row, tnv_from_str(duct->name));
+					tnvc_insert(cur_row, tnv_from_uint(vduct->cloPid));
+					tnvc_insert(cur_row, tnv_from_str(cloCmd));
+					tnvc_insert(cur_row, tnv_from_uint(duct->maxPayloadLen));
+
+					tbl_add_row(table, cur_row);
+				}
+				else
+				{
+					AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_outducts", "Can't allocate row. Skipping.", NULL);
+				}
+
+			}
+		}
+	}
+
+	sdr_exit_xn(sdr);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_outducts BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/*
+ * Convergence layer protocols that can currently be utilized at the local node.
+ */
+tbl_t *dtn_ion_bpadmin_tblt_protocols(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_protocols BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	Sdr	sdr = getIonsdr();
+	Object	elt;
+	OBJ_POINTER(ClProtocol, clp);
+	tnvc_t  *cur_row = NULL;
+
+	CHKNULL(sdr_begin_xn(sdr));
+	for (elt = sdr_list_first(sdr, (getBpConstants())->protocols); elt;
+			elt = sdr_list_next(sdr, elt))
+	{
+		GET_OBJ_POINTER(sdr, ClProtocol, clp, sdr_list_data(sdr, elt));
+
+		/* (STR) name, (UINT) protocol_class */
+		if((cur_row = tnvc_create(2)) != NULL)
+		{
+			tnvc_insert(cur_row, tnv_from_str(clp->name));
+			tnvc_insert(cur_row, tnv_from_uint(clp->protocolClass));
+
+			tbl_add_row(table, cur_row);
+		}
+		else
+		{
+			AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_protocols", "Can't allocate row. Skipping.", NULL);
+		}
+	}
+
+	sdr_exit_xn(sdr);
+
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_protocols BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/*
+ * Declared endpoint naming schemes.
+ */
+tbl_t *dtn_ion_bpadmin_tblt_schemes(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_schemes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	Sdr		sdr = getIonsdr();
+	PsmPartition	ionwm = getIonwm();
+	PsmAddress	elt;
+	VScheme		*vscheme;
+	OBJ_POINTER(Scheme, scheme);
+	char	fwdCmdBuffer[SDRSTRING_BUFSZ];
+	char	*fwdCmd;
+	char	admAppCmdBuffer[SDRSTRING_BUFSZ];
+	char	*admAppCmd;
+	tnvc_t  *cur_row = NULL;
+
+	CHKNULL(sdr_begin_xn(sdr));
+	for (elt = sm_list_first(ionwm, (getBpVdb())->schemes); elt;
+			elt = sm_list_next(ionwm, elt))
+	{
+		vscheme = (VScheme *) psp(ionwm, sm_list_data(ionwm, elt));
+
+		GET_OBJ_POINTER(sdr, Scheme, scheme, sdr_list_data(sdr, vscheme->schemeElt));
+		if (sdr_string_read(sdr, fwdCmdBuffer, scheme->fwdCmd) < 0)
+		{
+			fwdCmd = "?";
+		}
+		else
+		{
+			fwdCmd = fwdCmdBuffer;
+		}
+
+		if (sdr_string_read(sdr, admAppCmdBuffer, scheme->admAppCmd) < 0)
+		{
+			admAppCmd = "?";
+		}
+		else
+		{
+			admAppCmd = admAppCmdBuffer;
+		}
+
+		/* (STR) name, (UINT) fwd_pid, (STR) fwd_cmd, (UINT) admin_app_pid (STR) admin_app_cmd */
+		if((cur_row = tnvc_create(5)) != NULL)
+		{
+			tnvc_insert(cur_row, tnv_from_str(scheme->name));
+			tnvc_insert(cur_row, tnv_from_uint(vscheme->fwdPid));
+			tnvc_insert(cur_row, tnv_from_str(fwdCmd));
+			tnvc_insert(cur_row, tnv_from_uint(vscheme->admAppPid));
+			tnvc_insert(cur_row, tnv_from_str(admAppCmd));
+
+			tbl_add_row(table, cur_row);
+		}
+		else
+		{
+			AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_schemess", "Can't allocate row. Skipping.", NULL);
+		}
+	}
+
+	sdr_exit_xn(sdr);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_schemes BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/*
+ * Egress plans.
+ */
+tbl_t *dtn_ion_bpadmin_tblt_egress_plans(ari_t *id)
+{
+	tbl_t *table = NULL;
+	if((table = tbl_create(id)) == NULL)
+	{
+		return NULL;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION tblt_egress_plans BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	Sdr		sdr = getIonsdr();
+	PsmPartition	ionwm = getIonwm();
+	PsmAddress	elt;
+	VPlan		*vplan;
+	OBJ_POINTER(BpPlan, plan);
+	tnvc_t  *cur_row = NULL;
+
+
+	CHKNULL(sdr_begin_xn(sdr));
+	for (elt = sm_list_first(ionwm, (getBpVdb())->plans); elt;
+			elt = sm_list_next(ionwm, elt))
+	{
+		vplan = (VPlan *) psp(ionwm, sm_list_data(ionwm, elt));
+		GET_OBJ_POINTER(sdr, BpPlan, plan, sdr_list_data(sdr, vplan->planElt));
+
+		/* (STR) neighbor EID, (UINT) clm_pid, (UINT) nominal rate*/
+		if((cur_row = tnvc_create(3)) != NULL)
+		{
+			tnvc_insert(cur_row, tnv_from_str(plan->neighborEid));
+			tnvc_insert(cur_row, tnv_from_uint(vplan->clmPid));
+			tnvc_insert(cur_row, tnv_from_uint(plan->nominalRate));
+
+			tbl_add_row(table, cur_row);
+		}
+		else
+		{
+			AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_egress_plans", "Can't allocate row. Skipping.", NULL);
+		}
+	}
+
+	sdr_exit_xn(sdr);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION tblt_egress_plans BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return table;
+}
+
+
+/* Collect Functions */
+/*
+ * Version of installed ION BP Admin utility.
+ */
+tnv_t *dtn_ion_bpadmin_get_bp_version(tnvc_t *parms)
+{
+	tnv_t *result = NULL;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION get_bp_version BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char buffer[80];
+	isprintf(buffer, sizeof buffer,
+			"%s compiled with crypto suite: %s",
+			IONVERSIONNUMBER, CSI_SUITE_NAME);
+	result = tnv_from_str(buffer);
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION get_bp_version BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+
+/* Control Functions */
+
+/*
+ * Establish DTN endpoint named endpointId on the local node. The remaining parameters indicate what is
+ *  to be done when bundles destined for this endpoint arrive at a time when no application has the end
+ * point open for bundle reception. If type is 'x', then such bundles are to be discarded silently and 
+ * immediately. If type is 'q', then such bundles are to be enqueued for later delivery and, if recvScr
+ * ipt is provided, recvScript is to be executed.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_endpoint_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_endpoint_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	int success;
+	BpRecvRule	rule;
+
+	char *id = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+    uint32_t type = adm_get_parm_uint(parms, 1, &success);
+    char *rcv = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
+
+    rule = (type == 'q') ? EnqueueBundle : DiscardBundle;
+
+	if(addEndpoint(id, rule, rcv) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_endpoint_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Change the action taken when bundles destined for this endpoint arrive at a time when no application
+ *  has the endpoint open for bundle reception.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_endpoint_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_endpoint_change BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	int success;
+	BpRecvRule	rule;
+
+	char *id = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+    uint32_t type = adm_get_parm_uint(parms, 1, &success);
+    char *rcv = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
+
+    rule = (type == 'q') ? EnqueueBundle : DiscardBundle;
+
+	if(updateEndpoint(id, rule, rcv) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_endpoint_change BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Delete the endpoint identified by endpointId. The control will fail if any bundles are currently pen
+ * ding delivery to this endpoint.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_endpoint_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_endpoint_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *id = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	if(removeEndpoint(id) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_endpoint_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Establish a duct for reception of bundles via the indicated CL protocol. The duct's data acquisition
+ *  structure is used and populated by the induct task whose operation is initiated by cliControl at th
+ * e time the duct is started.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_induct_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_induct_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	char *cli_ctrl = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
+
+	if(addInduct(p_name, d_name, cli_ctrl) > 1)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_induct_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Change the control used to initiate operation of the induct task for the indicated duct.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_induct_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_induct_change BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	char *cli_ctrl = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
+
+	if(updateInduct(p_name, d_name, cli_ctrl) > 1)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_induct_change BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Delete the induct identified by protocolName and ductName. The control will fail if any bundles are 
+ * currently pending acquisition via this induct.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_induct_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_induct_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+
+	if(removeInduct(p_name, d_name) > 1)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_induct_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Start the indicated induct task as defined for the indicated CL protocol on the local node.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_induct_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_induct_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+
+	if(bpStartInduct(p_name, d_name) > 1)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_induct_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Stop the indicated induct task as defined for the indicated CL protocol on the local node.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_induct_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_induct_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+
+	bpStopInduct(p_name, d_name);
+	*status = CTRL_SUCCESS;
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_induct_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Declare the maximum number of bytes of SDR heap space that will be occupied by any single bundle acq
+ * uisition activity (nominally the acquisition of a single bundle, but this is at the discretion of th
+ * e convergence-layer input task). All data acquired in excess of this limit will be written to a temp
+ * orary file pending extraction and dispatching of the acquired bundle or bundles. The default is the 
+ * minimum allowed value (560 bytes), which is the approximate size of a ZCO file reference object; thi
+ * s is the minimum SDR heap space occupancy in the event that all acquisition is into a file.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_manage_heap_max(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_manage_heap_max BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	Sdr		sdr = getIonsdr();
+	Object		bpdbObj = getBpDbObject();
+	BpDB		bpdb;
+	int success;
+	unsigned int heapmax = adm_get_parm_uint(parms, 0, &success);
+
+	if (heapmax < 560)
+	{
+		AMP_DEBUG_WARN("dtn_ion_bpadmin_ctrl_manage_heap_max", "heapmax (%lu) must be at least 560.", heapmax);
+		return NULL;
+	}
+
+	CHKNULL(sdr_begin_xn(sdr));
+	sdr_stage(sdr, (char *) &bpdb, bpdbObj, sizeof(BpDB));
+	bpdb.maxAcqInHeap = heapmax;
+	sdr_write(sdr, bpdbObj, (char *) &bpdb, sizeof(BpDB));
+	if (sdr_end_xn(sdr) < 0)
+	{
+		AMP_DEBUG_ERR("dtn_ion_bpadmin_ctrl_manage_heap_max", "Can't change maxAcqInHeap.", NULL);
+	}
+	else
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_manage_heap_max BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Establish a duct for transmission of bundles via the indicated CL protocol. the duct's data transmis
+ * sion structure is serviced by the outduct task whose operation is initiated by CLOcommand at the tim
+ * e the duct is started. A value of zero for maxPayloadLength indicates that bundles of any size can b
+ * e accomodated; this is the default.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_outduct_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	int success;
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	char *clo_cmd = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
+	unsigned int max_len = adm_get_parm_uint(parms, 3, &success);
+
+	if(addOutduct(p_name, d_name, clo_cmd, max_len) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_outduct_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Set new values for the indicated duct's payload size limit and the control that is used to initiate 
+ * operation of the outduct task for this duct.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_outduct_change BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	int success;
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	char *clo_cmd = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
+	unsigned int max_len = adm_get_parm_uint(parms, 3, &success);
+
+	if(updateOutduct(p_name, d_name, clo_cmd, max_len) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_outduct_change BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Delete the outduct identified by protocolName and ductName. The control will fail if any bundles are
+ *  currently pending transmission via this outduct.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_outduct_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+
+	if(removeOutduct(p_name, d_name) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_outduct_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Start the indicated outduct task as defined for the indicated CL protocol on the local node.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_outduct_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+
+	if(bpStartOutduct(p_name, d_name) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_outduct_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Stop the indicated outduct task as defined for the indicated CL protocol on the local node.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_outduct_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *p_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *d_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+
+	bpStopOutduct(p_name, d_name);
+	*status = CTRL_SUCCESS;
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_outduct_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Add an egress plan for a specific peer and outduct.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_egress_plan_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *neighbor_eid = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *protocol_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	char *duct_name = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
+
+	unsigned int xmitRate = 0;
+	if (addPlan(neighbor_eid, xmitRate) <= 0)
+	{
+		return result;
+	}
+
+	VOutduct	*vduct;
+	PsmAddress	vductElt;
+	findOutduct(protocol_name, duct_name, &vduct, &vductElt);
+	if (vductElt == 0)
+	{
+		return result;
+	}
+	attachPlanDuct(neighbor_eid, vduct->outductElt);
+
+	*status = CTRL_SUCCESS;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_egress_plan_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Remove an egress plan for a specific peer and outduct.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_egress_plan_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *neighbor_eid = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *duct_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+
+	VOutduct	*vduct;
+	PsmAddress	vductElt;
+	findOutduct(neighbor_eid, duct_name, &vduct, &vductElt);
+	if (vductElt == 0)
+	{
+		return result;
+	}
+	detachPlanDuct(vduct->outductElt);
+
+	removePlan(neighbor_eid);
+
+	*status = CTRL_SUCCESS;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_egress_plan_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Start the indicated egress plan task.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_egress_plan_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	if(bpStartPlan(name) >= 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_egress_plan_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Stop the indicated egress plan task.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_egress_plan_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	bpStopPlan(name);
+	*status = CTRL_SUCCESS;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_egress_plan_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Disable transmission of bundles queued for transmission to the indicated node and reforwards all non
+ * -critical bundles currently queued for transmission to this node. This may result in some or all of 
+ * these bundles being enqueued for transmission to the psuedo-node limbo.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_block(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_egress_plan_block BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	if(bpBlockPlan(name) >= 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_egress_plan_block BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Re-enable transmission of bundles to the indicated node and reforwards all bundles in limbo in the h
+ * ope that the unblocking of this egress plan will enable some of them to be transmitted.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_unblock(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_egress_plan_unblock BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	if(bpUnblockPlan(name) >= 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_egress_plan_unblock BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Establish access to the named convergence layer protocol at the local node. The payloadBytesPerFrame
+ *  and overheadBytesPerFrame arguments are used in calculating the estimated transmission capacity con
+ * sumption of each bundle, to aid in route computation and congesting forecasting. The optional nomina
+ * lDataRate argument overrides the hard coded default continuous data rate for the indicated protocol 
+ * for purposes of rate control. For all promiscuous prototocols-that is, protocols whose outducts are 
+ * not specifically dedicated to transmission to a single identified convergence-layer protocol endpoin
+ * t- the protocol's applicable nominal continuous data rate is the data rate that is always used for r
+ * ate control over links served by that protocol; data rates are not extracted from contact graph info
+ * rmation. This is because only the induct and outduct throttles for non-promiscuous protocols (LTP, T
+ * CP) can be dynamically adjusted in response to changes in data rate between the local node and its n
+ * eighbors, as enacted per the contact plan. Even for an outduct of a non-promiscuous protocol the nom
+ * inal data rate may be the authority for rate control, in the event that the contact plan lacks ident
+ * ified contacts with the node to which the outduct is mapped.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_protocol_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_protocol_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	int success;
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	int protocolClass = adm_get_parm_uint(parms, 1, &success);
+
+	if(addProtocol(name, protocolClass) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_protocol_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Delete the convergence layer protocol identified by protocolName. The control will fail if any ducts
+ *  are still locally declared for this protocol.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_protocol_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_protocol_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	if(removeProtocol(name) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_protocol_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Start all induct and outduct tasks for inducts and outducts that have been defined for the indicated
+ *  CL protocol on the local node.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_protocol_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_protocol_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	if(bpStartProtocol(name) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_protocol_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Stop all induct and outduct tasks for inducts and outducts that have been defined for the indicated 
+ * CL protocol on the local node.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_protocol_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_protocol_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	bpStopProtocol(name);
+	*status = CTRL_SUCCESS;
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_protocol_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Declares an endpoint naming scheme for use in endpoint IDs, which are structured as URIs: schemeName
+ * :schemeSpecificPart. forwarderControl will be executed when the scheme is started on this node, to i
+ * nitiate operation of a forwarding daemon for this scheme. adminAppControl will also be executed when
+ *  the scheme is started on this node, to initiate operation of a daemon that opens a custodian endpoi
+ * nt identified within this scheme so that it can recieve and process custody signals and bundle statu
+ * s reports.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_scheme_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *fwd_ctrl = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	char *adm_app_ctrl = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
+
+	if(addScheme(name, fwd_ctrl, adm_app_ctrl) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_scheme_add BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Set the indicated scheme's forwarderControl and adminAppControl to the strings provided as arguments
+ * .
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_scheme_change BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	char *fwd_ctrl = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
+	char *adm_app_ctrl = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
+
+	if(updateScheme(name, fwd_ctrl, adm_app_ctrl) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_scheme_change BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Delete the scheme identified by schemeName. The control will fail if any bundles identified in this 
+ * scheme are pending forwarding, transmission, or delivery.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_scheme_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	if(removeScheme(name) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_scheme_del BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Start the forwarder and administrative endpoint tasks for the indicated scheme task on the local nod
+ * e.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_scheme_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	if(bpStartScheme(name) > 0)
+	{
+		*status = CTRL_SUCCESS;
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_scheme_start BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Stop the forwarder and administrative endpoint tasks for the indicated scheme task on the local node
+ * .
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_scheme_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+
+	bpStopScheme(name);
+	*status = CTRL_SUCCESS;
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_scheme_stop BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+/*
+ * Enable/Disable production of a continuous stream of user selected Bundle Protocol activity indicatio
+ * n characters. A watch parameter of 1 selects all BP activity indication characters, 0 deselects allB
+ * P activity indication characters; any other activitySpec such as acz~ selects all activity indicatio
+ * n characters in the string, deselecting all others. BP will print each selected activity indication 
+ * character to stdout every time a processing event of the associated type occurs: a new bundle is que
+ * ued for forwarding, b bundle is queued for transmission, c bundle is popped from its transmission qu
+ * eue, m custody acceptance signal is recieved, w custody of bundle is accepted, x custody of bundle i
+ * s refused, y bundle is accepted upon arrival, z bundle is queued for delivery to an application, ~ b
+ * undle is abandoned (discarded) on attempt to forward it, ! bundle is destroyed due to TTL expiration
+ * , &amp; custody refusal signal is recieved, # bundle is queued for re-forwarding due to CL protocol 
+ * failures, j bundle is placed in 'limbo' for possible future reforwarding, k bundle is removed from '
+ * limbo' and queued for reforwarding, $ bundle's custodial retransmission timeout interval expired.
+ */
+tnv_t *dtn_ion_bpadmin_ctrl_watch(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
+{
+	tnv_t *result = NULL;
+	*status = CTRL_FAILURE;
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |START CUSTOM FUNCTION ctrl_watch BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+
+	int success;
+	Sdr	sdr = getIonsdr();
+	Object	dbObj = getBpDbObject();
+	BpDB	db;
+	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
+	BpVdb	*vdb = getBpVdb();
+	int i;
+
+	CHKNULL(vdb);
+	*status = CTRL_SUCCESS;
+
+	if (strcmp(name, "1") == 0)
+	{
+		vdb->watching = -1;
+		return result;
+	}
+
+	vdb->watching = 0;
+	if (strcmp(name, "0") == 0)
+	{
+		return result;
+	}
+
+	for(i = 0; i < strlen(name); i++)
+	{
+		switch(name[i])
+		{
+			case 'a': vdb->watching |= WATCH_a; break;
+			case 'b': vdb->watching |= WATCH_b; break;
+			case 'c': vdb->watching |= WATCH_c; break;
+			case 'y': vdb->watching |= WATCH_y; break;
+			case 'z': vdb->watching |= WATCH_z; break;
+			case '~': vdb->watching |= WATCH_abandon; break;
+			case '!': vdb->watching |= WATCH_expire;  break;
+			case 'j': vdb->watching |= WATCH_limbo;   break;
+			case 'k': vdb->watching |= WATCH_delimbo; break;
+			default:
+				AMP_DEBUG_WARN("dtn_ion_bpadmin_ctrl_watch", "Invalid watch char %c.", name[i]);
+				break;
+		}
+	}
+
+
+	if (dbObj != 0)
+	{
+		CHKNULL(sdr_begin_xn(sdr));
+		sdr_stage(sdr, (char *) &db, dbObj, sizeof(BpDB));
+		db.watching = vdb->watching;
+		sdr_write(sdr, dbObj, (char *) &db, sizeof(BpDB));
+		oK(sdr_end_xn(sdr));
+	}
+
+	/*
+	 * +-------------------------------------------------------------------------+
+	 * |STOP CUSTOM FUNCTION ctrl_watch BODY
+	 * +-------------------------------------------------------------------------+
+	 */
+	return result;
+}
+
+
+
+/* OP Functions */
diff -ru --new-file ion-sf/bpv7/nm/agent/adm_ion_bp_admin_impl.h ion-anms/bpv7/nm/agent/adm_ion_bp_admin_impl.h
--- ion-sf/bpv7/nm/agent/adm_ion_bp_admin_impl.h	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/agent/adm_ion_bp_admin_impl.h	2023-05-15 12:59:40.841870085 -0400
@@ -0,0 +1,104 @@
+/****************************************************************************
+ **
+ ** File Name: adm_ion_bp_admin_impl.h
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History:
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2023-04-12  AUTO             Auto-generated header file
+ **
+ ****************************************************************************/
+
+#ifndef ADM_ION_BP_ADMIN_IMPL_H_
+#define ADM_ION_BP_ADMIN_IMPL_H_
+
+/*   START CUSTOM INCLUDES HERE  */
+/*             TODO              */
+/*   STOP CUSTOM INCLUDES HERE  */
+
+
+#include "shared/utils/utils.h"
+#include "shared/primitives/ctrl.h"
+#include "shared/primitives/table.h"
+#include "shared/primitives/tnv.h"
+
+/*   START typeENUM */
+/*   STOP typeENUM  */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                     Retrieval Functions                                     +
+ * +---------------------------------------------------------------------------------------------+
+ */
+/*   START CUSTOM FUNCTIONS HERE */
+/*   STOP CUSTOM FUNCTIONS HERE  */
+
+void dtn_ion_bpadmin_setup();
+void dtn_ion_bpadmin_cleanup();
+
+
+/* Metadata Functions */
+tnv_t *dtn_ion_bpadmin_meta_name(tnvc_t *parms);
+tnv_t *dtn_ion_bpadmin_meta_enum(tnvc_t *parms);
+tnv_t *dtn_ion_bpadmin_meta_namespace(tnvc_t *parms);
+tnv_t *dtn_ion_bpadmin_meta_version(tnvc_t *parms);
+tnv_t *dtn_ion_bpadmin_meta_organization(tnvc_t *parms);
+
+/* Constant Functions */
+
+/* Collect Functions */
+tnv_t *dtn_ion_bpadmin_get_bp_version(tnvc_t *parms);
+
+
+/* Control Functions */
+tnv_t *dtn_ion_bpadmin_ctrl_endpoint_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_endpoint_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_endpoint_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_induct_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_induct_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_induct_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_induct_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_induct_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_manage_heap_max(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_outduct_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_block(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_egress_plan_unblock(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_protocol_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_protocol_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_protocol_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_protocol_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_start(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_scheme_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+tnv_t *dtn_ion_bpadmin_ctrl_watch(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
+
+
+/* OP Functions */
+
+
+/* Table Build Functions */
+tbl_t *dtn_ion_bpadmin_tblt_endpoints(ari_t *id);
+tbl_t *dtn_ion_bpadmin_tblt_inducts(ari_t *id);
+tbl_t *dtn_ion_bpadmin_tblt_outducts(ari_t *id);
+tbl_t *dtn_ion_bpadmin_tblt_protocols(ari_t *id);
+tbl_t *dtn_ion_bpadmin_tblt_schemes(ari_t *id);
+tbl_t *dtn_ion_bpadmin_tblt_egress_plans(ari_t *id);
+
+#endif // ADM_ION_BP_ADMIN_IMPL_H_
diff -ru --new-file ion-sf/bpv7/nm/mgr/adm_bp_agent_mgr.c ion-anms/bpv7/nm/mgr/adm_bp_agent_mgr.c
--- ion-sf/bpv7/nm/mgr/adm_bp_agent_mgr.c	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/mgr/adm_bp_agent_mgr.c	2023-05-15 12:59:40.845870122 -0400
@@ -0,0 +1,315 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bp_agent_mgr.c
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated c file 
+ **
+ ****************************************************************************/
+
+
+#include "ion.h"
+#include "platform.h"
+#include "adm_bp_agent.h"
+#include "shared/utils/utils.h"
+#include "shared/primitives/report.h"
+#include "shared/primitives/blob.h"
+#include "metadata.h"
+#include "nm_mgr_ui.h"
+
+
+
+
+#define _HAVE_DTN_BP_AGENT_ADM_
+#ifdef _HAVE_DTN_BP_AGENT_ADM_
+static vec_idx_t g_dtn_bp_agent_idx[11];
+
+void dtn_bp_agent_init()
+{
+	adm_add_adm_info("dtn_bp_agent", ADM_ENUM_DTN_BP_AGENT);
+
+	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_META_IDX), &(g_dtn_bp_agent_idx[ADM_META_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_RPTT_IDX), &(g_dtn_bp_agent_idx[ADM_RPTT_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_EDD_IDX), &(g_dtn_bp_agent_idx[ADM_EDD_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BP_AGENT * 20) + ADM_CTRL_IDX), &(g_dtn_bp_agent_idx[ADM_CTRL_IDX]));
+
+
+	dtn_bp_agent_init_meta();
+	dtn_bp_agent_init_cnst();
+	dtn_bp_agent_init_edd();
+	dtn_bp_agent_init_op();
+	dtn_bp_agent_init_var();
+	dtn_bp_agent_init_ctrl();
+	dtn_bp_agent_init_mac();
+	dtn_bp_agent_init_rpttpl();
+	dtn_bp_agent_init_tblt();
+}
+
+void dtn_bp_agent_init_meta()
+{
+
+	ari_t *id = NULL;
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAME);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "name", "The human-readable name of the ADM.");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAMESPACE);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "namespace", "The namespace of the ADM.");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_VERSION);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "version", "The version of the ADM");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_ORGANIZATION);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "organization", "The name of the issuing organization of the ADM.");
+
+}
+
+void dtn_bp_agent_init_cnst()
+{
+
+}
+
+void dtn_bp_agent_init_edd()
+{
+
+	ari_t *id = NULL;
+
+	metadata_t *meta = NULL;
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_ID);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "bp_node_id", "The node administration endpoint");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_VERSION);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "bp_node_version", "The latest version of the BP supported by this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_AVAILABLE_STORAGE);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UVAST, id, ADM_ENUM_DTN_BP_AGENT, "available_storage", "Bytes available for bundle storage");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_LAST_RESET_TIME);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UVAST, id, ADM_ENUM_DTN_BP_AGENT, "last_reset_time", "The last time that BP counters were reset, either due to execution of a reset control or a restart of the node itself");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_REGISTRATIONS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_registrations", "number of registrations");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_FWD);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_pend_fwd", "number of bundles pending forwarding");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_DIS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_pend_dis", "number of bundles awaiting dispatch");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_IN_CUST);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_in_cust", "number of bundles");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_pend_reassembly", "number of bundles pending reassembly");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "bundles_by_priority", "number of bundles for the given priority. Priority is given as a priority mask where Bulk=0x1, normal=0x2, express=0x4. Any bundles matching any of the masked priorities will be included in the returned count");
+
+	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "bytes_by_priority", "number of bytes of the given priority. Priority is given as a priority mask where bulk=0x1, normal=0x2, express=0x4. Any bundles matching any of the masked priorities will be included in the returned count.");
+
+	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "src_bundles_by_priority", "number of bundles sourced by this node of the given priority. Priority is given as a priority mask where bulk=0x1, normal=0x2, express=0x4. Any bundles sourced by this node and matching any of the masked priorities will be included in the returned count.");
+
+	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "src_bytes_by_priority", "number of bytes sourced by this node of the given priority. Priority is given as a priority mask where bulk=0x1, normal=0x2, express=0x4. Any bundles sourced by this node and matching any of the masked priorities will be included in the returned count");
+
+	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_fragmented_bundles", "number of fragmented bundles");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_fragments_produced", "number of bundles with fragmentary payloads produced by this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_failed_by_reason", "number of bundles failed for any of the given reasons. (noInfo=0x1, Expired=0x2, UniFwd=0x4, Cancelled=0x8, NoStorage=0x10, BadEID=0x20, NoRoute=0x40, NoContact=0x80, BadBlock=0x100)");
+
+	meta_add_parm(meta, "mask", AMP_TYPE_UINT);
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "num_bundles_deleted", "number of bundles deleted by this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "failed_custody_bundles", "number of bundle fails at this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "failed_custody_bytes", "number bytes of fails at this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "failed_forward_bundles", "number bundles not forwarded by this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "failed_forward_bytes", "number of bytes not forwaded by this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BUNDLES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "abandoned_bundles", "number of bundles abandoned by this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "abandoned_bytes", "number of bytes abandoned by this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BUNDLES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "discarded_bundles", "number of bundles discarded by this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "discarded_bytes", "number of bytes discarded by this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_NAMES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BP_AGENT, "endpoint_names", "CSV list of endpoint names for this node");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "endpoint_active", "is the given endpoint active? (0=no)");
+
+	meta_add_parm(meta, "endpoint_name", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "endpoint_singleton", "is the given endpoint singleton? (0=no)");
+
+	meta_add_parm(meta, "endpoint_name", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_POLICY);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BP_AGENT, "endpoint_policy", "Does the endpoint abandon on fail (0=no)");
+
+	meta_add_parm(meta, "endpoint_name", AMP_TYPE_STR);
+}
+
+void dtn_bp_agent_init_op()
+{
+
+}
+
+void dtn_bp_agent_init_var()
+{
+
+}
+
+void dtn_bp_agent_init_ctrl()
+{
+
+	ari_t *id = NULL;
+
+
+	/* RESET_ALL_COUNTS */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 0, g_dtn_bp_agent_idx[ADM_CTRL_IDX], DTN_BP_AGENT_CTRL_RESET_ALL_COUNTS);
+	adm_add_ctrldef_ari(id, 0, NULL);
+	meta_add_ctrl(id, ADM_ENUM_DTN_BP_AGENT, "reset_all_counts", "This control causes the Agent to reset all counts associated with bundle or byte statistics and to set the last reset time of the BP primitive data to the time when the control was run");
+
+}
+
+void dtn_bp_agent_init_mac()
+{
+
+}
+
+void dtn_bp_agent_init_rpttpl()
+{
+
+	metadata_t *meta = NULL;
+
+	rpttpl_t *def = NULL;
+
+	/* FULL_REPORT */
+	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_dtn_bp_agent_idx[ADM_RPTT_IDX], DTN_BP_AGENT_RPTTPL_FULL_REPORT));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_NAME));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bp_agent_idx[ADM_META_IDX], DTN_BP_AGENT_META_VERSION));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_ID));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BP_NODE_VERSION));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_AVAILABLE_STORAGE));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_LAST_RESET_TIME));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_REGISTRATIONS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_FWD));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_DIS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_IN_CUST));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY, tnv_from_uint(4)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY, tnv_from_uint(4)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY, tnv_from_uint(4)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY, tnv_from_uint(4)));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(1)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(2)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(4)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(8)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(16)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(32)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(64)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(128)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON, tnv_from_uint(256)));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ABANDONED_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BUNDLES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_DISCARDED_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_NAMES));
+	adm_add_rpttpl(def);
+	meta_add_rpttpl(def->id, ADM_ENUM_DTN_BP_AGENT, "full_report", "This is all known meta-data, EDD, and VAR values known by the agent.");
+	/* ENDPOINT_REPORT */
+	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_bp_agent_idx[ADM_RPTT_IDX], DTN_BP_AGENT_RPTTPL_ENDPOINT_REPORT));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bp_agent_idx[ADM_EDD_IDX], DTN_BP_AGENT_EDD_ENDPOINT_POLICY, tnv_from_map(AMP_TYPE_STR, 0)));
+	adm_add_rpttpl(def);
+	meta = meta_add_rpttpl(def->id, ADM_ENUM_DTN_BP_AGENT, "endpoint_report", "This is all known endpoint information");
+	meta_add_parm(meta, "endpoint_id", AMP_TYPE_STR);
+}
+
+void dtn_bp_agent_init_tblt()
+{
+
+}
+
+#endif // _HAVE_DTN_BP_AGENT_ADM_
diff -ru --new-file ion-sf/bpv7/nm/mgr/adm_bpsec_mgr.c ion-anms/bpv7/nm/mgr/adm_bpsec_mgr.c
--- ion-sf/bpv7/nm/mgr/adm_bpsec_mgr.c	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/mgr/adm_bpsec_mgr.c	2023-05-15 12:59:40.869870345 -0400
@@ -0,0 +1,576 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bpsec_mgr.c
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated c file 
+ **
+ ****************************************************************************/
+
+
+#include "ion.h"
+#include "platform.h"
+#include "adm_bpsec.h"
+#include "shared/utils/utils.h"
+#include "shared/primitives/report.h"
+#include "shared/primitives/blob.h"
+#include "metadata.h"
+#include "nm_mgr_ui.h"
+
+
+#include "adm_amp_agent.h"
+
+
+#define _HAVE_DTN_BPSEC_ADM_
+#ifdef _HAVE_DTN_BPSEC_ADM_
+static vec_idx_t g_dtn_bpsec_idx[11];
+
+void dtn_bpsec_init()
+{
+	adm_add_adm_info("dtn_bpsec", ADM_ENUM_DTN_BPSEC);
+
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_RPTT_IDX), &(g_dtn_bpsec_idx[ADM_RPTT_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_EDD_IDX), &(g_dtn_bpsec_idx[ADM_EDD_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_CTRL_IDX), &(g_dtn_bpsec_idx[ADM_CTRL_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_META_IDX), &(g_dtn_bpsec_idx[ADM_META_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_TBLT_IDX), &(g_dtn_bpsec_idx[ADM_TBLT_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_BPSEC * 20) + ADM_VAR_IDX), &(g_dtn_bpsec_idx[ADM_VAR_IDX]));
+
+
+	dtn_bpsec_init_meta();
+	dtn_bpsec_init_cnst();
+	dtn_bpsec_init_edd();
+	dtn_bpsec_init_op();
+	dtn_bpsec_init_var();
+	dtn_bpsec_init_ctrl();
+	dtn_bpsec_init_mac();
+	dtn_bpsec_init_rpttpl();
+	dtn_bpsec_init_tblt();
+}
+
+void dtn_bpsec_init_meta()
+{
+
+	ari_t *id = NULL;
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_NAME);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "name", "The human-readable name of the ADM.");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_NAMESPACE);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "namespace", "The namespace of the ADM.");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_VERSION);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "version", "The version of the ADM.");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_bpsec_idx[ADM_META_IDX], DTN_BPSEC_META_ORGANIZATION);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "organization", "The name of the issuing organization of the ADM.");
+
+}
+
+void dtn_bpsec_init_cnst()
+{
+
+}
+
+void dtn_bpsec_init_edd()
+{
+
+	ari_t *id = NULL;
+
+	metadata_t *meta = NULL;
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bcb_blk", "Total successfully Tx Bundle Confidentiality blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_blk", "Total unsuccessfully Tx Block Confidentiality Block (BCB) blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bcb_blk", "Total successfully Rx BCB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bcb_blk", "Total unsuccessfully Rx BCB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bcb_blks", "Total missing-on-RX BCB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bcb_blks", "Total forward BCB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bcb_bytes", "Total successfully Tx BCB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_bytes", "Total unsuccessfully Tx BCB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_blks", "Total unsuccessfully Tx BCB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bcb_bytes", "Total successfully Rx BCB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bcb_bytes", "Total unsuccessfully Rx BCB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bcb_bytes", "Total missing-on-Rx BCB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bcb_bytes", "Total forwarded BCB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bib_blks", "Total successfully Tx Block Integrity Block (BIB) blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bib_blks", "Total unsuccessfully Tx BIB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bib_blks", "Total successfully Rx BIB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bib_blks", "Total unsuccessfully Rx BIB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_miss_rx_bib_blks", "Total missing-on-Rx BIB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bib_blks", "Total forwarded BIB blocks");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bib_bytes", "Total successfully Tx BIB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bib_bytes", "Total unsuccessfully Tx BIB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bib_bytes", "Total successfully Rx BIB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bib_bytes", "Total unsuccessfully Rx BIB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_miss_rx_bib_bytes", "Total missing-on-Rx BIB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bib_bytes", "Total forwarded BIB bytes");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_TV, id, ADM_ENUM_DTN_BPSEC, "last_update", "Last BPSEC update");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_KNOWN_KEYS);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_known_keys", "Number of known keys");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_KEY_NAMES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "key_names", "Known key names");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_CIPHERSUITE_NAMES);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "ciphersuite_names", "Known ciphersuite names");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_RULE_SOURCE);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_BPSEC, "rule_source", "Known rule sources");
+
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bcb_blks_src", "Number of successfully Tx BCB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_blks_src", "Number of failed TX BCB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bcb_blks_src", "Number of successfully Rx BCB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bcb_blks_src", "Number of failed RX BCB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bcb_blks_src", "Number of missing-onRX BCB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bcb_blks_src", "Number of forwarded BCB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bcb_bytes_src", "Number of successfully Tx bcb bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bcb_bytes_src", "Number of failed Tx bcb bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bcb_bytes_src", "Number of successfully Rx bcb bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bcb_bytes_src", "Number of failed Rx bcb bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bcb_bytes_src", "Number of missing-on-Rx bcb bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bcb_bytes_src", "Number of forwarded bcb bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bib_blks_src", "Number of successfully Tx BIB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bib_blks_src", "Number of failed Tx BIB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bib_blks_src", "Number of successfully Rx BIB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bib_blks_src", "Number of failed Rx BIB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_miss_rx_bib_blks_src", "Number of missing-on-Rx BIB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bib_blks_src", "Number of forwarded BIB blocks from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_tx_bib_bytes_src", "Number of successfully Tx BIB bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_tx_bib_bytes_src", "Number of failed Tx BIB bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_good_rx_bib_bytes_src", "Number of successfully Rx BIB bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_bad_rx_bib_bytes_src", "Number of failed Rx BIB bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_missing_rx_bib_bytes_src", "Number of missing-on-Rx BIB bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "num_fwd_bib_bytes_src", "Number of forwarded BIB bytes from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE_SRC);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_TV, id, ADM_ENUM_DTN_BPSEC, "last_update_src", "Last BPSEC update from SRC");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_RESET);
+	adm_add_edd(id, NULL);
+	meta = meta_add_edd(AMP_TYPE_TV, id, ADM_ENUM_DTN_BPSEC, "last_reset", "Last reset");
+
+	meta_add_parm(meta, "Src", AMP_TYPE_STR);
+}
+
+void dtn_bpsec_init_op()
+{
+
+}
+
+void dtn_bpsec_init_var()
+{
+
+	ari_t *id = NULL;
+
+	expr_t *expr = NULL;
+
+
+	/* TOTAL_BAD_TX_BLKS */
+
+	id = adm_build_ari(AMP_TYPE_VAR, 0, g_dtn_bpsec_idx[ADM_VAR_IDX], DTN_BPSEC_VAR_TOTAL_BAD_TX_BLKS);
+	expr = expr_create(AMP_TYPE_UINT);
+	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS));
+	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS));
+	expr_add_item(expr, adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUINT));
+	adm_add_var_from_expr(id, AMP_TYPE_UINT, expr);
+	meta_add_var(AMP_TYPE_UINT, id, ADM_ENUM_DTN_BPSEC, "total_bad_tx_blks", "This is the number of failed TX blocks (# failed BIB + # failed bcb).");
+
+}
+
+void dtn_bpsec_init_ctrl()
+{
+
+	ari_t *id = NULL;
+
+	metadata_t *meta = NULL;
+
+
+	/* RST_ALL_CNTS */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 0, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_RST_ALL_CNTS);
+	adm_add_ctrldef_ari(id, 0, NULL);
+	meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "rst_all_cnts", "This control causes the Agent to reset all counts associated with block or byte statistics and to set the Last Reset Time of the BPsec EDD data to the time when the control was run.");
+
+
+	/* RST_SRC_CNTS */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_RST_SRC_CNTS);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "rst_src_cnts", "This control causes the Agent to reset all counts (blocks and bytes) associated with a given bundle source and set the Last Reset Time of the source statistics to the time when the control was run.");
+
+	meta_add_parm(meta, "src", AMP_TYPE_STR);
+
+	/* DELETE_KEY */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DELETE_KEY);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "delete_key", "This control deletes a key from the BPsec system.");
+
+	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
+
+	/* ADD_KEY */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_KEY);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "add_key", "This control adds a key to the BPsec system.");
+
+	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "keyData", AMP_TYPE_BYTESTR);
+
+	/* ADD_BIB_RULE */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_BIB_RULE);
+	adm_add_ctrldef_ari(id, 5, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "add_bib_rule", "This control configures policy on the BPsec protocol implementation that describes how BIB blocks should be applied to bundles in the system. This policy is captured as a rule which states when transmitting a bundle from the given source endpoint ID to the given destination endpoint ID, blocks of type target should have a BIB added to them using the given ciphersuite and the given key.");
+
+	meta_add_parm(meta, "source", AMP_TYPE_STR);
+	meta_add_parm(meta, "destination", AMP_TYPE_STR);
+	meta_add_parm(meta, "target", AMP_TYPE_INT);
+	meta_add_parm(meta, "ciphersuiteId", AMP_TYPE_STR);
+	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
+
+	/* DEL_BIB_RULE */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DEL_BIB_RULE);
+	adm_add_ctrldef_ari(id, 3, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "del_bib_rule", "This control removes any configured policy on the BPsec protocol implementation that describes how BIB blocks should be applied to bundles in the system. A BIB policy is uniquely identified by a source endpoint Id, a destination Id, and a target block type.");
+
+	meta_add_parm(meta, "source", AMP_TYPE_STR);
+	meta_add_parm(meta, "destination", AMP_TYPE_STR);
+	meta_add_parm(meta, "target", AMP_TYPE_INT);
+
+	/* ADD_BCB_RULE */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_ADD_BCB_RULE);
+	adm_add_ctrldef_ari(id, 5, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "add_bcb_rule", "This control configures policy on the BPsec protocol implementation that describes how BCB blocks should be applied to bundles in the system. This policy is captured as a rule which states when transmitting a bundle from the given source endpoint id to the given destination endpoint id, blocks of type target should have a bcb added to them using the given ciphersuite and the given key.");
+
+	meta_add_parm(meta, "source", AMP_TYPE_STR);
+	meta_add_parm(meta, "destination", AMP_TYPE_STR);
+	meta_add_parm(meta, "target", AMP_TYPE_INT);
+	meta_add_parm(meta, "ciphersuiteId", AMP_TYPE_STR);
+	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
+
+	/* DEL_BCB_RULE */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_bpsec_idx[ADM_CTRL_IDX], DTN_BPSEC_CTRL_DEL_BCB_RULE);
+	adm_add_ctrldef_ari(id, 3, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_BPSEC, "del_bcb_rule", "This control removes any configured policy on the BPsec protocol implementation that describes how BCB blocks should be applied to bundles in the system. A bcb policy is uniquely identified by a source endpoint id, a destination endpoint id, and a target block type.");
+
+	meta_add_parm(meta, "source", AMP_TYPE_STR);
+	meta_add_parm(meta, "destination", AMP_TYPE_STR);
+	meta_add_parm(meta, "target", AMP_TYPE_INT);
+}
+
+void dtn_bpsec_init_mac()
+{
+
+}
+
+void dtn_bpsec_init_rpttpl()
+{
+
+	metadata_t *meta = NULL;
+
+	rpttpl_t *def = NULL;
+
+	/* FULL_REPORT */
+	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_dtn_bpsec_idx[ADM_RPTT_IDX], DTN_BPSEC_RPTTPL_FULL_REPORT));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_KNOWN_KEYS));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_KEY_NAMES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_CIPHERSUITE_NAMES));
+	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_RULE_SOURCE));
+	adm_add_rpttpl(def);
+	meta_add_rpttpl(def->id, ADM_ENUM_DTN_BPSEC, "full_report", "all known meta-data, externally defined data, and variables");
+	/* SOURCE_REPORT */
+	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_bpsec_idx[ADM_RPTT_IDX], DTN_BPSEC_RPTTPL_SOURCE_REPORT));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_UPDATE_SRC, tnv_from_map(AMP_TYPE_STR, 0)));
+	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_bpsec_idx[ADM_EDD_IDX], DTN_BPSEC_EDD_LAST_RESET, tnv_from_map(AMP_TYPE_STR, 0)));
+	adm_add_rpttpl(def);
+	meta = meta_add_rpttpl(def->id, ADM_ENUM_DTN_BPSEC, "source_report", "security info by source");
+	meta_add_parm(meta, "Source", AMP_TYPE_STR);
+}
+
+void dtn_bpsec_init_tblt()
+{
+
+	tblt_t *def = NULL;
+
+	/* KEYS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_KEYS), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "key_name");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_BPSEC, "keys", "This table lists all keys in the security policy database.");
+
+	/* CIPHERSUITES */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_CIPHERSUITES), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "csname");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_BPSEC, "ciphersuites", "This table lists supported ciphersuites.");
+
+	/* BIB_RULES */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_BIB_RULES), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "SrcEid");
+	tblt_add_col(def, AMP_TYPE_STR, "DestEid");
+	tblt_add_col(def, AMP_TYPE_UINT, "TgtBlk");
+	tblt_add_col(def, AMP_TYPE_STR, "csName");
+	tblt_add_col(def, AMP_TYPE_STR, "keyName");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_BPSEC, "bib_rules", "BIB Rules.");
+
+	/* BCB_RULES */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_bpsec_idx[ADM_TBLT_IDX], DTN_BPSEC_TBLT_BCB_RULES), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "SrcEid");
+	tblt_add_col(def, AMP_TYPE_STR, "DestEid");
+	tblt_add_col(def, AMP_TYPE_UINT, "TgtBlk");
+	tblt_add_col(def, AMP_TYPE_STR, "csName");
+	tblt_add_col(def, AMP_TYPE_STR, "keyName");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_BPSEC, "bcb_rules", "BCB Rules.");
+}
+
+#endif // _HAVE_DTN_BPSEC_ADM_
diff -ru --new-file ion-sf/bpv7/nm/mgr/adm_ion_bp_admin_mgr.c ion-anms/bpv7/nm/mgr/adm_ion_bp_admin_mgr.c
--- ion-sf/bpv7/nm/mgr/adm_ion_bp_admin_mgr.c	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/mgr/adm_ion_bp_admin_mgr.c	2023-05-15 12:59:40.877870420 -0400
@@ -0,0 +1,472 @@
+/****************************************************************************
+ **
+ ** File Name: adm_ion_bp_admin_mgr.c
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History:
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2023-04-12  AUTO             Auto-generated c file
+ **
+ ****************************************************************************/
+
+
+#include "ion.h"
+#include "platform.h"
+#include "adm_ion_bp_admin.h"
+#include "shared/utils/utils.h"
+#include "shared/primitives/report.h"
+#include "shared/primitives/blob.h"
+#include "metadata.h"
+#include "nm_mgr_ui.h"
+
+vec_idx_t g_dtn_ion_bpadmin_idx[11];
+
+static void dtn_ion_bpadmin_init_meta(void);
+static void dtn_ion_bpadmin_init_cnst(void);
+static void dtn_ion_bpadmin_init_edd(void);
+static void dtn_ion_bpadmin_init_op(void);
+static void dtn_ion_bpadmin_init_var(void);
+static void dtn_ion_bpadmin_init_ctrl(void);
+static void dtn_ion_bpadmin_init_mac(void);
+static void dtn_ion_bpadmin_init_rpttpl(void);
+static void dtn_ion_bpadmin_init_tblt(void);
+
+void dtn_ion_bpadmin_init()
+{
+	adm_add_adm_info("dtn_ion_bpadmin", ADM_ENUM_DTN_ION_BPADMIN);
+
+	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_bpadmin_idx[ADM_META_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_bpadmin_idx[ADM_EDD_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX]));
+	VDB_ADD_NN(((ADM_ENUM_DTN_ION_BPADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX]));
+
+
+	dtn_ion_bpadmin_init_meta();
+	dtn_ion_bpadmin_init_cnst();
+	dtn_ion_bpadmin_init_edd();
+	dtn_ion_bpadmin_init_op();
+	dtn_ion_bpadmin_init_var();
+	dtn_ion_bpadmin_init_ctrl();
+	dtn_ion_bpadmin_init_mac();
+	dtn_ion_bpadmin_init_rpttpl();
+	dtn_ion_bpadmin_init_tblt();
+}
+
+void dtn_ion_bpadmin_init_meta()
+{
+
+	ari_t *id = NULL;
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_NAME);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "name", "The human-readable name of the ADM.");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_ENUM);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_INT, id, ADM_ENUM_DTN_ION_BPADMIN, "enum", "None");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_NAMESPACE);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "namespace", "The namespace of the ADM");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_VERSION);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "version", "The version of the ADM");
+
+	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_bpadmin_idx[ADM_META_IDX], DTN_ION_BPADMIN_META_ORGANIZATION);
+	adm_add_cnst(id, NULL);
+	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "organization", "The name of the issuing organization of the ADM");
+
+}
+
+void dtn_ion_bpadmin_init_cnst()
+{
+
+}
+
+void dtn_ion_bpadmin_init_edd()
+{
+
+	ari_t *id = NULL;
+
+	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_bpadmin_idx[ADM_EDD_IDX], DTN_ION_BPADMIN_EDD_BP_VERSION);
+	adm_add_edd(id, NULL);
+	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_BPADMIN, "bp_version", "Version of installed ION BP Admin utility.");
+
+}
+
+void dtn_ion_bpadmin_init_op()
+{
+
+}
+
+void dtn_ion_bpadmin_init_var()
+{
+
+}
+
+void dtn_ion_bpadmin_init_ctrl()
+{
+
+	ari_t *id = NULL;
+
+	metadata_t *meta = NULL;
+
+
+	/* ENDPOINT_ADD */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_ADD);
+	adm_add_ctrldef_ari(id, 3, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "endpoint_add", "Establish DTN endpoint named endpointId on the local node. The remaining parameters indicate what is to be done when bundles destined for this endpoint arrive at a time when no application has the endpoint open for bundle reception. If type is 'x', then such bundles are to be discarded silently and immediately. If type is 'q', then such bundles are to be enqueued for later delivery and, if recvScript is provided, recvScript is to be executed.");
+	meta_add_parm(meta, "endpoint_id", AMP_TYPE_STR);
+	meta_add_parm(meta, "type", AMP_TYPE_UINT);
+	meta_add_parm(meta, "rcv_script", AMP_TYPE_STR);
+
+
+	/* ENDPOINT_CHANGE */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_CHANGE);
+	adm_add_ctrldef_ari(id, 3, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "endpoint_change", "Change the action taken when bundles destined for this endpoint arrive at a time when no application has the endpoint open for bundle reception.");
+	meta_add_parm(meta, "endpoint_id", AMP_TYPE_STR);
+	meta_add_parm(meta, "type", AMP_TYPE_UINT);
+	meta_add_parm(meta, "rcv_script", AMP_TYPE_STR);
+
+
+	/* ENDPOINT_DEL */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_ENDPOINT_DEL);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "endpoint_del", "Delete the endpoint identified by endpointId. The control will fail if any bundles are currently pending delivery to this endpoint.");
+	meta_add_parm(meta, "endpoint_id", AMP_TYPE_STR);
+
+
+	/* INDUCT_ADD */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_ADD);
+	adm_add_ctrldef_ari(id, 3, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_add", "Establish a duct for reception of bundles via the indicated CL protocol. The duct's data acquisition structure is used and populated by the induct task whose operation is initiated by cliControl at the time the duct is started.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "cli_control", AMP_TYPE_STR);
+
+
+	/* INDUCT_CHANGE */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_CHANGE);
+	adm_add_ctrldef_ari(id, 3, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_change", "Change the control used to initiate operation of the induct task for the indicated duct.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "cli_control", AMP_TYPE_STR);
+
+
+	/* INDUCT_DEL */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_DEL);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_del", "Delete the induct identified by protocolName and ductName. The control will fail if any bundles are currently pending acquisition via this induct.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* INDUCT_START */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_START);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_start", "Start the indicated induct task as defined for the indicated CL protocol on the local node.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* INDUCT_STOP */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_INDUCT_STOP);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "induct_stop", "Stop the indicated induct task as defined for the indicated CL protocol on the local node.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* MANAGE_HEAP_MAX */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_MANAGE_HEAP_MAX);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "manage_heap_max", "Declare the maximum number of bytes of SDR heap space that will be occupied by any single bundle acquisition activity (nominally the acquisition of a single bundle, but this is at the discretion of the convergence-layer input task). All data acquired in excess of this limit will be written to a temporary file pending extraction and dispatching of the acquired bundle or bundles. The default is the minimum allowed value (560 bytes), which is the approximate size of a ZCO file reference object; this is the minimum SDR heap space occupancy in the event that all acquisition is into a file.");
+	meta_add_parm(meta, "max_database_heap_per_acquisition", AMP_TYPE_UINT);
+
+
+	/* OUTDUCT_ADD */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_ADD);
+	adm_add_ctrldef_ari(id, 4, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_add", "Establish a duct for transmission of bundles via the indicated CL protocol. the duct's data transmission structure is serviced by the outduct task whose operation is initiated by CLOcommand at the time the duct is started. A value of zero for maxPayloadLength indicates that bundles of any size can be accomodated; this is the default.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "clo_command", AMP_TYPE_STR);
+	meta_add_parm(meta, "max_payload_length", AMP_TYPE_UINT);
+
+
+	/* OUTDUCT_CHANGE */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_CHANGE);
+	adm_add_ctrldef_ari(id, 4, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_change", "Set new values for the indicated duct's payload size limit and the control that is used to initiate operation of the outduct task for this duct.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "clo_control", AMP_TYPE_STR);
+	meta_add_parm(meta, "max_payload_length", AMP_TYPE_UINT);
+
+
+	/* OUTDUCT_DEL */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_DEL);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_del", "Delete the outduct identified by protocolName and ductName. The control will fail if any bundles are currently pending transmission via this outduct.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* OUTDUCT_START */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_START);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_start", "Start the indicated outduct task as defined for the indicated CL protocol on the local node.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* OUTDUCT_STOP */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_OUTDUCT_STOP);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "outduct_stop", "Stop the indicated outduct task as defined for the indicated CL protocol on the local node.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* EGRESS_PLAN_ADD */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_ADD);
+	adm_add_ctrldef_ari(id, 3, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plan_add", "Add an egress plan for a specific peer and outduct.");
+	meta_add_parm(meta, "neighbor_eid", AMP_TYPE_STR);
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* EGRESS_PLAN_DEL */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_DEL);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plan_del", "Remove an egress plan for a specific peer and outduct.");
+	meta_add_parm(meta, "neighbor_eid", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* EGRESS_PLAN_START */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_START);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plan_start", "Start the indicated egress plan task.");
+	meta_add_parm(meta, "neighbor_eid", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* EGRESS_PLAN_STOP */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_STOP);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plan_stop", "Stop the indicated egress plan task.");
+	meta_add_parm(meta, "neighbor_eid", AMP_TYPE_STR);
+	meta_add_parm(meta, "duct_name", AMP_TYPE_STR);
+
+
+	/* EGRESS_PLAN_BLOCK */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_BLOCK);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plan_block", "Disable transmission of bundles queued for transmission to the indicated node and reforwards all non-critical bundles currently queued for transmission to this node. This may result in some or all of these bundles being enqueued for transmission to the psuedo-node limbo.");
+	meta_add_parm(meta, "neighbor_eid", AMP_TYPE_STR);
+
+
+	/* EGRESS_PLAN_UNBLOCK */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_UNBLOCK);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plan_unblock", "Re-enable transmission of bundles to the indicated node and reforwards all bundles in limbo in the hope that the unblocking of this egress plan will enable some of them to be transmitted.");
+	meta_add_parm(meta, "neighbor_eid", AMP_TYPE_STR);
+
+
+	/* PROTOCOL_ADD */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_ADD);
+	adm_add_ctrldef_ari(id, 4, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "protocol_add", "Establish access to the named convergence layer protocol at the local node. The payloadBytesPerFrame and overheadBytesPerFrame arguments are used in calculating the estimated transmission capacity consumption of each bundle, to aid in route computation and congesting forecasting. The optional nominalDataRate argument overrides the hard coded default continuous data rate for the indicated protocol for purposes of rate control. For all promiscuous prototocols-that is, protocols whose outducts are not specifically dedicated to transmission to a single identified convergence-layer protocol endpoint- the protocol's applicable nominal continuous data rate is the data rate that is always used for rate control over links served by that protocol; data rates are not extracted from contact graph information. This is because only the induct and outduct throttles for non-promiscuous protocols (LTP, TCP) can be dynamically adjusted in response to changes in data rate between the local node and its neighbors, as enacted per the contact plan. Even for an outduct of a non-promiscuous protocol the nominal data rate may be the authority for rate control, in the event that the contact plan lacks identified contacts with the node to which the outduct is mapped.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "payload_bytes_per_frame", AMP_TYPE_UINT);
+	meta_add_parm(meta, "overhead_bytes_per_frame", AMP_TYPE_UINT);
+	meta_add_parm(meta, "nominal_data_rate", AMP_TYPE_UINT);
+
+
+	/* PROTOCOL_DEL */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_DEL);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "protocol_del", "Delete the convergence layer protocol identified by protocolName. The control will fail if any ducts are still locally declared for this protocol.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+
+
+	/* PROTOCOL_START */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_START);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "protocol_start", "Start all induct and outduct tasks for inducts and outducts that have been defined for the indicated CL protocol on the local node.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+
+
+	/* PROTOCOL_STOP */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_PROTOCOL_STOP);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "protocol_stop", "Stop all induct and outduct tasks for inducts and outducts that have been defined for the indicated CL protocol on the local node.");
+	meta_add_parm(meta, "protocol_name", AMP_TYPE_STR);
+
+
+	/* SCHEME_ADD */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_ADD);
+	adm_add_ctrldef_ari(id, 3, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_add", "Declares an endpoint naming scheme for use in endpoint IDs, which are structured as URIs: schemeName:schemeSpecificPart. forwarderControl will be executed when the scheme is started on this node, to initiate operation of a forwarding daemon for this scheme. adminAppControl will also be executed when the scheme is started on this node, to initiate operation of a daemon that opens a custodian endpoint identified within this scheme so that it can recieve and process custody signals and bundle status reports.");
+	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "forwarder_control", AMP_TYPE_STR);
+	meta_add_parm(meta, "admin_app_control", AMP_TYPE_STR);
+
+
+	/* SCHEME_CHANGE */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_CHANGE);
+	adm_add_ctrldef_ari(id, 3, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_change", "Set the indicated scheme's forwarderControl and adminAppControl to the strings provided as arguments.");
+	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
+	meta_add_parm(meta, "forwarder_control", AMP_TYPE_STR);
+	meta_add_parm(meta, "admin_app_control", AMP_TYPE_STR);
+
+
+	/* SCHEME_DEL */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_DEL);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_del", "Delete the scheme identified by schemeName. The control will fail if any bundles identified in this scheme are pending forwarding, transmission, or delivery.");
+	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
+
+
+	/* SCHEME_START */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_START);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_start", "Start the forwarder and administrative endpoint tasks for the indicated scheme task on the local node.");
+	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
+
+
+	/* SCHEME_STOP */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_SCHEME_STOP);
+	adm_add_ctrldef_ari(id, 1, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "scheme_stop", "Stop the forwarder and administrative endpoint tasks for the indicated scheme task on the local node.");
+	meta_add_parm(meta, "scheme_name", AMP_TYPE_STR);
+
+
+	/* WATCH */
+
+	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_bpadmin_idx[ADM_CTRL_IDX], DTN_ION_BPADMIN_CTRL_WATCH);
+	adm_add_ctrldef_ari(id, 2, NULL);
+	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_BPADMIN, "watch", "Enable/Disable production of a continuous stream of user selected Bundle Protocol activity indication characters. A watch parameter of 1 selects all BP activity indication characters, 0 deselects allBP activity indication characters; any other activitySpec such as acz~ selects all activity indication characters in the string, deselecting all others. BP will print each selected activity indication character to stdout every time a processing event of the associated type occurs: a new bundle is queued for forwarding, b bundle is queued for transmission, c bundle is popped from its transmission queue, m custody acceptance signal is recieved, w custody of bundle is accepted, x custody of bundle is refused, y bundle is accepted upon arrival, z bundle is queued for delivery to an application, ~ bundle is abandoned (discarded) on attempt to forward it, ! bundle is destroyed due to TTL expiration, &amp; custody refusal signal is recieved, # bundle is queued for re-forwarding due to CL protocol failures, j bundle is placed in 'limbo' for possible future reforwarding, k bundle is removed from 'limbo' and queued for reforwarding, $ bundle's custodial retransmission timeout interval expired.");
+	meta_add_parm(meta, "status", AMP_TYPE_UINT);
+	meta_add_parm(meta, "activity_spec", AMP_TYPE_STR);
+
+}
+
+void dtn_ion_bpadmin_init_mac()
+{
+
+}
+
+void dtn_ion_bpadmin_init_rpttpl()
+{
+
+}
+
+void dtn_ion_bpadmin_init_tblt()
+{
+
+	tblt_t *def = NULL;
+
+	/* ENDPOINTS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_ENDPOINTS), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "scheme_name");
+	tblt_add_col(def, AMP_TYPE_STR, "endpoint_nss");
+	tblt_add_col(def, AMP_TYPE_UINT, "app_pid");
+	tblt_add_col(def, AMP_TYPE_STR, "recv_rule");
+	tblt_add_col(def, AMP_TYPE_STR, "rcv_script");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "endpoints", "Local endpoints, regardless of scheme name.");
+
+	/* INDUCTS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_INDUCTS), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "protocol_name");
+	tblt_add_col(def, AMP_TYPE_STR, "duct_name");
+	tblt_add_col(def, AMP_TYPE_STR, "cli_control");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "inducts", "Inducts established locally for the indicated CL protocol.");
+
+	/* OUTDUCTS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_OUTDUCTS), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "protocol_name");
+	tblt_add_col(def, AMP_TYPE_STR, "duct_name");
+	tblt_add_col(def, AMP_TYPE_UINT, "clo_pid");
+	tblt_add_col(def, AMP_TYPE_STR, "clo_control");
+	tblt_add_col(def, AMP_TYPE_UINT, "max_payload_length");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "outducts", "If protocolName is specified, this table lists all outducts established locally for the indicated CL protocol. Otherwise, it lists all locally established outducts, regardless of their protocol.");
+
+	/* PROTOCOLS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_PROTOCOLS), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "name");
+	tblt_add_col(def, AMP_TYPE_UINT, "payload_bpf");
+	tblt_add_col(def, AMP_TYPE_UINT, "overhead_bpf");
+	tblt_add_col(def, AMP_TYPE_UINT, "protocol class");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "protocols", "Convergence layer protocols that can currently be utilized at the local node.");
+
+	/* SCHEMES */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_SCHEMES), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "scheme_name");
+	tblt_add_col(def, AMP_TYPE_UINT, "fwd_pid");
+	tblt_add_col(def, AMP_TYPE_STR, "fwd_cmd");
+	tblt_add_col(def, AMP_TYPE_UINT, "admin_app_pid");
+	tblt_add_col(def, AMP_TYPE_STR, "admin_app_cmd");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "schemes", "Declared endpoint naming schemes.");
+
+	/* EGRESS_PLANS */
+
+	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_bpadmin_idx[ADM_TBLT_IDX], DTN_ION_BPADMIN_TBLT_EGRESS_PLANS), NULL);
+	tblt_add_col(def, AMP_TYPE_STR, "neighbor_eid");
+	tblt_add_col(def, AMP_TYPE_UINT, "clm_pid");
+	tblt_add_col(def, AMP_TYPE_UINT, "nominal_rate");
+	adm_add_tblt(def);
+	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_BPADMIN, "egress_plans", "Egress plans.");
+}
+
diff -ru --new-file ion-sf/bpv7/nm/shared/adm/adm_bp_agent.h ion-anms/bpv7/nm/shared/adm/adm_bp_agent.h
--- ion-sf/bpv7/nm/shared/adm/adm_bp_agent.h	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/shared/adm/adm_bp_agent.h	2023-05-15 12:59:40.881870457 -0400
@@ -0,0 +1,290 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bp_agent.h
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated header file 
+ **
+ ****************************************************************************/
+
+
+#ifndef ADM_BP_AGENT_H_
+#define ADM_BP_AGENT_H_
+#define _HAVE_DTN_BP_AGENT_ADM_
+#ifdef _HAVE_DTN_BP_AGENT_ADM_
+
+#include "shared/utils/nm_types.h"
+#include "shared/adm/adm.h"
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                 ADM TEMPLATE DOCUMENTATION                                  +
+ * +---------------------------------------------------------------------------------------------+
+ *
+ * ADM ROOT STRING:DTN/bp_agent
+ */
+#define ADM_ENUM_DTN_BP_AGENT 2
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                 AGENT NICKNAME DEFINITIONS                                  +
+ * +---------------------------------------------------------------------------------------------+
+ */
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                             DTN_BP_AGENT META-DATA DEFINITIONS                              +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |name                 |The human-readable name of the ADM.   |STR    |bp_agent                |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |namespace            |The namespace of the ADM.             |STR    |DTN/bp_agent            |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |version              |The version of the ADM                |STR    |v0.1                    |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |organization         |The name of the issuing organization o|       |                        |
+ * |                     |f the ADM.                            |STR    |JHUAPL                  |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ */
+// "name"
+#define DTN_BP_AGENT_META_NAME 0x00
+// "namespace"
+#define DTN_BP_AGENT_META_NAMESPACE 0x01
+// "version"
+#define DTN_BP_AGENT_META_VERSION 0x02
+// "organization"
+#define DTN_BP_AGENT_META_ORGANIZATION 0x03
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                      DTN_BP_AGENT EXTERNALLY DEFINED DATA DEFINITIONS                       +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |bp_node_id           |The node administration endpoint      |STR    |
+ * +---------------------+--------------------------------------+-------+
+ * |bp_node_version      |The latest version of the BP supported|       |
+ * |                     | by this node                         |STR    |
+ * +---------------------+--------------------------------------+-------+
+ * |available_storage    |Bytes available for bundle storage    |UVAST  |
+ * +---------------------+--------------------------------------+-------+
+ * |last_reset_time      |The last time that BP counters were re|       |
+ * |                     |set, either due to execution of a rese|       |
+ * |                     |t control or a restart of the node its|       |
+ * |                     |elf                                   |UVAST  |
+ * +---------------------+--------------------------------------+-------+
+ * |num_registrations    |number of registrations               |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_pend_fwd         |number of bundles pending forwarding  |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_pend_dis         |number of bundles awaiting dispatch   |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_in_cust          |number of bundles                     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_pend_reassembly  |number of bundles pending reassembly  |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |bundles_by_priority  |number of bundles for the given priori|       |
+ * |                     |ty. Priority is given as a priority ma|       |
+ * |                     |sk where Bulk=0x1, normal=0x2, express|       |
+ * |                     |=0x4. Any bundles matching any of the |       |
+ * |                     |masked priorities will be included in |       |
+ * |                     |the returned count                    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |bytes_by_priority    |number of bytes of the given priority.|       |
+ * |                     | Priority is given as a priority mask |       |
+ * |                     |where bulk=0x1, normal=0x2, express=0x|       |
+ * |                     |4. Any bundles matching any of the mas|       |
+ * |                     |ked priorities will be included in the|       |
+ * |                     | returned count.                      |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |src_bundles_by_priori|number of bundles sourced by this node|       |
+ * |                     | of the given priority. Priority is gi|       |
+ * |                     |ven as a priority mask where bulk=0x1,|       |
+ * |                     | normal=0x2, express=0x4. Any bundles |       |
+ * |                     |sourced by this node and matching any |       |
+ * |                     |of the masked priorities will be inclu|       |
+ * |                     |ded in the returned count.            |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |src_bytes_by_priority|number of bytes sourced by this node o|       |
+ * |                     |f the given priority. Priority is give|       |
+ * |                     |n as a priority mask where bulk=0x1, n|       |
+ * |                     |ormal=0x2, express=0x4. Any bundles so|       |
+ * |                     |urced by this node and matching any of|       |
+ * |                     | the masked priorities will be include|       |
+ * |                     |d in the returned count               |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fragmented_bundle|number of fragmented bundles          |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fragments_produce|number of bundles with fragmentary pay|       |
+ * |                     |loads produced by this node           |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_failed_by_reason |number of bundles failed for any of th|       |
+ * |                     |e given reasons. (noInfo=0x1, Expired=|       |
+ * |                     |0x2, UniFwd=0x4, Cancelled=0x8, NoStor|       |
+ * |                     |age=0x10, BadEID=0x20, NoRoute=0x40, N|       |
+ * |                     |oContact=0x80, BadBlock=0x100)        |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bundles_deleted  |number of bundles deleted by this node|UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |failed_custody_bundle|number of bundle fails at this node   |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |failed_custody_bytes |number bytes of fails at this node    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |failed_forward_bundle|number bundles not forwarded by this n|       |
+ * |                     |ode                                   |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |failed_forward_bytes |number of bytes not forwaded by this n|       |
+ * |                     |ode                                   |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |abandoned_bundles    |number of bundles abandoned by this no|       |
+ * |                     |de                                    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |abandoned_bytes      |number of bytes abandoned by this node|UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |discarded_bundles    |number of bundles discarded by this no|       |
+ * |                     |de                                    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |discarded_bytes      |number of bytes discarded by this node|UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |endpoint_names       |CSV list of endpoint names for this no|       |
+ * |                     |de                                    |STR    |
+ * +---------------------+--------------------------------------+-------+
+ * |endpoint_active      |is the given endpoint active? (0=no)  |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |endpoint_singleton   |is the given endpoint singleton? (0=no|       |
+ * |                     |)                                     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |endpoint_policy      |Does the endpoint abandon on fail (0=n|       |
+ * |                     |o)                                    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_BP_AGENT_EDD_BP_NODE_ID 0x00
+#define DTN_BP_AGENT_EDD_BP_NODE_VERSION 0x01
+#define DTN_BP_AGENT_EDD_AVAILABLE_STORAGE 0x02
+#define DTN_BP_AGENT_EDD_LAST_RESET_TIME 0x03
+#define DTN_BP_AGENT_EDD_NUM_REGISTRATIONS 0x04
+#define DTN_BP_AGENT_EDD_NUM_PEND_FWD 0x05
+#define DTN_BP_AGENT_EDD_NUM_PEND_DIS 0x06
+#define DTN_BP_AGENT_EDD_NUM_IN_CUST 0x07
+#define DTN_BP_AGENT_EDD_NUM_PEND_REASSEMBLY 0x08
+#define DTN_BP_AGENT_EDD_BUNDLES_BY_PRIORITY 0x09
+#define DTN_BP_AGENT_EDD_BYTES_BY_PRIORITY 0x0a
+#define DTN_BP_AGENT_EDD_SRC_BUNDLES_BY_PRIORITY 0x0b
+#define DTN_BP_AGENT_EDD_SRC_BYTES_BY_PRIORITY 0x0c
+#define DTN_BP_AGENT_EDD_NUM_FRAGMENTED_BUNDLES 0x0d
+#define DTN_BP_AGENT_EDD_NUM_FRAGMENTS_PRODUCED 0x0e
+#define DTN_BP_AGENT_EDD_NUM_FAILED_BY_REASON 0x0f
+#define DTN_BP_AGENT_EDD_NUM_BUNDLES_DELETED 0x10
+#define DTN_BP_AGENT_EDD_FAILED_CUSTODY_BUNDLES 0x11
+#define DTN_BP_AGENT_EDD_FAILED_CUSTODY_BYTES 0x12
+#define DTN_BP_AGENT_EDD_FAILED_FORWARD_BUNDLES 0x13
+#define DTN_BP_AGENT_EDD_FAILED_FORWARD_BYTES 0x14
+#define DTN_BP_AGENT_EDD_ABANDONED_BUNDLES 0x15
+#define DTN_BP_AGENT_EDD_ABANDONED_BYTES 0x16
+#define DTN_BP_AGENT_EDD_DISCARDED_BUNDLES 0x17
+#define DTN_BP_AGENT_EDD_DISCARDED_BYTES 0x18
+#define DTN_BP_AGENT_EDD_ENDPOINT_NAMES 0x19
+#define DTN_BP_AGENT_EDD_ENDPOINT_ACTIVE 0x1a
+#define DTN_BP_AGENT_EDD_ENDPOINT_SINGLETON 0x1b
+#define DTN_BP_AGENT_EDD_ENDPOINT_POLICY 0x1c
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                              DTN_BP_AGENT VARIABLE DEFINITIONS                              +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                               DTN_BP_AGENT REPORT DEFINITIONS                               +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |full_report          |This is all known meta-data, EDD, and |       |
+ * |                     |VAR values known by the agent.        |TNVC   |
+ * +---------------------+--------------------------------------+-------+
+ * |endpoint_report      |This is all known endpoint information|TNVC   |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_BP_AGENT_RPTTPL_FULL_REPORT 0x00
+#define DTN_BP_AGENT_RPTTPL_ENDPOINT_REPORT 0x01
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                               DTN_BP_AGENT TABLE DEFINITIONS                                +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                              DTN_BP_AGENT CONTROL DEFINITIONS                               +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |reset_all_counts     |This control causes the Agent to reset|       |
+ * |                     | all counts associated with bundle or |       |
+ * |                     |byte statistics and to set the last re|       |
+ * |                     |set time of the BP primitive data to t|       |
+ * |                     |he time when the control was run      |       |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_BP_AGENT_CTRL_RESET_ALL_COUNTS 0x00
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                              DTN_BP_AGENT CONSTANT DEFINITIONS                              +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                               DTN_BP_AGENT MACRO DEFINITIONS                                +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                              DTN_BP_AGENT OPERATOR DEFINITIONS                              +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+/* Initialization functions. */
+void dtn_bp_agent_init();
+void dtn_bp_agent_init_meta();
+void dtn_bp_agent_init_cnst();
+void dtn_bp_agent_init_edd();
+void dtn_bp_agent_init_op();
+void dtn_bp_agent_init_var();
+void dtn_bp_agent_init_ctrl();
+void dtn_bp_agent_init_mac();
+void dtn_bp_agent_init_rpttpl();
+void dtn_bp_agent_init_tblt();
+#endif /* _HAVE_DTN_BP_AGENT_ADM_ */
+#endif //ADM_BP_AGENT_H_
\ No newline at end of file
diff -ru --new-file ion-sf/bpv7/nm/shared/adm/adm_bpsec.h ion-anms/bpv7/nm/shared/adm/adm_bpsec.h
--- ion-sf/bpv7/nm/shared/adm/adm_bpsec.h	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/shared/adm/adm_bpsec.h	2023-05-15 12:59:40.881870457 -0400
@@ -0,0 +1,432 @@
+/****************************************************************************
+ **
+ ** File Name: adm_bpsec.h
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History: 
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2020-04-13  AUTO             Auto-generated header file 
+ **
+ ****************************************************************************/
+
+
+#ifndef ADM_BPSEC_H_
+#define ADM_BPSEC_H_
+#define _HAVE_DTN_BPSEC_ADM_
+#ifdef _HAVE_DTN_BPSEC_ADM_
+
+#include "shared/utils/nm_types.h"
+#include "shared/adm/adm.h"
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                 ADM TEMPLATE DOCUMENTATION                                  +
+ * +---------------------------------------------------------------------------------------------+
+ *
+ * ADM ROOT STRING:DTN/bpsec
+ */
+#define ADM_ENUM_DTN_BPSEC 10
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                 AGENT NICKNAME DEFINITIONS                                  +
+ * +---------------------------------------------------------------------------------------------+
+ */
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                               DTN_BPSEC META-DATA DEFINITIONS                               +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |name                 |The human-readable name of the ADM.   |STR    |bpsec                   |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |namespace            |The namespace of the ADM.             |STR    |DTN/bpsec               |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |version              |The version of the ADM.               |STR    |v1.0                    |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |organization         |The name of the issuing organization o|       |                        |
+ * |                     |f the ADM.                            |STR    |JHUAPL                  |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ */
+// "name"
+#define DTN_BPSEC_META_NAME 0x00
+// "namespace"
+#define DTN_BPSEC_META_NAMESPACE 0x01
+// "version"
+#define DTN_BPSEC_META_VERSION 0x02
+// "organization"
+#define DTN_BPSEC_META_ORGANIZATION 0x03
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                        DTN_BPSEC EXTERNALLY DEFINED DATA DEFINITIONS                        +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_tx_bcb_blk  |Total successfully Tx Bundle Confident|       |
+ * |                     |iality blocks                         |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_tx_bcb_blk   |Total unsuccessfully Tx Block Confiden|       |
+ * |                     |tiality Block (BCB) blocks            |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_rx_bcb_blk  |Total successfully Rx BCB blocks      |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_rx_bcb_blk   |Total unsuccessfully Rx BCB blocks    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_missing_rx_bcb_bl|Total missing-on-RX BCB blocks        |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fwd_bcb_blks     |Total forward BCB blocks              |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_tx_bcb_bytes|Total successfully Tx BCB bytes       |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_tx_bcb_bytes |Total unsuccessfully Tx BCB bytes     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_tx_bcb_blks  |Total unsuccessfully Tx BCB blocks    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_rx_bcb_bytes|Total successfully Rx BCB bytes       |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_rx_bcb_bytes |Total unsuccessfully Rx BCB bytes     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_missing_rx_bcb_by|Total missing-on-Rx BCB bytes         |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fwd_bcb_bytes    |Total forwarded BCB bytes             |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_tx_bib_blks |Total successfully Tx Block Integrity |       |
+ * |                     |Block (BIB) blocks                    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_tx_bib_blks  |Total unsuccessfully Tx BIB blocks    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_rx_bib_blks |Total successfully Rx BIB blocks      |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_rx_bib_blks  |Total unsuccessfully Rx BIB blocks    |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_miss_rx_bib_blks |Total missing-on-Rx BIB blocks        |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fwd_bib_blks     |Total forwarded BIB blocks            |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_tx_bib_bytes|Total successfully Tx BIB bytes       |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_tx_bib_bytes |Total unsuccessfully Tx BIB bytes     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_rx_bib_bytes|Total successfully Rx BIB bytes       |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_rx_bib_bytes |Total unsuccessfully Rx BIB bytes     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_miss_rx_bib_bytes|Total missing-on-Rx BIB bytes         |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fwd_bib_bytes    |Total forwarded BIB bytes             |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |last_update          |Last BPSEC update                     |TV     |
+ * +---------------------+--------------------------------------+-------+
+ * |num_known_keys       |Number of known keys                  |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |key_names            |Known key names                       |STR    |
+ * +---------------------+--------------------------------------+-------+
+ * |ciphersuite_names    |Known ciphersuite names               |STR    |
+ * +---------------------+--------------------------------------+-------+
+ * |rule_source          |Known rule sources                    |STR    |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_tx_bcb_blks_|Number of successfully Tx BCB blocks f|       |
+ * |                     |rom SRC                               |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_tx_bcb_blks_s|Number of failed TX BCB blocks from SR|       |
+ * |                     |C                                     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_rx_bcb_blks_|Number of successfully Rx BCB blocks f|       |
+ * |                     |rom SRC                               |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_rx_bcb_blks_s|Number of failed RX BCB blocks from SR|       |
+ * |                     |C                                     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_missing_rx_bcb_bl|Number of missing-onRX BCB blocks from|       |
+ * |                     | SRC                                  |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fwd_bcb_blks_src |Number of forwarded BCB blocks from SR|       |
+ * |                     |C                                     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_tx_bcb_bytes|Number of successfully Tx bcb bytes fr|       |
+ * |                     |om SRC                                |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_tx_bcb_bytes_|Number of failed Tx bcb bytes from SRC|UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_rx_bcb_bytes|Number of successfully Rx bcb bytes fr|       |
+ * |                     |om SRC                                |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_rx_bcb_bytes_|Number of failed Rx bcb bytes from SRC|UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_missing_rx_bcb_by|Number of missing-on-Rx bcb bytes from|       |
+ * |                     | SRC                                  |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fwd_bcb_bytes_src|Number of forwarded bcb bytes from SRC|UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_tx_bib_blks_|Number of successfully Tx BIB blocks f|       |
+ * |                     |rom SRC                               |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_tx_bib_blks_s|Number of failed Tx BIB blocks from SR|       |
+ * |                     |C                                     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_rx_bib_blks_|Number of successfully Rx BIB blocks f|       |
+ * |                     |rom SRC                               |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_rx_bib_blks_s|Number of failed Rx BIB blocks from SR|       |
+ * |                     |C                                     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_miss_rx_bib_blks_|Number of missing-on-Rx BIB blocks fro|       |
+ * |                     |m SRC                                 |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fwd_bib_blks_src |Number of forwarded BIB blocks from SR|       |
+ * |                     |C                                     |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_tx_bib_bytes|Number of successfully Tx BIB bytes fr|       |
+ * |                     |om SRC                                |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_tx_bib_bytes_|Number of failed Tx BIB bytes from SRC|UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_good_rx_bib_bytes|Number of successfully Rx BIB bytes fr|       |
+ * |                     |om SRC                                |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_bad_rx_bib_bytes_|Number of failed Rx BIB bytes from SRC|UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_missing_rx_bib_by|Number of missing-on-Rx BIB bytes from|       |
+ * |                     | SRC                                  |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |num_fwd_bib_bytes_src|Number of forwarded BIB bytes from SRC|UINT   |
+ * +---------------------+--------------------------------------+-------+
+ * |last_update_src      |Last BPSEC update from SRC            |TV     |
+ * +---------------------+--------------------------------------+-------+
+ * |last_reset           |Last reset                            |TV     |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLK 0x00
+#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLK 0x01
+#define DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLK 0x02
+#define DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLK 0x03
+#define DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS 0x04
+#define DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS 0x05
+#define DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES 0x06
+#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES 0x07
+#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS 0x08
+#define DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES 0x09
+#define DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES 0x0a
+#define DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES 0x0b
+#define DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES 0x0c
+#define DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS 0x0d
+#define DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS 0x0e
+#define DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS 0x0f
+#define DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS 0x10
+#define DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS 0x11
+#define DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS 0x12
+#define DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES 0x13
+#define DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES 0x14
+#define DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES 0x15
+#define DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES 0x16
+#define DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BYTES 0x17
+#define DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES 0x18
+#define DTN_BPSEC_EDD_LAST_UPDATE 0x19
+#define DTN_BPSEC_EDD_NUM_KNOWN_KEYS 0x1a
+#define DTN_BPSEC_EDD_KEY_NAMES 0x1b
+#define DTN_BPSEC_EDD_CIPHERSUITE_NAMES 0x1c
+#define DTN_BPSEC_EDD_RULE_SOURCE 0x1d
+#define DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BLKS_SRC 0x1e
+#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BLKS_SRC 0x1f
+#define DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BLKS_SRC 0x20
+#define DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BLKS_SRC 0x21
+#define DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BLKS_SRC 0x22
+#define DTN_BPSEC_EDD_NUM_FWD_BCB_BLKS_SRC 0x23
+#define DTN_BPSEC_EDD_NUM_GOOD_TX_BCB_BYTES_SRC 0x24
+#define DTN_BPSEC_EDD_NUM_BAD_TX_BCB_BYTES_SRC 0x25
+#define DTN_BPSEC_EDD_NUM_GOOD_RX_BCB_BYTES_SRC 0x26
+#define DTN_BPSEC_EDD_NUM_BAD_RX_BCB_BYTES_SRC 0x27
+#define DTN_BPSEC_EDD_NUM_MISSING_RX_BCB_BYTES_SRC 0x28
+#define DTN_BPSEC_EDD_NUM_FWD_BCB_BYTES_SRC 0x29
+#define DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BLKS_SRC 0x2a
+#define DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BLKS_SRC 0x2b
+#define DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BLKS_SRC 0x2c
+#define DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BLKS_SRC 0x2d
+#define DTN_BPSEC_EDD_NUM_MISS_RX_BIB_BLKS_SRC 0x2e
+#define DTN_BPSEC_EDD_NUM_FWD_BIB_BLKS_SRC 0x2f
+#define DTN_BPSEC_EDD_NUM_GOOD_TX_BIB_BYTES_SRC 0x30
+#define DTN_BPSEC_EDD_NUM_BAD_TX_BIB_BYTES_SRC 0x31
+#define DTN_BPSEC_EDD_NUM_GOOD_RX_BIB_BYTES_SRC 0x32
+#define DTN_BPSEC_EDD_NUM_BAD_RX_BIB_BYTES_SRC 0x33
+#define DTN_BPSEC_EDD_NUM_MISSING_RX_BIB_BYTES_SRC 0x34
+#define DTN_BPSEC_EDD_NUM_FWD_BIB_BYTES_SRC 0x35
+#define DTN_BPSEC_EDD_LAST_UPDATE_SRC 0x36
+#define DTN_BPSEC_EDD_LAST_RESET 0x37
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                               DTN_BPSEC VARIABLE DEFINITIONS                                +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |total_bad_tx_blks    |This is the number of failed TX blocks|       |
+ * |                     | (# failed BIB + # failed bcb).       |UINT   |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_BPSEC_VAR_TOTAL_BAD_TX_BLKS 0x00
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                DTN_BPSEC REPORT DEFINITIONS                                 +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |full_report          |all known meta-data, externally define|       |
+ * |                     |d data, and variables                 |TNVC   |
+ * +---------------------+--------------------------------------+-------+
+ * |source_report        |security info by source               |TNVC   |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_BPSEC_RPTTPL_FULL_REPORT 0x00
+#define DTN_BPSEC_RPTTPL_SOURCE_REPORT 0x01
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                 DTN_BPSEC TABLE DEFINITIONS                                 +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |keys                 |This table lists all keys in the secur|       |
+ * |                     |ity policy database.                  |       |
+ * +---------------------+--------------------------------------+-------+
+ * |ciphersuites         |This table lists supported ciphersuite|       |
+ * |                     |s.                                    |       |
+ * +---------------------+--------------------------------------+-------+
+ * |bib_rules            |BIB Rules.                            |       |
+ * +---------------------+--------------------------------------+-------+
+ * |bcb_rules            |BCB Rules.                            |       |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_BPSEC_TBLT_KEYS 0x00
+#define DTN_BPSEC_TBLT_CIPHERSUITES 0x01
+#define DTN_BPSEC_TBLT_BIB_RULES 0x02
+#define DTN_BPSEC_TBLT_BCB_RULES 0x03
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                DTN_BPSEC CONTROL DEFINITIONS                                +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |rst_all_cnts         |This control causes the Agent to reset|       |
+ * |                     | all counts associated with block or b|       |
+ * |                     |yte statistics and to set the Last Res|       |
+ * |                     |et Time of the BPsec EDD data to the t|       |
+ * |                     |ime when the control was run.         |       |
+ * +---------------------+--------------------------------------+-------+
+ * |rst_src_cnts         |This control causes the Agent to reset|       |
+ * |                     | all counts (blocks and bytes) associa|       |
+ * |                     |ted with a given bundle source and set|       |
+ * |                     | the Last Reset Time of the source sta|       |
+ * |                     |tistics to the time when the control w|       |
+ * |                     |as run.                               |       |
+ * +---------------------+--------------------------------------+-------+
+ * |delete_key           |This control deletes a key from the BP|       |
+ * |                     |sec system.                           |       |
+ * +---------------------+--------------------------------------+-------+
+ * |add_key              |This control adds a key to the BPsec s|       |
+ * |                     |ystem.                                |       |
+ * +---------------------+--------------------------------------+-------+
+ * |add_bib_rule         |This control configures policy on the |       |
+ * |                     |BPsec protocol implementation that des|       |
+ * |                     |cribes how BIB blocks should be applie|       |
+ * |                     |d to bundles in the system. This polic|       |
+ * |                     |y is captured as a rule which states w|       |
+ * |                     |hen transmitting a bundle from the giv|       |
+ * |                     |en source endpoint ID to the given des|       |
+ * |                     |tination endpoint ID, blocks of type t|       |
+ * |                     |arget should have a BIB added to them |       |
+ * |                     |using the given ciphersuite and the gi|       |
+ * |                     |ven key.                              |       |
+ * +---------------------+--------------------------------------+-------+
+ * |del_bib_rule         |This control removes any configured po|       |
+ * |                     |licy on the BPsec protocol implementat|       |
+ * |                     |ion that describes how BIB blocks shou|       |
+ * |                     |ld be applied to bundles in the system|       |
+ * |                     |. A BIB policy is uniquely identified |       |
+ * |                     |by a source endpoint Id, a destination|       |
+ * |                     | Id, and a target block type.         |       |
+ * +---------------------+--------------------------------------+-------+
+ * |add_bcb_rule         |This control configures policy on the |       |
+ * |                     |BPsec protocol implementation that des|       |
+ * |                     |cribes how BCB blocks should be applie|       |
+ * |                     |d to bundles in the system. This polic|       |
+ * |                     |y is captured as a rule which states w|       |
+ * |                     |hen transmitting a bundle from the giv|       |
+ * |                     |en source endpoint id to the given des|       |
+ * |                     |tination endpoint id, blocks of type t|       |
+ * |                     |arget should have a bcb added to them |       |
+ * |                     |using the given ciphersuite and the gi|       |
+ * |                     |ven key.                              |       |
+ * +---------------------+--------------------------------------+-------+
+ * |del_bcb_rule         |This control removes any configured po|       |
+ * |                     |licy on the BPsec protocol implementat|       |
+ * |                     |ion that describes how BCB blocks shou|       |
+ * |                     |ld be applied to bundles in the system|       |
+ * |                     |. A bcb policy is uniquely identified |       |
+ * |                     |by a source endpoint id, a destination|       |
+ * |                     | endpoint id, and a target block type.|       |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_BPSEC_CTRL_RST_ALL_CNTS 0x00
+#define DTN_BPSEC_CTRL_RST_SRC_CNTS 0x01
+#define DTN_BPSEC_CTRL_DELETE_KEY 0x02
+#define DTN_BPSEC_CTRL_ADD_KEY 0x03
+#define DTN_BPSEC_CTRL_ADD_BIB_RULE 0x04
+#define DTN_BPSEC_CTRL_DEL_BIB_RULE 0x05
+#define DTN_BPSEC_CTRL_ADD_BCB_RULE 0x06
+#define DTN_BPSEC_CTRL_DEL_BCB_RULE 0x07
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                               DTN_BPSEC CONSTANT DEFINITIONS                                +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                 DTN_BPSEC MACRO DEFINITIONS                                 +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                               DTN_BPSEC OPERATOR DEFINITIONS                                +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+/* Initialization functions. */
+void dtn_bpsec_init();
+void dtn_bpsec_init_meta();
+void dtn_bpsec_init_cnst();
+void dtn_bpsec_init_edd();
+void dtn_bpsec_init_op();
+void dtn_bpsec_init_var();
+void dtn_bpsec_init_ctrl();
+void dtn_bpsec_init_mac();
+void dtn_bpsec_init_rpttpl();
+void dtn_bpsec_init_tblt();
+#endif /* _HAVE_DTN_BPSEC_ADM_ */
+#endif //ADM_BPSEC_H_
\ No newline at end of file
diff -ru --new-file ion-sf/bpv7/nm/shared/adm/adm_ion_bp_admin.h ion-anms/bpv7/nm/shared/adm/adm_ion_bp_admin.h
--- ion-sf/bpv7/nm/shared/adm/adm_ion_bp_admin.h	1969-12-31 19:00:00.000000000 -0500
+++ ion-anms/bpv7/nm/shared/adm/adm_ion_bp_admin.h	2023-05-15 12:59:40.881870457 -0400
@@ -0,0 +1,443 @@
+/****************************************************************************
+ **
+ ** File Name: adm_ion_bp_admin.h
+ **
+ ** Description: TODO
+ **
+ ** Notes: TODO
+ **
+ ** Assumptions: TODO
+ **
+ ** Modification History:
+ **  YYYY-MM-DD  AUTHOR           DESCRIPTION
+ **  ----------  --------------   --------------------------------------------
+ **  2023-04-12  AUTO             Auto-generated header file
+ **
+ ****************************************************************************/
+
+
+#ifndef ADM_ION_BP_ADMIN_H_
+#define ADM_ION_BP_ADMIN_H_
+#define _HAVE_DTN_ION_BPADMIN_ADM_
+#ifdef _HAVE_DTN_ION_BPADMIN_ADM_
+
+#include "shared/utils/nm_types.h"
+#include "shared/adm/adm.h"
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                 ADM TEMPLATE DOCUMENTATION                                  +
+ * +---------------------------------------------------------------------------------------------+
+ *
+ * ADM ROOT STRING:dtn_ion_bpadmin
+ */
+extern vec_idx_t g_dtn_ion_bpadmin_idx[11];
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                                 AGENT NICKNAME DEFINITIONS                                  +
+ * +---------------------------------------------------------------------------------------------+
+ */
+#define ADM_ENUM_DTN_ION_BPADMIN 5
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                            DTN_ION_BPADMIN META-DATA DEFINITIONS                            +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |name                 |The human-readable name of the ADM.   |STR    |ion_bp_admin            |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |enum                 |                                      |INT    |5                       |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |namespace            |The namespace of the ADM              |STR    |DTN/ION/bpadmin         |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |version              |The version of the ADM                |STR    |v0.0                    |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ * |organization         |The name of the issuing organization o|       |                        |
+ * |                     |f the ADM                             |STR    |JHUAPL                  |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ */
+// "name"
+#define DTN_ION_BPADMIN_META_NAME 0x00
+// "enum"
+#define DTN_ION_BPADMIN_META_ENUM 0x01
+// "namespace"
+#define DTN_ION_BPADMIN_META_NAMESPACE 0x02
+// "version"
+#define DTN_ION_BPADMIN_META_VERSION 0x03
+// "organization"
+#define DTN_ION_BPADMIN_META_ORGANIZATION 0x04
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                     DTN_ION_BPADMIN EXTERNALLY DEFINED DATA DEFINITIONS                     +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |bp_version           |Version of installed ION BP Admin util|       |
+ * |                     |ity.                                  |STR    |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_ION_BPADMIN_EDD_BP_VERSION 0x00
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                            DTN_ION_BPADMIN VARIABLE DEFINITIONS                             +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                             DTN_ION_BPADMIN REPORT DEFINITIONS                              +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                              DTN_ION_BPADMIN TABLE DEFINITIONS                              +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |endpoints            |Local endpoints, regardless of scheme |       |
+ * |                     |name.                                 |       |
+ * +---------------------+--------------------------------------+-------+
+ * |inducts              |Inducts established locally for the in|       |
+ * |                     |dicated CL protocol.                  |       |
+ * +---------------------+--------------------------------------+-------+
+ * |outducts             |If protocolName is specified, this tab|       |
+ * |                     |le lists all outducts established loca|       |
+ * |                     |lly for the indicated CL protocol. Oth|       |
+ * |                     |erwise, it lists all locally establish|       |
+ * |                     |ed outducts, regardless of their proto|       |
+ * |                     |col.                                  |       |
+ * +---------------------+--------------------------------------+-------+
+ * |protocols            |Convergence layer protocols that can c|       |
+ * |                     |urrently be utilized at the local node|       |
+ * |                     |.                                     |       |
+ * +---------------------+--------------------------------------+-------+
+ * |schemes              |Declared endpoint naming schemes.     |       |
+ * +---------------------+--------------------------------------+-------+
+ * |egress_plans         |Egress plans.                         |       |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_ION_BPADMIN_TBLT_ENDPOINTS 0x00
+#define DTN_ION_BPADMIN_TBLT_INDUCTS 0x01
+#define DTN_ION_BPADMIN_TBLT_OUTDUCTS 0x02
+#define DTN_ION_BPADMIN_TBLT_PROTOCOLS 0x03
+#define DTN_ION_BPADMIN_TBLT_SCHEMES 0x04
+#define DTN_ION_BPADMIN_TBLT_EGRESS_PLANS 0x05
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                             DTN_ION_BPADMIN CONTROL DEFINITIONS                             +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ * |endpoint_add         |Establish DTN endpoint named endpointI|       |
+ * |                     |d on the local node. The remaining par|       |
+ * |                     |ameters indicate what is to be done wh|       |
+ * |                     |en bundles destined for this endpoint |       |
+ * |                     |arrive at a time when no application h|       |
+ * |                     |as the endpoint open for bundle recept|       |
+ * |                     |ion. If type is 'x', then such bundles|       |
+ * |                     | are to be discarded silently and imme|       |
+ * |                     |diately. If type is 'q', then such bun|       |
+ * |                     |dles are to be enqueued for later deli|       |
+ * |                     |very and, if recvScript is provided, r|       |
+ * |                     |ecvScript is to be executed.          |       |
+ * +---------------------+--------------------------------------+-------+
+ * |endpoint_change      |Change the action taken when bundles d|       |
+ * |                     |estined for this endpoint arrive at a |       |
+ * |                     |time when no application has the endpo|       |
+ * |                     |int open for bundle reception.        |       |
+ * +---------------------+--------------------------------------+-------+
+ * |endpoint_del         |Delete the endpoint identified by endp|       |
+ * |                     |ointId. The control will fail if any b|       |
+ * |                     |undles are currently pending delivery |       |
+ * |                     |to this endpoint.                     |       |
+ * +---------------------+--------------------------------------+-------+
+ * |induct_add           |Establish a duct for reception of bund|       |
+ * |                     |les via the indicated CL protocol. The|       |
+ * |                     | duct's data acquisition structure is |       |
+ * |                     |used and populated by the induct task |       |
+ * |                     |whose operation is initiated by cliCon|       |
+ * |                     |trol at the time the duct is started. |       |
+ * +---------------------+--------------------------------------+-------+
+ * |induct_change        |Change the control used to initiate op|       |
+ * |                     |eration of the induct task for the ind|       |
+ * |                     |icated duct.                          |       |
+ * +---------------------+--------------------------------------+-------+
+ * |induct_del           |Delete the induct identified by protoc|       |
+ * |                     |olName and ductName. The control will |       |
+ * |                     |fail if any bundles are currently pend|       |
+ * |                     |ing acquisition via this induct.      |       |
+ * +---------------------+--------------------------------------+-------+
+ * |induct_start         |Start the indicated induct task as def|       |
+ * |                     |ined for the indicated CL protocol on |       |
+ * |                     |the local node.                       |       |
+ * +---------------------+--------------------------------------+-------+
+ * |induct_stop          |Stop the indicated induct task as defi|       |
+ * |                     |ned for the indicated CL protocol on t|       |
+ * |                     |he local node.                        |       |
+ * +---------------------+--------------------------------------+-------+
+ * |manage_heap_max      |Declare the maximum number of bytes of|       |
+ * |                     | SDR heap space that will be occupied |       |
+ * |                     |by any single bundle acquisition activ|       |
+ * |                     |ity (nominally the acquisition of a si|       |
+ * |                     |ngle bundle, but this is at the discre|       |
+ * |                     |tion of the convergence-layer input ta|       |
+ * |                     |sk). All data acquired in excess of th|       |
+ * |                     |is limit will be written to a temporar|       |
+ * |                     |y file pending extraction and dispatch|       |
+ * |                     |ing of the acquired bundle or bundles.|       |
+ * |                     | The default is the minimum allowed va|       |
+ * |                     |lue (560 bytes), which is the approxim|       |
+ * |                     |ate size of a ZCO file reference objec|       |
+ * |                     |t; this is the minimum SDR heap space |       |
+ * |                     |occupancy in the event that all acquis|       |
+ * |                     |ition is into a file.                 |       |
+ * +---------------------+--------------------------------------+-------+
+ * |outduct_add          |Establish a duct for transmission of b|       |
+ * |                     |undles via the indicated CL protocol. |       |
+ * |                     |the duct's data transmission structure|       |
+ * |                     | is serviced by the outduct task whose|       |
+ * |                     | operation is initiated by CLOcommand |       |
+ * |                     |at the time the duct is started. A val|       |
+ * |                     |ue of zero for maxPayloadLength indica|       |
+ * |                     |tes that bundles of any size can be ac|       |
+ * |                     |comodated; this is the default.       |       |
+ * +---------------------+--------------------------------------+-------+
+ * |outduct_change       |Set new values for the indicated duct'|       |
+ * |                     |s payload size limit and the control t|       |
+ * |                     |hat is used to initiate operation of t|       |
+ * |                     |he outduct task for this duct.        |       |
+ * +---------------------+--------------------------------------+-------+
+ * |outduct_del          |Delete the outduct identified by proto|       |
+ * |                     |colName and ductName. The control will|       |
+ * |                     | fail if any bundles are currently pen|       |
+ * |                     |ding transmission via this outduct.   |       |
+ * +---------------------+--------------------------------------+-------+
+ * |outduct_start        |Start the indicated outduct task as de|       |
+ * |                     |fined for the indicated CL protocol on|       |
+ * |                     | the local node.                      |       |
+ * +---------------------+--------------------------------------+-------+
+ * |outduct_stop         |Stop the indicated outduct task as def|       |
+ * |                     |ined for the indicated CL protocol on |       |
+ * |                     |the local node.                       |       |
+ * +---------------------+--------------------------------------+-------+
+ * |egress_plan_add      |Add an egress plan for a specific peer|       |
+ * |                     | and outduct.                         |       |
+ * +---------------------+--------------------------------------+-------+
+ * |egress_plan_del      |Remove an egress plan for a specific p|       |
+ * |                     |eer and outduct.                      |       |
+ * +---------------------+--------------------------------------+-------+
+ * |egress_plan_start    |Start the indicated egress plan task. |       |
+ * +---------------------+--------------------------------------+-------+
+ * |egress_plan_stop     |Stop the indicated egress plan task.  |       |
+ * +---------------------+--------------------------------------+-------+
+ * |egress_plan_block    |Disable transmission of bundles queued|       |
+ * |                     | for transmission to the indicated nod|       |
+ * |                     |e and reforwards all non-critical bund|       |
+ * |                     |les currently queued for transmission |       |
+ * |                     |to this node. This may result in some |       |
+ * |                     |or all of these bundles being enqueued|       |
+ * |                     | for transmission to the psuedo-node l|       |
+ * |                     |imbo.                                 |       |
+ * +---------------------+--------------------------------------+-------+
+ * |egress_plan_unblock  |Re-enable transmission of bundles to t|       |
+ * |                     |he indicated node and reforwards all b|       |
+ * |                     |undles in limbo in the hope that the u|       |
+ * |                     |nblocking of this egress plan will ena|       |
+ * |                     |ble some of them to be transmitted.   |       |
+ * +---------------------+--------------------------------------+-------+
+ * |protocol_add         |Establish access to the named converge|       |
+ * |                     |nce layer protocol at the local node. |       |
+ * |                     |The payloadBytesPerFrame and overheadB|       |
+ * |                     |ytesPerFrame arguments are used in cal|       |
+ * |                     |culating the estimated transmission ca|       |
+ * |                     |pacity consumption of each bundle, to |       |
+ * |                     |aid in route computation and congestin|       |
+ * |                     |g forecasting. The optional nominalDat|       |
+ * |                     |aRate argument overrides the hard code|       |
+ * |                     |d default continuous data rate for the|       |
+ * |                     | indicated protocol for purposes of ra|       |
+ * |                     |te control. For all promiscuous protot|       |
+ * |                     |ocols-that is, protocols whose outduct|       |
+ * |                     |s are not specifically dedicated to tr|       |
+ * |                     |ansmission to a single identified conv|       |
+ * |                     |ergence-layer protocol endpoint- the p|       |
+ * |                     |rotocol's applicable nominal continuou|       |
+ * |                     |s data rate is the data rate that is a|       |
+ * |                     |lways used for rate control over links|       |
+ * |                     | served by that protocol; data rates a|       |
+ * |                     |re not extracted from contact graph in|       |
+ * |                     |formation. This is because only the in|       |
+ * |                     |duct and outduct throttles for non-pro|       |
+ * |                     |miscuous protocols (LTP, TCP) can be d|       |
+ * |                     |ynamically adjusted in response to cha|       |
+ * |                     |nges in data rate between the local no|       |
+ * |                     |de and its neighbors, as enacted per t|       |
+ * |                     |he contact plan. Even for an outduct o|       |
+ * |                     |f a non-promiscuous protocol the nomin|       |
+ * |                     |al data rate may be the authority for |       |
+ * |                     |rate control, in the event that the co|       |
+ * |                     |ntact plan lacks identified contacts w|       |
+ * |                     |ith the node to which the outduct is m|       |
+ * |                     |apped.                                |       |
+ * +---------------------+--------------------------------------+-------+
+ * |protocol_del         |Delete the convergence layer protocol |       |
+ * |                     |identified by protocolName. The contro|       |
+ * |                     |l will fail if any ducts are still loc|       |
+ * |                     |ally declared for this protocol.      |       |
+ * +---------------------+--------------------------------------+-------+
+ * |protocol_start       |Start all induct and outduct tasks for|       |
+ * |                     | inducts and outducts that have been d|       |
+ * |                     |efined for the indicated CL protocol o|       |
+ * |                     |n the local node.                     |       |
+ * +---------------------+--------------------------------------+-------+
+ * |protocol_stop        |Stop all induct and outduct tasks for |       |
+ * |                     |inducts and outducts that have been de|       |
+ * |                     |fined for the indicated CL protocol on|       |
+ * |                     | the local node.                      |       |
+ * +---------------------+--------------------------------------+-------+
+ * |scheme_add           |Declares an endpoint naming scheme for|       |
+ * |                     | use in endpoint IDs, which are struct|       |
+ * |                     |ured as URIs: schemeName:schemeSpecifi|       |
+ * |                     |cPart. forwarderControl will be execut|       |
+ * |                     |ed when the scheme is started on this |       |
+ * |                     |node, to initiate operation of a forwa|       |
+ * |                     |rding daemon for this scheme. adminApp|       |
+ * |                     |Control will also be executed when the|       |
+ * |                     | scheme is started on this node, to in|       |
+ * |                     |itiate operation of a daemon that open|       |
+ * |                     |s a custodian endpoint identified with|       |
+ * |                     |in this scheme so that it can recieve |       |
+ * |                     |and process custody signals and bundle|       |
+ * |                     | status reports.                      |       |
+ * +---------------------+--------------------------------------+-------+
+ * |scheme_change        |Set the indicated scheme's forwarderCo|       |
+ * |                     |ntrol and adminAppControl to the strin|       |
+ * |                     |gs provided as arguments.             |       |
+ * +---------------------+--------------------------------------+-------+
+ * |scheme_del           |Delete the scheme identified by scheme|       |
+ * |                     |Name. The control will fail if any bun|       |
+ * |                     |dles identified in this scheme are pen|       |
+ * |                     |ding forwarding, transmission, or deli|       |
+ * |                     |very.                                 |       |
+ * +---------------------+--------------------------------------+-------+
+ * |scheme_start         |Start the forwarder and administrative|       |
+ * |                     | endpoint tasks for the indicated sche|       |
+ * |                     |me task on the local node.            |       |
+ * +---------------------+--------------------------------------+-------+
+ * |scheme_stop          |Stop the forwarder and administrative |       |
+ * |                     |endpoint tasks for the indicated schem|       |
+ * |                     |e task on the local node.             |       |
+ * +---------------------+--------------------------------------+-------+
+ * |watch                |Enable/Disable production of a continu|       |
+ * |                     |ous stream of user selected Bundle Pro|       |
+ * |                     |tocol activity indication characters. |       |
+ * |                     |A watch parameter of 1 selects all BP |       |
+ * |                     |activity indication characters, 0 dese|       |
+ * |                     |lects allBP activity indication charac|       |
+ * |                     |ters; any other activitySpec such as a|       |
+ * |                     |cz~ selects all activity indication ch|       |
+ * |                     |aracters in the string, deselecting al|       |
+ * |                     |l others. BP will print each selected |       |
+ * |                     |activity indication character to stdou|       |
+ * |                     |t every time a processing event of the|       |
+ * |                     | associated type occurs: a new bundle |       |
+ * |                     |is queued for forwarding, b bundle is |       |
+ * |                     |queued for transmission, c bundle is p|       |
+ * |                     |opped from its transmission queue, m c|       |
+ * |                     |ustody acceptance signal is recieved, |       |
+ * |                     |w custody of bundle is accepted, x cus|       |
+ * |                     |tody of bundle is refused, y bundle is|       |
+ * |                     | accepted upon arrival, z bundle is qu|       |
+ * |                     |eued for delivery to an application, ~|       |
+ * |                     | bundle is abandoned (discarded) on at|       |
+ * |                     |tempt to forward it, ! bundle is destr|       |
+ * |                     |oyed due to TTL expiration, &amp; cust|       |
+ * |                     |ody refusal signal is recieved, # bund|       |
+ * |                     |le is queued for re-forwarding due to |       |
+ * |                     |CL protocol failures, j bundle is plac|       |
+ * |                     |ed in 'limbo' for possible future refo|       |
+ * |                     |rwarding, k bundle is removed from 'li|       |
+ * |                     |mbo' and queued for reforwarding, $ bu|       |
+ * |                     |ndle's custodial retransmission timeou|       |
+ * |                     |t interval expired.                   |       |
+ * +---------------------+--------------------------------------+-------+
+ */
+#define DTN_ION_BPADMIN_CTRL_ENDPOINT_ADD 0x00
+#define DTN_ION_BPADMIN_CTRL_ENDPOINT_CHANGE 0x01
+#define DTN_ION_BPADMIN_CTRL_ENDPOINT_DEL 0x02
+#define DTN_ION_BPADMIN_CTRL_INDUCT_ADD 0x03
+#define DTN_ION_BPADMIN_CTRL_INDUCT_CHANGE 0x04
+#define DTN_ION_BPADMIN_CTRL_INDUCT_DEL 0x05
+#define DTN_ION_BPADMIN_CTRL_INDUCT_START 0x06
+#define DTN_ION_BPADMIN_CTRL_INDUCT_STOP 0x07
+#define DTN_ION_BPADMIN_CTRL_MANAGE_HEAP_MAX 0x08
+#define DTN_ION_BPADMIN_CTRL_OUTDUCT_ADD 0x09
+#define DTN_ION_BPADMIN_CTRL_OUTDUCT_CHANGE 0x0a
+#define DTN_ION_BPADMIN_CTRL_OUTDUCT_DEL 0x0b
+#define DTN_ION_BPADMIN_CTRL_OUTDUCT_START 0x0c
+#define DTN_ION_BPADMIN_CTRL_OUTDUCT_STOP 0x0d
+#define DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_ADD 0x0e
+#define DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_DEL 0x0f
+#define DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_START 0x10
+#define DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_STOP 0x11
+#define DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_BLOCK 0x12
+#define DTN_ION_BPADMIN_CTRL_EGRESS_PLAN_UNBLOCK 0x13
+#define DTN_ION_BPADMIN_CTRL_PROTOCOL_ADD 0x14
+#define DTN_ION_BPADMIN_CTRL_PROTOCOL_DEL 0x15
+#define DTN_ION_BPADMIN_CTRL_PROTOCOL_START 0x16
+#define DTN_ION_BPADMIN_CTRL_PROTOCOL_STOP 0x17
+#define DTN_ION_BPADMIN_CTRL_SCHEME_ADD 0x18
+#define DTN_ION_BPADMIN_CTRL_SCHEME_CHANGE 0x19
+#define DTN_ION_BPADMIN_CTRL_SCHEME_DEL 0x1a
+#define DTN_ION_BPADMIN_CTRL_SCHEME_START 0x1b
+#define DTN_ION_BPADMIN_CTRL_SCHEME_STOP 0x1c
+#define DTN_ION_BPADMIN_CTRL_WATCH 0x1d
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                            DTN_ION_BPADMIN CONSTANT DEFINITIONS                             +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
+ * +---------------------+--------------------------------------+-------+------------------------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                              DTN_ION_BPADMIN MACRO DEFINITIONS                              +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+
+/*
+ * +---------------------------------------------------------------------------------------------+
+ * |                            DTN_ION_BPADMIN OPERATOR DEFINITIONS                             +
+ * +---------------------------------------------------------------------------------------------+
+ * |        NAME         |             DESCRIPTION              | TYPE  |
+ * +---------------------+--------------------------------------+-------+
+ */
+
+/* Initialization functions. */
+void dtn_ion_bpadmin_init();
+
+#endif /* _HAVE_DTN_ION_BPADMIN_ADM_ */
+#endif // ADM_ION_BP_ADMIN_H_
diff -ru --new-file ion-sf/nm/doc/adms/amp_agent.json ion-anms/nm/doc/adms/amp_agent.json
--- ion-sf/nm/doc/adms/amp_agent.json	2023-05-30 10:55:36.785113220 -0400
+++ ion-anms/nm/doc/adms/amp_agent.json	2023-05-15 12:59:40.909870718 -0400
@@ -6,6 +6,11 @@
       "description": "The human-readable name of the ADM."
     },
     {
+      "name": "enum",
+      "type": "INT",
+      "value": 1
+    },
+    {
       "name": "namespace",
       "type": "STR",
       "value": "Amp/Agent",
diff -ru --new-file ion-sf/nm/doc/adms/bp_agent.json ion-anms/nm/doc/adms/bp_agent.json
--- ion-sf/nm/doc/adms/bp_agent.json	2023-05-30 10:55:36.785113220 -0400
+++ ion-anms/nm/doc/adms/bp_agent.json	2023-05-15 12:59:40.913870755 -0400
@@ -6,6 +6,11 @@
       "description": "The human-readable name of the ADM."
     },
     {
+      "name": "enum",
+      "type": "INT",
+      "value": 2
+    },
+    {
       "name": "namespace",
       "type": "STR",
       "value": "DTN/bp_agent",
diff -ru --new-file ion-sf/nm/doc/adms/ion_admin.json ion-anms/nm/doc/adms/ion_admin.json
--- ion-sf/nm/doc/adms/ion_admin.json	2023-05-30 10:55:36.785113220 -0400
+++ ion-anms/nm/doc/adms/ion_admin.json	2023-05-15 12:59:40.957871164 -0400
@@ -6,6 +6,11 @@
       "description": "The human-readable name of the ADM."
     },
     {
+      "name": "enum",
+      "type": "INT",
+      "value": 7
+    },
+    {
       "name": "namespace",
       "type": "STR",
       "value": "DTN/ION/ionadmin",
diff -ru --new-file ion-sf/nm/doc/adms/ion_bp_admin.json ion-anms/nm/doc/adms/ion_bp_admin.json
--- ion-sf/nm/doc/adms/ion_bp_admin.json	2023-05-30 10:55:36.785113220 -0400
+++ ion-anms/nm/doc/adms/ion_bp_admin.json	2023-05-15 12:59:40.961871201 -0400
@@ -6,6 +6,11 @@
       "description": "The human-readable name of the ADM."
     },
     {
+      "name": "enum",
+      "type": "INT",
+      "value": 5
+    },
+    {
       "name": "namespace",
       "type": "STR",
       "value": "DTN/ION/bpadmin",
@@ -297,31 +302,78 @@
       "description": "Start the indicated outduct task as defined for the indicated CL protocol on the local node."
     },
     {
-      "name": "egress_plan_block",
+      "name": "outduct_stop",
       "parmspec": [{
         "type": "STR",
-        "name": "plan_name"
+        "name": "protocol_name"
+      }, {
+        "type": "STR",
+        "name": "duct_name"
       }],
-      "description": "Disable transmission of bundles queued for transmission to the indicated node and reforwards all non-critical bundles currently queued for transmission to this node. This may result in some or all of these bundles being enqueued for transmission to the psuedo-node limbo."
+      "description": "Stop the indicated outduct task as defined for the indicated CL protocol on the local node."
     },
     {
-      "name": "egress_plan_unblock",
+      "name": "egress_plan_add",
       "parmspec": [{
         "type": "STR",
-        "name": "plan_name"
+        "name": "neighbor_eid"
+      }, {
+        "type": "STR",
+        "name": "protocol_name"
+      }, {
+        "type": "STR",
+        "name": "duct_name"
       }],
-      "description": "Re-enable transmission of bundles to the indicated node and reforwards all bundles in limbo in the hope that the unblocking of this egress plan will enable some of them to be transmitted."
+      "description": "Add an egress plan for a specific peer and outduct."
     },
     {
-      "name": "outduct_stop",
+      "name": "egress_plan_del",
       "parmspec": [{
         "type": "STR",
-        "name": "protocol_name"
+        "name": "neighbor_eid"
       }, {
         "type": "STR",
         "name": "duct_name"
       }],
-      "description": "Stop the indicated outduct task as defined for the indicated CL protocol on the local node."
+      "description": "Remove an egress plan for a specific peer and outduct."
+    },
+    {
+      "name": "egress_plan_start",
+      "parmspec": [{
+        "type": "STR",
+        "name": "neighbor_eid"
+      }, {
+        "type": "STR",
+        "name": "duct_name"
+      }],
+      "description": "Start the indicated egress plan task."
+    },
+    {
+      "name": "egress_plan_stop",
+      "parmspec": [{
+        "type": "STR",
+        "name": "neighbor_eid"
+      }, {
+        "type": "STR",
+        "name": "duct_name"
+      }],
+      "description": "Stop the indicated egress plan task."
+    },
+    {
+      "name": "egress_plan_block",
+      "parmspec": [{
+        "type": "STR",
+        "name": "neighbor_eid"
+      }],
+      "description": "Disable transmission of bundles queued for transmission to the indicated node and reforwards all non-critical bundles currently queued for transmission to this node. This may result in some or all of these bundles being enqueued for transmission to the psuedo-node limbo."
+    },
+    {
+      "name": "egress_plan_unblock",
+      "parmspec": [{
+        "type": "STR",
+        "name": "neighbor_eid"
+      }],
+      "description": "Re-enable transmission of bundles to the indicated node and reforwards all bundles in limbo in the hope that the unblocking of this egress plan will enable some of them to be transmitted."
     },
     {
       "name": "protocol_add",
diff -ru --new-file ion-sf/nm/doc/adms/ion_bpsec_admin.json ion-anms/nm/doc/adms/ion_bpsec_admin.json
--- ion-sf/nm/doc/adms/ion_bpsec_admin.json	2023-05-30 10:55:36.793113323 -0400
+++ ion-anms/nm/doc/adms/ion_bpsec_admin.json	2023-05-15 12:59:40.969871275 -0400
@@ -8,9 +8,14 @@
       "description": "The human-readable name of the ADM."
     },
     {
+      "name": "enum",
+      "type": "INT",
+      "value": 10
+    },
+    {
       "name": "namespace",
       "type": "STR",
-      "value": "DTN:BundleProtocolSecurity",
+      "value": "DTN/bpsec",
       "description": "The namespace of the ADM."
     },
     {
diff -ru --new-file ion-sf/nm/doc/adms/ion_ionsec_admin.json ion-anms/nm/doc/adms/ion_ionsec_admin.json
--- ion-sf/nm/doc/adms/ion_ionsec_admin.json	2023-05-30 10:55:36.793113323 -0400
+++ ion-anms/nm/doc/adms/ion_ionsec_admin.json	2023-05-15 12:59:41.001871573 -0400
@@ -6,6 +6,11 @@
       "description": "The human-readable name of the ADM."
     },
     {
+      "name": "enum",
+      "type": "INT",
+      "value": 8
+    },
+    {
       "name": "namespace",
       "type": "STR",
       "value": "DTN/ION/ionsecadmin",
diff -ru --new-file ion-sf/nm/doc/adms/ion_ipn_admin.json ion-anms/nm/doc/adms/ion_ipn_admin.json
--- ion-sf/nm/doc/adms/ion_ipn_admin.json	2023-05-30 10:55:36.793113323 -0400
+++ ion-anms/nm/doc/adms/ion_ipn_admin.json	2023-05-15 12:59:41.001871573 -0400
@@ -6,6 +6,11 @@
       "description": "The human-readable name of the ADM."
     },
     {
+      "name": "enum",
+      "type": "INT",
+      "value": 6
+    },
+    {
       "name": "namespace",
       "type": "STR",
       "value": "DTN/ION/ipnadmin",
diff -ru --new-file ion-sf/nm/doc/adms/ion_ltp_admin.json ion-anms/nm/doc/adms/ion_ltp_admin.json
--- ion-sf/nm/doc/adms/ion_ltp_admin.json	2023-05-30 10:55:36.793113323 -0400
+++ ion-anms/nm/doc/adms/ion_ltp_admin.json	2023-05-15 12:59:41.005871610 -0400
@@ -6,6 +6,11 @@
       "description": "The human-readable name of the ADM."
     },
     {
+      "name": "enum",
+      "type": "INT",
+      "value": 9
+    },
+    {
       "name": "namespace",
       "type": "STR",
       "value": "DTN/ION/ltpadmin",
diff -ru --new-file ion-sf/nm/doc/adms/ltp_agent.json ion-anms/nm/doc/adms/ltp_agent.json
--- ion-sf/nm/doc/adms/ltp_agent.json	2023-05-30 10:55:36.793113323 -0400
+++ ion-anms/nm/doc/adms/ltp_agent.json	2023-05-15 12:59:41.017871722 -0400
@@ -6,6 +6,11 @@
       "description": "The human-readable name of the ADM."
     },
     {
+      "name": "enum",
+      "type": "INT",
+      "value": 3
+    },
+    {
       "name": "namespace",
       "type": "STR",
       "value": "DTN/ltp_agent",
