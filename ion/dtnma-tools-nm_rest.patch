diff --git a/nm/agent/adm_amp_agent_agent.c b/nm/agent/adm_amp_agent_agent.c
deleted file mode 100644
index 602371b2..00000000
--- a/nm/agent/adm_amp_agent_agent.c
+++ /dev/null
@@ -1,265 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_amp_agent_agent.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-16  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_amp_agent.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "adm_amp_agent_impl.h"
-#include "agent/rda.h"
-
-
-
-#define _HAVE_AMP_AGENT_ADM_
-#ifdef _HAVE_AMP_AGENT_ADM_
-
-//vec_idx_t g_amp_agent_idx[11];
-
-void amp_agent_init()
-{
-	adm_add_adm_info("amp_agent", ADM_ENUM_AMP_AGENT);
-
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_OPER_IDX), &(g_amp_agent_idx[ADM_OPER_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_RPTT_IDX), &(g_amp_agent_idx[ADM_RPTT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_CONST_IDX), &(g_amp_agent_idx[ADM_CONST_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_EDD_IDX), &(g_amp_agent_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_CTRL_IDX), &(g_amp_agent_idx[ADM_CTRL_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_META_IDX), &(g_amp_agent_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_TBLT_IDX), &(g_amp_agent_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_VAR_IDX), &(g_amp_agent_idx[ADM_VAR_IDX]));
-
-
-	amp_agent_setup();
-	amp_agent_init_meta();
-	amp_agent_init_cnst();
-	amp_agent_init_edd();
-	amp_agent_init_op();
-	amp_agent_init_var();
-	amp_agent_init_ctrl();
-	amp_agent_init_mac();
-	amp_agent_init_rpttpl();
-	amp_agent_init_tblt();
-}
-
-void amp_agent_init_meta()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_NAME), amp_agent_meta_name);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_NAMESPACE), amp_agent_meta_namespace);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_VERSION), amp_agent_meta_version);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_ORGANIZATION), amp_agent_meta_organization);
-}
-
-void amp_agent_init_cnst()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_CONST_IDX], AMP_AGENT_CNST_AMP_EPOCH), amp_agent_get_amp_epoch);
-}
-
-void amp_agent_init_edd()
-{
-
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_RPT_TPLS), amp_agent_get_num_rpt_tpls);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBL_TPLS), amp_agent_get_num_tbl_tpls);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_SENT_REPORTS), amp_agent_get_sent_reports);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBR), amp_agent_get_num_tbr);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_TBR), amp_agent_get_run_tbr);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_SBR), amp_agent_get_num_sbr);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_SBR), amp_agent_get_run_sbr);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_CONST), amp_agent_get_num_const);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_VAR), amp_agent_get_num_var);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_MACROS), amp_agent_get_num_macros);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_MACROS), amp_agent_get_run_macros);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_CONTROLS), amp_agent_get_num_controls);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_CONTROLS), amp_agent_get_run_controls);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_CUR_TIME), amp_agent_get_cur_time);
-}
-
-void amp_agent_init_op()
-{
-
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSINT, 2, amp_agent_op_plusint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUINT, 2, amp_agent_op_plusuint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSVAST, 2, amp_agent_op_plusvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUVAST, 2, amp_agent_op_plusuvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSREAL32, 2, amp_agent_op_plusreal32);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSREAL64, 2, amp_agent_op_plusreal64);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSINT, 2, amp_agent_op_minusint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSUINT, 2, amp_agent_op_minusuint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSVAST, 2, amp_agent_op_minusvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSUVAST, 2, amp_agent_op_minusuvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSREAL32, 2, amp_agent_op_minusreal32);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSREAL64, 2, amp_agent_op_minusreal64);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTINT, 2, amp_agent_op_multint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTUINT, 2, amp_agent_op_multuint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTVAST, 2, amp_agent_op_multvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTUVAST, 2, amp_agent_op_multuvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTREAL32, 2, amp_agent_op_multreal32);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTREAL64, 2, amp_agent_op_multreal64);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVINT, 2, amp_agent_op_divint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVUINT, 2, amp_agent_op_divuint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVVAST, 2, amp_agent_op_divvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVUVAST, 2, amp_agent_op_divuvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVREAL32, 2, amp_agent_op_divreal32);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVREAL64, 2, amp_agent_op_divreal64);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODINT, 2, amp_agent_op_modint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODUINT, 2, amp_agent_op_moduint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODVAST, 2, amp_agent_op_modvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODUVAST, 2, amp_agent_op_moduvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODREAL32, 2, amp_agent_op_modreal32);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODREAL64, 2, amp_agent_op_modreal64);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPINT, 2, amp_agent_op_expint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPUINT, 2, amp_agent_op_expuint);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPVAST, 2, amp_agent_op_expvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPUVAST, 2, amp_agent_op_expuvast);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPREAL32, 2, amp_agent_op_expreal32);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPREAL64, 2, amp_agent_op_expreal64);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITAND, 2, amp_agent_op_bitand);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITOR, 2, amp_agent_op_bitor);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITXOR, 2, amp_agent_op_bitxor);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITNOT, 1, amp_agent_op_bitnot);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LOGAND, 2, amp_agent_op_logand);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LOGOR, 2, amp_agent_op_logor);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LOGNOT, 1, amp_agent_op_lognot);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_ABS, 1, amp_agent_op_abs);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LESSTHAN, 2, amp_agent_op_lessthan);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_GREATERTHAN, 2, amp_agent_op_greaterthan);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LESSEQUAL, 2, amp_agent_op_lessequal);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_GREATEREQUAL, 2, amp_agent_op_greaterequal);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_NOTEQUAL, 2, amp_agent_op_notequal);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EQUAL, 2, amp_agent_op_equal);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITSHIFTLEFT, 2, amp_agent_op_bitshiftleft);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITSHIFTRIGHT, 2, amp_agent_op_bitshiftright);
-	adm_add_op(g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_STOR, 2, amp_agent_op_stor);
-}
-
-void amp_agent_init_var()
-{
-
-	ari_t *id = NULL;
-
-	expr_t *expr = NULL;
-
-
-	/* NUM_RULES */
-
-	id = adm_build_ari(AMP_TYPE_VAR, 0, g_amp_agent_idx[ADM_VAR_IDX], AMP_AGENT_VAR_NUM_RULES);
-	expr = expr_create(AMP_TYPE_UINT);
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBR));
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_SBR));
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUINT));
-	adm_add_var_from_expr(id, AMP_TYPE_UINT, expr);
-}
-
-void amp_agent_init_ctrl()
-{
-
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_VAR, 3, amp_agent_ctrl_add_var);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DEL_VAR, 1, amp_agent_ctrl_del_var);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_RPTT, 2, amp_agent_ctrl_add_rptt);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DEL_RPTT, 1, amp_agent_ctrl_del_rptt);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DESC_RPTT, 1, amp_agent_ctrl_desc_rptt);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_GEN_RPTS, 2, amp_agent_ctrl_gen_rpts);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_GEN_TBLS, 2, amp_agent_ctrl_gen_tbls);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_MACRO, 3, amp_agent_ctrl_add_macro);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DEL_MACRO, 1, amp_agent_ctrl_del_macro);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DESC_MACRO, 1, amp_agent_ctrl_desc_macro);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_TBR, 6, amp_agent_ctrl_add_tbr);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_SBR, 7, amp_agent_ctrl_add_sbr);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DEL_RULE, 1, amp_agent_ctrl_del_rule);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DESC_RULE, 1, amp_agent_ctrl_desc_rule);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_STORE_VAR, 2, amp_agent_ctrl_store_var);
-	adm_add_ctrldef(g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_RESET_COUNTS, 0, amp_agent_ctrl_reset_counts);
-}
-
-void amp_agent_init_mac()
-{
-
-}
-
-void amp_agent_init_rpttpl()
-{
-
-	rpttpl_t *def = NULL;
-
-	/* FULL_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_amp_agent_idx[ADM_RPTT_IDX], AMP_AGENT_RPTTPL_FULL_REPORT));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_NAME));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_VERSION));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_RPT_TPLS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBL_TPLS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_SENT_REPORTS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_TBR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_SBR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_SBR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_CONST));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_VAR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_MACROS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_MACROS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_CONTROLS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_CONTROLS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_VAR, 0, g_amp_agent_idx[ADM_VAR_IDX], AMP_AGENT_VAR_NUM_RULES));
-	adm_add_rpttpl(def);
-}
-
-void amp_agent_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* ADMS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_ADMS), amp_agent_tblt_adms);
-	tblt_add_col(def, AMP_TYPE_STR, "adm_name");
-	adm_add_tblt(def);
-
-	/* VARIABLES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_VARIABLES), amp_agent_tblt_variables);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-
-	/* RPTTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_RPTTS), amp_agent_tblt_rptts);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-
-	/* MACROS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_MACROS), amp_agent_tblt_macros);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-
-	/* RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_RULES), amp_agent_tblt_rules);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-
-	/* TBLTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_TBLTS), amp_agent_tblt_tblts);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-}
-
-#endif // _HAVE_AMP_AGENT_ADM_
diff --git a/nm/agent/adm_amp_agent_impl.c b/nm/agent/adm_amp_agent_impl.c
deleted file mode 100644
index dbb2d252..00000000
--- a/nm/agent/adm_amp_agent_impl.c
+++ /dev/null
@@ -1,3263 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_amp_agent_impl.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-16  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "../shared/primitives/expr.h"
-#include "../shared/primitives/tnv.h"
-#include "instr.h"
-#include "../shared/msg/msg.h"
-#include "rda.h"
-#include "ldc.h"
-
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/adm/adm.h"
-#include "adm_amp_agent_impl.h"
-
-/*   START CUSTOM FUNCTIONS HERE */
-#define AMP_SAFE_MOD(a,b) ((b == 0) ? 0 : (a%b))
-#define AMP_SAFE_DIV(a,b) ((b == 0) ? 0 : (a/b))
-void amp_agent_collect_ari_keys(rh_elt_t *elt, void *tag)
-{
-	vector_t *vec = (vector_t *) tag;
-
-	if((elt == NULL) || (vec == NULL))
-	{
-		return;
-	}
-
-	vec_push(vec, elt->key);
-}
-
-int amp_agent_build_ari_table(tbl_t *table, rhht_t *ht)
-{
-	int success;
-	vector_t vec = vec_create(4, NULL, NULL, NULL, 0, &success);
-	tnvc_t *cur_row;
-	vecit_t it;
-
-	if(success != VEC_OK)
-	{
-		return AMP_FAIL;
-	}
-
-	rhht_foreach(ht, amp_agent_collect_ari_keys, &vec);
-
-	success = AMP_OK;
-	for(it = vecit_first(&vec); vecit_valid(it); it = vecit_next(it))
-	{
-		ari_t *ari = (ari_t*) vecit_data(it);
-		cur_row = tnvc_create(1);
-		tnvc_insert(cur_row, tnv_from_obj(AMP_TYPE_ARI, ari_copy_ptr(ari)));
-		if(tbl_add_row(table, cur_row) != AMP_OK)
-		{
-			success = AMP_FAIL;
-			break;
-		}
-	}
-	vec_release(&vec, 0);
-	return success;
-}
-
-int adm_agent_op_prep(uint8_t num, tnv_t **lval, tnv_t **rval, vector_t *stack)
-{
-	int success = AMP_OK;
-
-	if(num > 0)
-	{
-		*rval = vec_pop(stack, &success);
-	}
-	else
-	{
-		*lval = vec_pop(stack, &success);
-	}
-
-	if((success == VEC_OK) && (num > 1))
-	{
-		*lval = vec_pop(stack, &success);
-	}
-
-	return success;
-}
-
-
-tnv_t *amp_agent_binary_num_op(amp_agent_op_e op, vector_t *stack, amp_type_e result_type)
-{
-	int ls = 0;
-	int rs = 0;
-	tnv_t *lval = NULL;
-	tnv_t *rval = NULL;
-	tnv_t *result = NULL;
-	int success;
-
-	if(stack == NULL)
-	{
-		return result;
-	}
-
-	success = adm_agent_op_prep(2, &lval, &rval, stack);
-	if( (success != AMP_OK) || (lval == NULL) || (rval == NULL))
-	{
-		tnv_release(lval, 1);
-		tnv_release(rval, 1);
-		return NULL;
-	}
-
-	// TODO more boundary checks.
-	if((result = tnv_create()) == NULL)
-	{
-		tnv_release(lval, 1);
-		tnv_release(rval, 1);
-		return NULL;
-	}
-
-	result->type = (result_type == AMP_TYPE_UNK) ? gValNumCvtResult[lval->type - AMP_TYPE_INT][rval->type - AMP_TYPE_INT] : result_type;
-
-	if(result->type == AMP_TYPE_UNK)
-	{
-		tnv_release(lval, 1);
-		tnv_release(rval, 1);
-		return NULL;
-	}
-
-    switch(result->type)
-	{
-	case AMP_TYPE_INT:
-		switch(op)
-		{
-		case PLUS:   result->value.as_int = tnv_to_int(*lval, &ls) + tnv_to_int(*rval, &rs); break;
-		case MINUS:  result->value.as_int = tnv_to_int(*lval, &ls) - tnv_to_int(*rval, &rs); break;
-		case MULT:   result->value.as_int = tnv_to_int(*lval, &ls) * tnv_to_int(*rval, &rs); break;
-		case DIV:    result->value.as_int = AMP_SAFE_DIV(tnv_to_int(*lval, &ls), tnv_to_int(*rval, &rs)); break;
-		case MOD:    result->value.as_int = AMP_SAFE_MOD(tnv_to_int(*lval, &ls), tnv_to_int(*rval, &rs)); break;
-		case EXP:    result->value.as_int = (int32_t) pow(tnv_to_int(*lval, &ls), tnv_to_int(*rval, &rs)); break;
-		case BITAND: result->value.as_int = tnv_to_int(*lval, &ls) & tnv_to_int(*rval, &rs); break;
-		case BITOR:  result->value.as_int = tnv_to_int(*lval, &ls) | tnv_to_int(*rval, &rs); break;
-		case BITXOR: result->value.as_int = tnv_to_int(*lval, &ls) ^ tnv_to_int(*rval, &rs); break;
-		case BITLSHFT: result->value.as_int = tnv_to_int(*lval, &ls) << tnv_to_uint(*rval, &rs); break;
-		case BITRSHFT: result->value.as_int = tnv_to_int(*lval, &ls) >> tnv_to_uint(*rval, &rs); break;
-		default:
-			ls = rs = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_UINT:
-		switch(op)
-		{
-		case PLUS:   result->value.as_uint = tnv_to_uint(*lval, &ls) + tnv_to_uint(*rval, &rs); break;
-		case MINUS:  result->value.as_uint = tnv_to_uint(*lval, &ls) - tnv_to_uint(*rval, &rs); break;
-		case MULT:   result->value.as_uint = tnv_to_uint(*lval, &ls) * tnv_to_uint(*rval, &rs); break;
-		case DIV:    result->value.as_uint = AMP_SAFE_DIV(tnv_to_uint(*lval, &ls), tnv_to_uint(*rval, &rs)); break;
-		case MOD:    result->value.as_uint = AMP_SAFE_MOD(tnv_to_uint(*lval, &ls), tnv_to_uint(*rval, &rs)); break;
-		case EXP:    result->value.as_uint = (uint32_t) pow(tnv_to_uint(*lval, &ls), tnv_to_uint(*rval, &rs)); break;
-		case BITAND: result->value.as_uint = tnv_to_uint(*lval, &ls) & tnv_to_uint(*rval, &rs); break;
-		case BITOR:  result->value.as_uint = tnv_to_uint(*lval, &ls) | tnv_to_uint(*rval, &rs); break;
-		case BITXOR: result->value.as_uint = tnv_to_uint(*lval, &ls) ^ tnv_to_uint(*rval, &rs); break;
-		case BITLSHFT: result->value.as_uint = tnv_to_uint(*lval, &ls) << tnv_to_uint(*rval, &rs); break;
-		case BITRSHFT: result->value.as_uint = tnv_to_uint(*lval, &ls) >> tnv_to_uint(*rval, &rs); break;
-		default:
-			ls = rs = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_VAST:
-		switch(op)
-		{
-		case PLUS:   result->value.as_vast = tnv_to_vast(*lval, &ls) + tnv_to_vast(*rval, &rs); break;
-		case MINUS:  result->value.as_vast = tnv_to_vast(*lval, &ls) - tnv_to_vast(*rval, &rs); break;
-		case MULT:   result->value.as_vast = tnv_to_vast(*lval, &ls) * tnv_to_vast(*rval, &rs); break;
-		case DIV:    result->value.as_vast = AMP_SAFE_DIV(tnv_to_vast(*lval, &ls), tnv_to_vast(*rval, &rs)); break;
-		case MOD:    result->value.as_vast = AMP_SAFE_MOD(tnv_to_vast(*lval, &ls), tnv_to_vast(*rval, &rs)); break;
-		case EXP:    result->value.as_vast = (vast) pow(tnv_to_vast(*lval, &ls), tnv_to_vast(*rval, &rs)); break;
-		case BITAND: result->value.as_vast = tnv_to_vast(*lval, &ls) & tnv_to_vast(*rval, &rs); break;
-		case BITOR:  result->value.as_vast = tnv_to_vast(*lval, &ls) | tnv_to_vast(*rval, &rs); break;
-		case BITXOR: result->value.as_vast = tnv_to_vast(*lval, &ls) ^ tnv_to_vast(*rval, &rs); break;
-		case BITLSHFT: result->value.as_vast = tnv_to_vast(*lval, &ls) << tnv_to_uint(*rval, &rs); break;
-		case BITRSHFT: result->value.as_vast = tnv_to_vast(*lval, &ls) >> tnv_to_uint(*rval, &rs); break;
-		default:
-			ls = rs = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_UVAST:
-		switch(op)
-		{
-		case PLUS:   result->value.as_uvast = tnv_to_uvast(*lval, &ls) + tnv_to_uvast(*rval, &rs); break;
-		case MINUS:  result->value.as_uvast = tnv_to_uvast(*lval, &ls) - tnv_to_uvast(*rval, &rs); break;
-		case MULT:   result->value.as_uvast = tnv_to_uvast(*lval, &ls) * tnv_to_uvast(*rval, &rs); break;
-		case DIV:    result->value.as_uvast = AMP_SAFE_DIV(tnv_to_uvast(*lval, &ls), tnv_to_uvast(*rval, &rs)); break;
-		case MOD:    result->value.as_uvast = AMP_SAFE_MOD(tnv_to_uvast(*lval, &ls), tnv_to_uvast(*rval, &rs)); break;
-		case EXP:    result->value.as_uvast = (uvast) pow(tnv_to_uvast(*lval, &ls), tnv_to_uvast(*rval, &rs)); break;
-		case BITAND: result->value.as_uvast = tnv_to_uvast(*lval, &ls) & tnv_to_uvast(*rval, &rs); break;
-		case BITOR:  result->value.as_uvast = tnv_to_uvast(*lval, &ls) | tnv_to_uvast(*rval, &rs); break;
-		case BITXOR: result->value.as_uvast = tnv_to_uvast(*lval, &ls) ^ tnv_to_uvast(*rval, &rs); break;
-		case BITLSHFT: result->value.as_uvast = tnv_to_uvast(*lval, &ls) << tnv_to_uint(*rval, &rs); break;
-		case BITRSHFT: result->value.as_uvast = tnv_to_uvast(*lval, &ls) >> tnv_to_uint(*rval, &rs); break;
-		default:
-			ls = rs = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_REAL32:
-		switch(op)
-		{
-		case PLUS:   result->value.as_real32 = tnv_to_real32(*lval, &ls) + tnv_to_real32(*rval, &rs); break;
-		case MINUS:  result->value.as_real32 = tnv_to_real32(*lval, &ls) - tnv_to_real32(*rval, &rs); break;
-		case MULT:   result->value.as_real32 = tnv_to_real32(*lval, &ls) * tnv_to_real32(*rval, &rs); break;
-		case DIV:    result->value.as_real32 = AMP_SAFE_DIV(tnv_to_real32(*lval, &ls), tnv_to_real32(*rval, &rs)); break;
-		case EXP:    result->value.as_real32 = (float) pow(tnv_to_real32(*lval, &ls), tnv_to_real32(*rval, &rs)); break;
-		default:
-			ls = rs = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_REAL64:
-		switch(op)
-		{
-		case PLUS:   result->value.as_real64 = tnv_to_real64(*lval, &ls) + tnv_to_real64(*rval, &rs); break;
-		case MINUS:  result->value.as_real64 = tnv_to_real64(*lval, &ls) - tnv_to_real64(*rval, &rs); break;
-		case MULT:   result->value.as_real64 = tnv_to_real64(*lval, &ls) * tnv_to_real64(*rval, &rs); break;
-		case DIV:    result->value.as_real64 = AMP_SAFE_DIV(tnv_to_real64(*lval, &ls), tnv_to_real64(*rval, &rs)); break;
-		case EXP:    result->value.as_real64 = (double) pow(tnv_to_real64(*lval, &ls), tnv_to_real64(*rval, &rs)); break;
-		default: ls = rs = 0; break;
-		}
-		break;
-		default:
-			ls = rs = AMP_FAIL; break;
-	}
-
-	if((ls != AMP_OK) || (rs != AMP_OK))
-	{
-        AMP_DEBUG_ERR("adm_agent_binary_num_op","Bad op (%d) or type (%d -> %d).",op, lval->type, rval->type);
-        tnv_release(result, 1);
-        result = NULL;
-	}
-
-	tnv_release(lval, 1);
-	tnv_release(rval, 1);
-
-	return result;
-}
-
-tnv_t *adm_agent_unary_num_op(amp_agent_op_e op, vector_t *stack, amp_type_e result_type)
-{
-	int ls = 0;
-	tnv_t *lval = NULL;
-	tnv_t *result = NULL;
-	int success;
-
-	if(stack == NULL)
-	{
-		return result;
-	}
-
-	success = adm_agent_op_prep(1, &lval, NULL, stack);
-	if( (success != AMP_OK) || (lval == NULL))
-	{
-		tnv_release(lval, 1);
-		return NULL;
-	}
-
-	// TODO more boundary checks.
-	if((result = tnv_create()) == NULL)
-	{
-		tnv_release(lval, 1);
-		return NULL;
-	}
-
-	result->type = (result_type == AMP_TYPE_UNK) ? gValNumCvtResult[lval->type - AMP_TYPE_INT][lval->type - AMP_TYPE_INT] : result_type;
-
-	if(result->type == AMP_TYPE_UNK)
-	{
-		tnv_release(lval, 1);
-		return NULL;
-	}
-
-    switch(result->type)
-	{
-	case AMP_TYPE_INT:
-		switch(op)
-		{
-		case BITNOT: result->value.as_int = ~(tnv_to_int(*lval, &ls)); break;
-		case ABS:    result->value.as_int = abs(tnv_to_int(*lval, &ls)); break;
-		case NEG:    result->value.as_int = -1 * (tnv_to_int(*lval, &ls)); break;
-		default:
-			ls = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_UINT:
-		switch(op)
-		{
-		case BITNOT: result->value.as_uint = ~(tnv_to_uint(*lval, &ls)); break;
-		case ABS:    result->value.as_uint = abs(tnv_to_int(*lval, &ls)); break;
-		case NEG:    result->value.as_uint = -1 * (tnv_to_uint(*lval, &ls)); break;
-		default:
-			ls = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_VAST:
-		switch(op)
-		{
-		case BITNOT: result->value.as_vast = ~(tnv_to_vast(*lval, &ls)); break;
-		case ABS:    result->value.as_vast = abs((int)tnv_to_vast(*lval, &ls)); break;
-		case NEG:    result->value.as_vast = -1 * (tnv_to_vast(*lval, &ls)); break;
-		default:
-			ls = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_UVAST:
-		switch(op)
-		{
-		case BITNOT: result->value.as_uvast = ~(tnv_to_uvast(*lval, &ls)); break;
-		case ABS:    result->value.as_uvast = abs((int)tnv_to_vast(*lval, &ls)); break;
-		case NEG:    result->value.as_uvast = -1 * (tnv_to_uvast(*lval, &ls)); break;
-		default:
-			ls = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_REAL32:
-		switch(op)
-		{
-		case ABS:    result->value.as_real32 = fabs(tnv_to_real32(*lval, &ls)); break;
-		case NEG:    result->value.as_real32 = -1 * (tnv_to_real32(*lval, &ls)); break;
-		default:
-			ls = AMP_FAIL; break;
-		}
-		break;
-	case AMP_TYPE_REAL64:
-		switch(op)
-		{
-		case ABS:    result->value.as_real64 = fabs(tnv_to_real64(*lval, &ls)); break;
-		case NEG:    result->value.as_real64 = -1 * (tnv_to_real64(*lval, &ls)); break;
-		default: ls = AMP_FAIL; break;
-		}
-		break;
-		default:
-			ls = AMP_FAIL; break;
-	}
-
-	if(ls != AMP_OK)
-	{
-        AMP_DEBUG_ERR("adm_agent_binary_num_op","Bad op (%d) or type (%d -> %d).",op, lval->type);
-        tnv_release(result, 1);
-        result = NULL;
-	}
-
-	tnv_release(lval, 1);
-
-	return result;
-}
-
-tnv_t *adm_agent_unary_log_op(amp_agent_op_e op, vector_t *stack)
-{
-	tnv_t *result = NULL;
-	tnv_t *val = NULL;
-	int s = 0;
-	int success = AMP_FAIL;
-
-	if(stack == NULL)
-	{
-		return result;
-	}
-
-	success = adm_agent_op_prep(1, &val, NULL, stack);
-	if((success != AMP_OK) || (val == NULL))
-	{
-		tnv_release(result, 1);
-		return NULL;
-	}
-
-	// TODO more boundary checks.
-	if((result = tnv_create()) == NULL)
-	{
-		tnv_release(val, 1);
-		return NULL;
-	}
-
-	result->type = AMP_TYPE_BOOL;
-
-	switch(val->type)
-	{
-	case AMP_TYPE_INT:
-		switch(op)
-		{
-			case LOGNOT: result->value.as_uint = tnv_to_int(*val, &s) ? 0 : 1; break;
-			default: s = 0; break;
-		}
-		break;
-	case AMP_TYPE_UINT:
-		switch(op)
-		{
-			case LOGNOT: result->value.as_uint = tnv_to_uint(*val, &s) ? 0 : 1; break;
-			default: s = 0; break;
-		}
-		break;
-	case AMP_TYPE_VAST:
-		switch(op)
-		{
-			case LOGNOT: result->value.as_uint = tnv_to_vast(*val, &s) ? 0 : 1; break;
-			default: s = 0; break;
-		}
-		break;
-	case AMP_TYPE_UVAST:
-		switch(op)
-		{
-			case LOGNOT: result->value.as_uint = tnv_to_uvast(*val, &s) ? 0 : 1; break;
-			default: s = 0; break;
-		}
-		break;
-	case AMP_TYPE_REAL32:
-		switch(op)
-		{
-			default: s = 0; break;
-		}
-		break;
-	case AMP_TYPE_REAL64:
-		switch(op)
-		{
-			default: s = 0; break;
-		}
-		break;
-	default:
-		s = 0;
-		break;
-	}
-
-    if(s == 0)
-	{
-        AMP_DEBUG_ERR("adm_agent_unary_log_op","Bad op (%d) or type (%d).",op, val->type);
-        tnv_release(result, 1);
-        result = NULL;
-	}
-
-	tnv_release(val, 1);
-
-	return result;
-}
-
-
-
-tnv_t *adm_agent_binary_log_op(amp_agent_op_e op, vector_t *stack)
-{
-	int ls = 0;
-	int rs = 0;
-	tnv_t *lval = NULL;
-	tnv_t *rval = NULL;
-	tnv_t *result = NULL;
-	int success;
-
-
-	if(stack == NULL)
-	{
-		return result;
-	}
-
-	success = adm_agent_op_prep(2, &lval, &rval, stack);
-	if( (success != AMP_OK) || (lval == NULL) || (rval == NULL))
-	{
-		tnv_release(lval, 1);
-		tnv_release(rval, 1);
-		return NULL;
-	}
-
-	// TODO more boundary checks.
-	if((result = tnv_create()) == NULL)
-	{
-		tnv_release(lval, 1);
-		tnv_release(rval, 1);
-		return NULL;
-	}
-
-	result->type = AMP_TYPE_BOOL;
-
-	/* Step 3: Based on result type, convert and perform operations. */
-    switch(lval->type)
-	{
-	case AMP_TYPE_INT:
-		switch(op)
-		{
-		case LOGAND: result->value.as_uint = tnv_to_int(*lval, &ls) && tnv_to_int(*rval, &rs); break;
-		case LOGOR:  result->value.as_uint = tnv_to_int(*lval, &ls) || tnv_to_int(*rval, &rs); break;
-		case LT:     result->value.as_uint = tnv_to_int(*lval, &ls) < tnv_to_int(*rval, &rs); break;
-		case GT:     result->value.as_uint = tnv_to_int(*lval, &ls) > tnv_to_int(*rval, &rs); break;
-		case LTE:    result->value.as_uint = tnv_to_int(*lval, &ls) <= tnv_to_int(*rval, &rs); break;
-		case GTE:    result->value.as_uint = tnv_to_int(*lval, &ls) >= tnv_to_int(*rval, &rs); break;
-		case EQ:     result->value.as_uint = tnv_to_int(*lval, &ls) == tnv_to_int(*rval, &rs); break;
-		default: ls = rs = 0; break;
-		}
-		break;
-	case AMP_TYPE_UINT:
-		switch(op)
-		{
-		case LOGAND: result->value.as_uint = tnv_to_uint(*lval, &ls) && tnv_to_uint(*rval, &rs); break;
-		case LOGOR:  result->value.as_uint = tnv_to_uint(*lval, &ls) || tnv_to_uint(*rval, &rs); break;
-		case LT:     result->value.as_uint = tnv_to_uint(*lval, &ls) < tnv_to_uint(*rval, &rs); break;
-		case GT:     result->value.as_uint = tnv_to_uint(*lval, &ls) > tnv_to_uint(*rval, &rs); break;
-		case LTE:    result->value.as_uint = tnv_to_uint(*lval, &ls) <= tnv_to_uint(*rval, &rs); break;
-		case GTE:    result->value.as_uint = tnv_to_uint(*lval, &ls) >= tnv_to_uint(*rval, &rs); break;
-		case EQ:     result->value.as_uint = tnv_to_uint(*lval, &ls) == tnv_to_uint(*rval, &rs); break;
-		default: ls = rs = 0; break;
-		}
-		break;
-	case AMP_TYPE_VAST:
-		switch(op)
-		{
-		case LOGAND: result->value.as_uint = tnv_to_vast(*lval, &ls) && tnv_to_vast(*rval, &rs); break;
-		case LOGOR:  result->value.as_uint = tnv_to_vast(*lval, &ls) || tnv_to_vast(*rval, &rs); break;
-		case LT:     result->value.as_uint = tnv_to_vast(*lval, &ls) < tnv_to_vast(*rval, &rs); break;
-		case GT:     result->value.as_uint = tnv_to_vast(*lval, &ls) > tnv_to_vast(*rval, &rs); break;
-		case LTE:    result->value.as_uint = tnv_to_vast(*lval, &ls) <= tnv_to_vast(*rval, &rs); break;
-		case GTE:    result->value.as_uint = tnv_to_vast(*lval, &ls) >= tnv_to_vast(*rval, &rs); break;
-		case EQ:     result->value.as_uint = tnv_to_vast(*lval, &ls) == tnv_to_vast(*rval, &rs); break;
-		default: ls = rs = 0; break;
-		}
-		break;
-	case AMP_TYPE_UVAST:
-		switch(op)
-		{
-		case LOGAND: result->value.as_uint = tnv_to_uvast(*lval, &ls) && tnv_to_uvast(*rval, &rs); break;
-		case LOGOR:  result->value.as_uint = tnv_to_uvast(*lval, &ls) || tnv_to_uvast(*rval, &rs); break;
-		case LT:     result->value.as_uint = tnv_to_uvast(*lval, &ls) < tnv_to_uvast(*rval, &rs); break;
-		case GT:     result->value.as_uint = tnv_to_uvast(*lval, &ls) > tnv_to_uvast(*rval, &rs); break;
-		case LTE:    result->value.as_uint = tnv_to_uvast(*lval, &ls) <= tnv_to_uvast(*rval, &rs); break;
-		case GTE:    result->value.as_uint = tnv_to_uvast(*lval, &ls) >= tnv_to_uvast(*rval, &rs); break;
-		case EQ:     result->value.as_uint = tnv_to_uvast(*lval, &ls) == tnv_to_uvast(*rval, &rs); break;
-		default: ls = rs = 0; break;
-		}
-		break;
-	case AMP_TYPE_REAL32:
-		switch(op)
-		{
-		case LOGAND: result->value.as_uint = tnv_to_real32(*lval, &ls) && tnv_to_real32(*rval, &rs); break;
-		case LOGOR:  result->value.as_uint = tnv_to_real32(*lval, &ls) || tnv_to_real32(*rval, &rs); break;
-		case LT:     result->value.as_uint = tnv_to_real32(*lval, &ls) < tnv_to_real32(*rval, &rs); break;
-		case GT:     result->value.as_uint = tnv_to_real32(*lval, &ls) > tnv_to_real32(*rval, &rs); break;
-		case LTE:    result->value.as_uint = tnv_to_real32(*lval, &ls) <= tnv_to_real32(*rval, &rs); break;
-		case GTE:    result->value.as_uint = tnv_to_real32(*lval, &ls) >= tnv_to_real32(*rval, &rs); break;
-		case EQ:     result->value.as_uint = tnv_to_real32(*lval, &ls) == tnv_to_real32(*rval, &rs); break;
-		default: ls = rs = 0; break;
-		}
-		break;
-	case AMP_TYPE_REAL64:
-		switch(op)
-		{
-		case LOGAND: result->value.as_uint = tnv_to_real64(*lval, &ls) && tnv_to_real64(*rval, &rs); break;
-		case LOGOR:  result->value.as_uint = tnv_to_real64(*lval, &ls) || tnv_to_real64(*rval, &rs); break;
-		case LT:     result->value.as_uint = tnv_to_real64(*lval, &ls) < tnv_to_real64(*rval, &rs); break;
-		case GT:     result->value.as_uint = tnv_to_real64(*lval, &ls) > tnv_to_real64(*rval, &rs); break;
-		case LTE:    result->value.as_uint = tnv_to_real64(*lval, &ls) <= tnv_to_real64(*rval, &rs); break;
-		case GTE:    result->value.as_uint = tnv_to_real64(*lval, &ls) >= tnv_to_real64(*rval, &rs); break;
-		case EQ:     result->value.as_uint = tnv_to_real64(*lval, &ls) == tnv_to_real64(*rval, &rs); break;
-		default: ls = rs = 0; break;
-		}
-		break;
-	default:
-		ls = rs = 0;
-		break;
-	}
-
-    if((ls == 0) || (rs == 0))
-	{
-        AMP_DEBUG_ERR("adm_agent_binary_log_op","Bad op (%d) or type (%d -> %d).",op, lval->type, rval->type);
-        tnv_release(result, 1);
-        result = NULL;
-	}
-
-    tnv_release(lval, 1);
-	tnv_release(rval, 1);
-
-	return result;
-}
-
-
-
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void amp_agent_setup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-void amp_agent_cleanup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-
-/* Metadata Functions */
-
-
-tnv_t *amp_agent_meta_name(tnvc_t *parms)
-{
-	return tnv_from_str("amp_agent");
-}
-
-
-tnv_t *amp_agent_meta_namespace(tnvc_t *parms)
-{
-	return tnv_from_str("Amp/Agent");
-}
-
-
-tnv_t *amp_agent_meta_version(tnvc_t *parms)
-{
-	return tnv_from_str("v3.1");
-}
-
-
-tnv_t *amp_agent_meta_organization(tnvc_t *parms)
-{
-	return tnv_from_str("JHUAPL");
-}
-
-
-/* Constant Functions */
-tnv_t *amp_agent_get_amp_epoch(tnvc_t *parms)
-{
-	return tnv_from_uvast(1504915200);
-}
-
-/* Table Functions */
-
-
-/*
- * This table lists all the adms that are supported by the agent.
- */
-tbl_t *amp_agent_tblt_adms(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_adms BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	tnvc_t *cur_row = NULL;
-
-	cur_row = tnvc_create(1);
-	tnvc_insert(cur_row, tnv_from_str("AMP AGENT"));
-	if(tbl_add_row(table, cur_row) != AMP_OK)
-	{
-		tbl_release(table, 1);
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_adms BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * This table lists the ARI for every variable that is known to the agent.
- */
-tbl_t *amp_agent_tblt_variables(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_variables BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	if(amp_agent_build_ari_table(table, &(gVDB.vars)) != AMP_OK)
-	{
-		tbl_release(table, 1);
-		table = NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_variables BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * This table lists the ARI for every report template that is known to the agent.
- */
-tbl_t *amp_agent_tblt_rptts(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_rptts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	if(amp_agent_build_ari_table(table, &(gVDB.rpttpls)) != AMP_OK)
-	{
-		tbl_release(table, 1);
-		table = NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_rptts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * This table lists the ARI for every macro that is known to the agent.
- */
-tbl_t *amp_agent_tblt_macros(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_macros BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	if(amp_agent_build_ari_table(table, &(gVDB.macdefs)) != AMP_OK)
-	{
-		tbl_release(table, 1);
-		table = NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_macros BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * This table lists the ARI for every rule that is known to the agent.
- */
-tbl_t *amp_agent_tblt_rules(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	if(amp_agent_build_ari_table(table, &(gVDB.rules)) != AMP_OK)
-	{
-		tbl_release(table, 1);
-		table = NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * This table lists the ARI for every table template that is known to the agent.
- */
-tbl_t *amp_agent_tblt_tblts(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_tblts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	if(amp_agent_build_ari_table(table, &(gVDB.adm_tblts)) != AMP_OK)
-	{
-		tbl_release(table, 1);
-		table = NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_tblts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/* Collect Functions */
-/*
- * This is the number of report templates known to the Agent.
- */
-tnv_t *amp_agent_get_num_rpt_tpls(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_rpt_tpls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = tnv_from_uint(gVDB.rpttpls.num_elts);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_rpt_tpls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of table templates known to the Agent.
- */
-tnv_t *amp_agent_get_num_tbl_tpls(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_tbl_tpls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = tnv_from_uint(gVDB.adm_tblts.num_elts);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_tbl_tpls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of reports sent by the agent.
- */
-tnv_t *amp_agent_get_sent_reports(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_sent_reports BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = tnv_from_uint(gAgentInstr.num_sent_rpts);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_sent_reports BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of time-based rules running on the agent.
- */
-tnv_t *amp_agent_get_num_tbr(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_tbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = tnv_from_uint(gAgentInstr.num_tbrs);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_tbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of time-based rules run by the agent since the last reset.
- */
-tnv_t *amp_agent_get_run_tbr(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_run_tbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = tnv_from_uint(gAgentInstr.num_tbrs_run);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_run_tbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of state-based rules running on the agent.
- */
-tnv_t *amp_agent_get_num_sbr(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_sbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = tnv_from_uint(gAgentInstr.num_sbrs);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_sbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of state-based rules run by the agent since the last reset.
- */
-tnv_t *amp_agent_get_run_sbr(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_run_sbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = tnv_from_uint(gAgentInstr.num_sbrs_run);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_run_sbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of constants known by the agent.
- */
-tnv_t *amp_agent_get_num_const(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_const BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = tnv_from_uint(gVDB.adm_atomics.num_elts);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_const BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of variables known by the agent.
- */
-tnv_t *amp_agent_get_num_var(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_var BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = tnv_from_uint(gVDB.vars.num_elts);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_var BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of macros known by the agent.
- */
-tnv_t *amp_agent_get_num_macros(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_macros BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = tnv_from_uint(gVDB.macdefs.num_elts);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_macros BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of macros run by the agent since the last reset.
- */
-tnv_t *amp_agent_get_run_macros(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_run_macros BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = tnv_from_uint(gAgentInstr.num_macros_run);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_run_macros BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of controls known by the agent.
- */
-tnv_t *amp_agent_get_num_controls(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_num_controls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = tnv_from_uint(gVDB.ctrls.total_slots - gVDB.ctrls.num_free);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_num_controls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the number of controls run by the agent since the last reset.
- */
-tnv_t *amp_agent_get_run_controls(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_run_controls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = tnv_from_uint(gAgentInstr.num_ctrls_run);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_run_controls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the current system time.
- */
-tnv_t *amp_agent_get_cur_time(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_cur_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	struct timeval cur_time;
-
-	getCurrentTime(&cur_time);
-
-	result = tnv_from_uvast(cur_time.tv_sec);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_cur_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* Control Functions */
-
-/*
- * This control configures a new variable definition on the Agent.
- */
-tnv_t *amp_agent_ctrl_add_var(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_add_var BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	ari_t *id = adm_get_parm_obj(parms, 0, AMP_TYPE_ARI);
-	expr_t *expr = adm_get_parm_obj(parms, 1, AMP_TYPE_EXPR);
-	amp_type_e type = adm_get_parm_uint(parms, 2, &success);
-
-	if((id == NULL) || (expr == NULL) || (type == AMP_TYPE_UNK))
-	{
-		AMP_DEBUG_ERR("ADD_VAR", "Bad parameters for control", NULL);
-		return result;
-	}
-
-	var_t *new_var = var_create(ari_copy_ptr(id), type, expr_copy_ptr(expr));
-
-	if(new_var == NULL)
-	{
-		AMP_DEBUG_ERR("ADD_VAR","Unable to make new var.", NULL);
-		return result;
-	}
-
-	if(VDB_FINDKEY_VAR(new_var->id) == NULL)
-	{
-		int rh_code = VDB_ADD_VAR(new_var->id, new_var);
-
-		if(rh_code != RH_OK)
-		{
-			var_release(new_var, 1);
-		}
-		else
-		{
-			*status = CTRL_SUCCESS;
-			db_persist_var(new_var);
-		}
-	}
-	else
-	{
-		*status = CTRL_SUCCESS;
-		AMP_DEBUG_WARN("ADD_VAR","Ignoring duplicate item.", NULL);
-		var_release(new_var, 1);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_add_var BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control removes one or more variable definitions from the Agent.
- */
-tnv_t *amp_agent_ctrl_del_var(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_del_var BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	vecit_t it;
-	ac_t *ids = adm_get_parm_obj(parms, 0, AMP_TYPE_AC);
-
-	if(ids == NULL)
-	{
-		AMP_DEBUG_ERR("DEL_VAR", "Bad parameters.", NULL);
-		return result;
-	}
-
-	for(it = vecit_first(&(ids->values)); vecit_valid(it); it = vecit_next(it))
-	{
-		ari_t *cur_id = vecit_data(it);
-		var_t *var = VDB_FINDKEY_VAR(cur_id);
-
-		if(var == NULL)
-		{
-			AMP_DEBUG_WARN("DEL_VAR", "Cannot find var to be deleted.", NULL);
-		}
-		else
-		{
-			db_forget(&(var->desc), gDB.vars);
-			VDB_DELKEY_VAR(cur_id);
-		}
-	}
-
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_del_var BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control configures a new report template definition on the Agent.
- */
-tnv_t *amp_agent_ctrl_add_rptt(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_add_rptt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	ari_t *id = adm_get_parm_obj(parms, 0, AMP_TYPE_ARI);
-	ac_t *template = adm_get_parm_obj(parms, 1, AMP_TYPE_AC);
-	rpttpl_t *def = NULL;
-
-	if((id == NULL) || (template == NULL))
-	{
-		AMP_DEBUG_ERR("ADD_RPTT", "Bad Parameters.", NULL);
-		return result;
-	}
-
-	def = rpttpl_create(ari_copy_ptr(id), ac_copy(template));
-
-
-	if(VDB_FINDKEY_RPTT(def->id) == NULL)
-	{
-		int rh_code = VDB_ADD_RPTT(def->id, def);
-
-		if(rh_code != RH_OK)
-		{
-			rpttpl_release(def, 1);
-		}
-		else
-		{
-			*status = CTRL_SUCCESS;
-			db_persist_rpttpl(def);
-		}
-	}
-	else
-	{
-		*status = CTRL_SUCCESS;
-		AMP_DEBUG_WARN("ADD_RPTT","Ignoring duplicate item.", NULL);
-		rpttpl_release(def, 1);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_add_rptt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control removes one or more report template definitions from the Agent.
- */
-tnv_t *amp_agent_ctrl_del_rptt(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_del_rptt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	vecit_t it;
-	ac_t *ids = adm_get_parm_obj(parms, 0, AMP_TYPE_AC);
-
-	if(ids == NULL)
-	{
-		AMP_DEBUG_ERR("DEL_RPTT", "Bad parameters.", NULL);
-		return result;
-	}
-
-	for(it = vecit_first(&(ids->values)); vecit_valid(it); it = vecit_next(it))
-	{
-		ari_t *cur_id = vecit_data(it);
-		rpttpl_t *def = VDB_FINDKEY_RPTT(cur_id);
-
-		if(def == NULL)
-		{
-			AMP_DEBUG_WARN("DEL_RPTT", "Cannot find template to be deleted.", NULL);
-		}
-		else
-		{
-			db_forget(&(def->desc), gDB.rpttpls);
-			VDB_DELKEY_RPTT(cur_id);
-		}
-	}
-
-	*status = CTRL_SUCCESS;
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_del_rptt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control produces a detailed description of one or more report template  identifier(ARI) known t
- * o the Agent.
- */
-tnv_t *amp_agent_ctrl_desc_rptt(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_desc_rptt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	vecit_t ac_it;
-	int i = 0;
-	ac_t *ids = adm_get_parm_obj(parms, 0, AMP_TYPE_AC);
-
-	if(ids == NULL)
-	{
-		AMP_DEBUG_ERR("DESC_RPTT", "Bad parameters.", NULL);
-		return result;
-	}
-
-	tnvc_t *tnvc = tnvc_create(vec_num_entries(ids->values));
-
-	/* For each rptt being described. */
-	for(ac_it = vecit_first(&(ids->values)); vecit_valid(ac_it); ac_it = vecit_next(ac_it))
-	{
-		ari_t *cur_id = vecit_data(ac_it);
-		rpttpl_t *def = VDB_FINDKEY_RPTT(cur_id);
-
-		if(def == NULL)
-		{
-			AMP_DEBUG_WARN("DESC_RPTT","Cannot find RPTT for item %d.", i);
-		}
-		else
-		{
-			tnv_t *val = tnv_from_obj(AMP_TYPE_RPTTPL, rpttpl_copy_ptr(def));
-			tnvc_insert(tnvc, val);
-		}
-	}
-
-	result = tnv_from_obj(AMP_TYPE_TNVC, tnvc);
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_desc_rptt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control causes the Agent to produce a report entry for each identified report templates and sen
- * d them to one or more identified managers(ARIs).
- */
-tnv_t *amp_agent_ctrl_gen_rpts(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_gen_rpts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-
-	vecit_t ac_it;
-	vecit_t mgr_it;
-
-	ac_t *ids = adm_get_parm_obj(parms, 0, AMP_TYPE_AC);
-	tnvc_t *mgrs = adm_get_parm_obj(parms, 1, AMP_TYPE_TNVC);
-
-	if((ids == NULL) || (mgrs == NULL))
-	{
-		AMP_DEBUG_ERR("GEN_RPTT", "Bad parameters.", NULL);
-		return result;
-	}
-
-	if(tnvc_get_count(mgrs) == 0)
-	{
-		if((tnvc_insert(mgrs, tnv_from_str(def_mgr->name))) != AMP_OK)
-		{
-			AMP_DEBUG_ERR("GEN_RPTT","Empty TNVC and can't add default mgr.", NULL);
-			return result;
-		}
-	}
-
-	/* For each manager receiving a report. */
-	for(mgr_it = vecit_first(&(mgrs->values)); vecit_valid(mgr_it); mgr_it = vecit_next(mgr_it))
-	{
-		tnv_t *cur_mgr = (tnv_t*)vecit_data(mgr_it);
-		eid_t mgr_eid;
-		msg_rpt_t* msg_rpt;
-
-		if((cur_mgr == NULL) || (cur_mgr->type != AMP_TYPE_STR))
-		{
-			AMP_DEBUG_ERR("GEN_RPTT","Cannot parse MGR EID to send to.", NULL);
-			return result;
-		}
-
-		strncpy(mgr_eid.name, cur_mgr->value.as_ptr, AMP_MAX_EID_LEN-1);
-		msg_rpt = rda_get_msg_rpt(mgr_eid);
-
-		/* For each report being sent. */
-		for(ac_it = vecit_first(&(ids->values)); vecit_valid(ac_it); ac_it = vecit_next(ac_it))
-		{
-			ari_t *cur_id = vecit_data(ac_it);
-			rpt_t *rpt = rpt_create(ari_copy_ptr(cur_id), getCtime(), NULL);
-
-			if(cur_id->type == AMP_TYPE_RPTTPL)
-			{
-				rpttpl_t *def = VDB_FINDKEY_RPTT(cur_id);
-				ldc_fill_rpt(def, rpt);
-			}
-			else
-			{
-				tnv_t *cur_val = ldc_collect(cur_id, &(cur_id->as_reg.parms));
-				rpt_add_entry(rpt, cur_val);
-			}
-
-			msg_rpt_add_rpt(msg_rpt, rpt);
-		}
-	}
-
-
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_gen_rpts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control causes the Agent to produce a table for each identified table templates and send them t
- * o one or more identified managers(ARIs).
- */
-tnv_t *amp_agent_ctrl_gen_tbls(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_gen_tbls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	vecit_t ac_it;
-	vecit_t mgr_it;
-
-	ac_t *ids = adm_get_parm_obj(parms, 0, AMP_TYPE_AC);
-	tnvc_t *mgrs = adm_get_parm_obj(parms, 1, AMP_TYPE_TNVC);
-
-	if((ids == NULL) || (mgrs == NULL))
-	{
-		AMP_DEBUG_ERR("GEN_TBLT", "Bad parameters.", NULL);
-		return result;
-	}
-
-	if(tnvc_get_count(mgrs) == 0)
-	{
-		if((tnvc_insert(mgrs, tnv_from_str(def_mgr->name))) != AMP_OK)
-		{
-			AMP_DEBUG_ERR("GEN_TBLT","Empty TNVC and can't add default mgr.", NULL);
-			return result;
-		}
-	}
-
-	/* For each manager receiving a report. */
-	for(mgr_it = vecit_first(&(mgrs->values)); vecit_valid(mgr_it); mgr_it = vecit_next(mgr_it))
-	{
-		tnv_t *cur_mgr = (tnv_t*)vecit_data(mgr_it);
-		eid_t mgr_eid;
-		msg_rpt_t* msg_rpt;
-
-		if((cur_mgr == NULL) || (cur_mgr->type != AMP_TYPE_STR))
-		{
-			AMP_DEBUG_ERR("GEN_TBLT","Cannot parse MGR EID to send to.", NULL);
-			return result;
-		}
-
-		strncpy(mgr_eid.name, cur_mgr->value.as_ptr, AMP_MAX_EID_LEN-1);
-		msg_rpt = rda_get_msg_rpt(mgr_eid);
-
-		/* For each report being sent. */
-		for(ac_it = vecit_first(&(ids->values)); vecit_valid(ac_it); ac_it = vecit_next(ac_it))
-		{
-			ari_t *cur_id = vecit_data(ac_it);
-			tblt_t *def = VDB_FINDKEY_TBLT(cur_id);
-			rpt_t *rpt = NULL;
-			tbl_t *tbl = NULL;
-			tnv_t *val = NULL;
-
-			if( (def == NULL) ||
-				((rpt = rpt_create(ari_copy_ptr(cur_id), getCtime(), NULL)) == NULL) ||
-				((tbl = def->build(cur_id)) == NULL) ||
-				((val = tnv_from_obj(AMP_TYPE_TBL, tbl)) == NULL) ||
-				(rpt_add_entry(rpt, val) != AMP_OK))
-			{
-				rpt_release(rpt, 1);
-				tbl_release(tbl, 1);
-
-				AMP_DEBUG_ERR("GEN_TBLT","Cannot build table.", NULL);
-				continue;
-			}
-
-			msg_rpt_add_rpt(msg_rpt, rpt);
-		}
-	}
-
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_gen_tbls BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control configures a new macro definition on the Agent.
- */
-tnv_t *amp_agent_ctrl_add_macro(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_add_macro BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	int i, num;
-	ari_t *id = adm_get_parm_obj(parms, 1, AMP_TYPE_ARI);
-	ac_t *def = adm_get_parm_obj(parms, 2, AMP_TYPE_AC);
-
-	if((id == NULL) || (def == NULL))
-	{
-		AMP_DEBUG_ERR("ADD_MACRO", "Bad parameters for control", NULL);
-		return result;
-	}
-
-	num = ac_get_count(def);
-	macdef_t *macro = macdef_create(num, ari_copy_ptr(id));
-
-	for(i = 0; i < num; i++)
-	{
-		ctrl_t *cur_ctrl = ctrl_create(ac_get(def, i));
-		macdef_append(macro, cur_ctrl);
-	}
-
-	if(VDB_FINDKEY_MACDEF(macro->ari) == NULL)
-	{
-		int rh_code = VDB_ADD_MACDEF(macro->ari, macro);
-
-		if(rh_code != RH_OK)
-		{
-			macdef_release(macro, 1);
-		}
-		else
-		{
-			*status = CTRL_SUCCESS;
-			db_persist_macdef(macro);
-		}
-	}
-	else
-	{
-		*status = CTRL_SUCCESS;
-		AMP_DEBUG_WARN("ADD_MACRO","Ignoring duplicate item.", NULL);
-		macdef_release(macro, 1);
-	}
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_add_macro BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control removes one or more macro definitions from the Agent.
- */
-tnv_t *amp_agent_ctrl_del_macro(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_del_macro BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	vecit_t it;
-	ac_t *ids = adm_get_parm_obj(parms, 0, AMP_TYPE_AC);
-
-	if(ids == NULL)
-	{
-		AMP_DEBUG_ERR("DEL_MACRO", "Bad parameters.", NULL);
-		return result;
-	}
-
-	for(it = vecit_first(&(ids->values)); vecit_valid(it); it = vecit_next(it))
-	{
-		ari_t *cur_id = vecit_data(it);
-		macdef_t *def = VDB_FINDKEY_MACDEF(cur_id);
-
-		if(def == NULL)
-		{
-			AMP_DEBUG_WARN("DEL_MACRO", "Cannot find template to be deleted.", NULL);
-		}
-		else
-		{
-			db_forget(&(def->desc), gDB.macdefs);
-			VDB_DELKEY_MACDEF(cur_id);
-		}
-	}
-
-	*status = CTRL_SUCCESS;
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_del_macro BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control produces a detailed description of one or more macro identifier(ARI) known to the Agent
- * .
- */
-tnv_t *amp_agent_ctrl_desc_macro(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_desc_macro BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	vecit_t ac_it;
-	int i = 0;
-	ac_t *ids = adm_get_parm_obj(parms, 0, AMP_TYPE_AC);
-
-	if(ids == NULL)
-	{
-		AMP_DEBUG_ERR("DESC_MACRO", "Bad parameters.", NULL);
-		return result;
-	}
-
-	tnvc_t *tnvc = tnvc_create(vec_num_entries(ids->values));
-
-	/* For each macro being described. */
-	for(ac_it = vecit_first(&(ids->values)); vecit_valid(ac_it); ac_it = vecit_next(ac_it))
-	{
-		ari_t *cur_id = vecit_data(ac_it);
-		macdef_t *def = VDB_FINDKEY_MACDEF(cur_id);
-
-		if(def == NULL)
-		{
-			AMP_DEBUG_WARN("DESC_MACRO","Cannot find MACRO for item %d.", i);
-		}
-		else
-		{
-			tnv_t *val = tnv_from_obj(AMP_TYPE_MAC, macdef_copy_ptr(def));
-			tnvc_insert(tnvc, val);
-		}
-	}
-
-	result = tnv_from_obj(AMP_TYPE_TNVC, tnvc);
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_desc_macro BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control configures a new time-based rule(TBR) definition on the Agent.
- */
-tnv_t *amp_agent_ctrl_add_tbr(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_add_tbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	int rh_code;
-	tbr_def_t def;
-	macdef_t mac;
-	rule_t *tbr = NULL;
-
-	ari_t *id = adm_get_parm_obj(parms, 0, AMP_TYPE_ARI);
-	uvast start = adm_get_parm_uvast(parms, 1, &success);
-	def.period = adm_get_parm_uvast(parms, 2, &success);
-	def.max_fire = adm_get_parm_uvast(parms, 3, &success);
-	ac_t action = ac_copy(adm_get_parm_obj(parms, 4, AMP_TYPE_AC));
-
-	if(id == NULL)
-	{
-		AMP_DEBUG_ERR("ADD_TBR", "Bad parameters for control", NULL);
-		return result;
-	}
-
-	if((tbr = rule_create_tbr(*id, start, def, action)) == NULL)
-	{
-		AMP_DEBUG_ERR("ADD_TBR", "Unable to create TBR structure.", NULL);
-		return result;
-	}
-
-
-	if(VDB_FINDKEY_RULE(&(tbr->id)) == NULL)
-	{
-		int rh_code = VDB_ADD_RULE(&(tbr->id), tbr);
-
-		if(rh_code != RH_OK)
-		{
-			rule_release(tbr, 1);
-		}
-		else
-		{
-			gAgentInstr.num_tbrs++;
-			*status = CTRL_SUCCESS;
-			db_persist_rule(tbr);
-		}
-	}
-	else
-	{
-		*status = CTRL_SUCCESS;
-		AMP_DEBUG_WARN("ADD_TBR","Ignoring duplicate item.", NULL);
-		rule_release(tbr, 1);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_add_tbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control configures a new state-based rule(SBR) definition on the Agent.
- */
-tnv_t *amp_agent_ctrl_add_sbr(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_add_sbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	sbr_def_t def;
-	rule_t *sbr = NULL;
-	int success;
-	int rh_code;
-
-	ari_t *id = adm_get_parm_obj(parms, 0, AMP_TYPE_ARI);
-	uvast start = adm_get_parm_uvast(parms, 1, &success);
-	expr_t *state = adm_get_parm_obj(parms, 2, AMP_TYPE_EXPR);
-	def.expr = expr_copy(*state);
-	def.max_eval = adm_get_parm_uvast(parms, 3, &success);
-	def.max_fire = adm_get_parm_uvast(parms, 4, &success);
-	ac_t action = ac_copy(adm_get_parm_obj(parms, 5, AMP_TYPE_AC));
-
-	if(id == NULL)
-	{
-		AMP_DEBUG_ERR("ADD_SBR", "Bad parameters for control", NULL);
-		return result;
-	}
-
-	if((sbr = rule_create_sbr(*id, start, def, action)) == NULL)
-	{
-		AMP_DEBUG_ERR("ADD_SBR", "Unable to create SBR structure.", NULL);
-		return result;
-	}
-
-	if(VDB_FINDKEY_RULE(&(sbr->id)) == NULL)
-	{
-		int rh_code = VDB_ADD_RULE(&(sbr->id), sbr);
-
-		if(rh_code != RH_OK)
-		{
-			rule_release(sbr, 1);
-		}
-		else
-		{
-			gAgentInstr.num_sbrs++;
-			*status = CTRL_SUCCESS;
-			db_persist_rule(sbr);
-		}
-	}
-	else
-	{
-		*status = CTRL_SUCCESS;
-		AMP_DEBUG_WARN("ADD_SBR","Ignoring duplicate item.", NULL);
-		rule_release(sbr, 1);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_add_sbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control removes one or more rule definitions from the Agent.
- */
-tnv_t *amp_agent_ctrl_del_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_del_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	vecit_t it;
-	ac_t *ids = adm_get_parm_obj(parms, 0, AMP_TYPE_AC);
-
-	if(ids == NULL)
-	{
-		AMP_DEBUG_ERR("DEL_RULE", "Bad parameters.", NULL);
-		return result;
-	}
-
-	for(it = vecit_first(&(ids->values)); vecit_valid(it); it = vecit_next(it))
-	{
-		ari_t *cur_id = vecit_data(it);
-		rule_t *rule = VDB_FINDKEY_RULE(cur_id);
-
-		if(rule == NULL)
-		{
-			AMP_DEBUG_WARN("DEL_RULE", "Cannot find RULE to be deleted.", NULL);
-		}
-		else
-		{
-			db_forget(&(rule->desc), gDB.rules);
-			VDB_DELKEY_RULE(cur_id);
-		}
-	}
-
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_del_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control produces a detailed description of one or more rules known to the Agent.
- */
-tnv_t *amp_agent_ctrl_desc_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_desc_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	vecit_t ac_it;
-	int i = 0;
-	ac_t *ids = adm_get_parm_obj(parms, 0, AMP_TYPE_AC);
-
-	if(ids == NULL)
-	{
-		AMP_DEBUG_ERR("DESC_RULE", "Bad parameters.", NULL);
-		return result;
-	}
-
-	tnvc_t *tnvc = tnvc_create(vec_num_entries(ids->values));
-
-	/* For each rule being described. */
-	for(ac_it = vecit_first(&(ids->values)); vecit_valid(ac_it); ac_it = vecit_next(ac_it))
-	{
-		ari_t *cur_id = vecit_data(ac_it);
-		rule_t *rule = VDB_FINDKEY_RULE(cur_id);
-
-		if(rule == NULL)
-		{
-			AMP_DEBUG_WARN("DESC_RULE","Cannot find RULE for item %d.", i);
-		}
-		else
-		{
-			tnv_t *val = tnv_from_obj(rule->id.type, rule_copy_ptr(rule));
-			tnvc_insert(tnvc, val);
-		}
-	}
-
-	result = tnv_from_obj(AMP_TYPE_TNVC, tnvc);
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_desc_rule BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control stores variables.
- */
-tnv_t *amp_agent_ctrl_store_var(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_store_var BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	ari_t *id = adm_get_parm_obj(parms, 0, AMP_TYPE_ARI);
-	expr_t *expr = adm_get_parm_obj(parms, 1, AMP_TYPE_EXPR);
-
-	var_t *var = VDB_FINDKEY_VAR(id);
-
-	if(var == NULL)
-	{
-		AMP_DEBUG_ERR("stor_var","Cannot find variable.", NULL);
-		return result;
-	}
-
-	tnv_t *tmp = expr_eval(expr);
-	if(tmp != NULL)
-	{
-		tnv_release(var->value, 1);
-		var->value = tmp;
-		*status = CTRL_SUCCESS;
-	}
-	else
-	{
-		AMP_DEBUG_ERR("stor_var","unable to assign new value.", NULL);
-	}
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_store_var BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control resets all Agent ADM statistics reported in the Agent ADM report.
- */
-tnv_t *amp_agent_ctrl_reset_counts(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_reset_counts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	agent_instr_clear();
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_reset_counts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* OP Functions */
-
-/*
- * Int32 addition
- */
-tnv_t *amp_agent_op_plusint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_plusint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = amp_agent_binary_num_op(PLUS, stack, AMP_TYPE_INT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_plusint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int32 addition
- */
-tnv_t *amp_agent_op_plusuint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_plusuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(PLUS, stack, AMP_TYPE_UINT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_plusuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int64 addition
- */
-tnv_t *amp_agent_op_plusvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_plusvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(PLUS, stack, AMP_TYPE_VAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_plusvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int64 addition
- */
-tnv_t *amp_agent_op_plusuvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_plusuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(PLUS, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_plusuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real32 addition
- */
-tnv_t *amp_agent_op_plusreal32(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_plusreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = amp_agent_binary_num_op(PLUS, stack, AMP_TYPE_REAL32);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_plusreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real64 addition
- */
-tnv_t *amp_agent_op_plusreal64(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_plusreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(PLUS, stack, AMP_TYPE_REAL64);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_plusreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int32 subtraction
- */
-tnv_t *amp_agent_op_minusint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_minusint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MINUS, stack, AMP_TYPE_INT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_minusint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int32 subtraction
- */
-tnv_t *amp_agent_op_minusuint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_minusuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MINUS, stack, AMP_TYPE_UINT);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_minusuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int64 subtraction
- */
-tnv_t *amp_agent_op_minusvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_minusvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MINUS, stack, AMP_TYPE_VAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_minusvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int64 subtraction
- */
-tnv_t *amp_agent_op_minusuvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_minusuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MINUS, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_minusuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real32 subtraction
- */
-tnv_t *amp_agent_op_minusreal32(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_minusreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MINUS, stack, AMP_TYPE_REAL32);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_minusreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real64 subtraction
- */
-tnv_t *amp_agent_op_minusreal64(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_minusreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MINUS, stack, AMP_TYPE_REAL64);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_minusreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int32 multiplication
- */
-tnv_t *amp_agent_op_multint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_multint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MULT, stack, AMP_TYPE_INT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_multint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int32 multiplication
- */
-tnv_t *amp_agent_op_multuint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_multuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MULT, stack, AMP_TYPE_UINT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_multuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int64 multiplication
- */
-tnv_t *amp_agent_op_multvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_multvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MULT, stack, AMP_TYPE_VAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_multvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int64 multiplication
- */
-tnv_t *amp_agent_op_multuvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_multuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MULT, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_multuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real32 multiplication
- */
-tnv_t *amp_agent_op_multreal32(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_multreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MULT, stack, AMP_TYPE_REAL32);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_multreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real64 multiplication
- */
-tnv_t *amp_agent_op_multreal64(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_multreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MULT, stack, AMP_TYPE_REAL64);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_multreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int32 division
- */
-tnv_t *amp_agent_op_divint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_divint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(DIV, stack, AMP_TYPE_INT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_divint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int32 division
- */
-tnv_t *amp_agent_op_divuint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_divuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(DIV, stack, AMP_TYPE_UINT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_divuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int64 division
- */
-tnv_t *amp_agent_op_divvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_divvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(DIV, stack, AMP_TYPE_VAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_divvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int64 division
- */
-tnv_t *amp_agent_op_divuvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_divuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(DIV, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_divuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real32 division
- */
-tnv_t *amp_agent_op_divreal32(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_divreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(DIV, stack, AMP_TYPE_REAL32);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_divreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real64 division
- */
-tnv_t *amp_agent_op_divreal64(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_divreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(DIV, stack, AMP_TYPE_REAL64);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_divreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int32 modulus division
- */
-tnv_t *amp_agent_op_modint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_modint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MOD, stack, AMP_TYPE_INT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_modint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int32 modulus division
- */
-tnv_t *amp_agent_op_moduint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_moduint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = amp_agent_binary_num_op(MOD, stack, AMP_TYPE_UINT);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_moduint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int64 modulus division
- */
-tnv_t *amp_agent_op_modvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_modvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MOD, stack, AMP_TYPE_VAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_modvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int64 modulus division
- */
-tnv_t *amp_agent_op_moduvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_moduvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MOD, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_moduvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real32 modulus division
- */
-tnv_t *amp_agent_op_modreal32(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_modreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = amp_agent_binary_num_op(MOD, stack, AMP_TYPE_REAL32);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_modreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real64 modulus division
- */
-tnv_t *amp_agent_op_modreal64(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_modreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(MOD, stack, AMP_TYPE_REAL64);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_modreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int32 exponentiation
- */
-tnv_t *amp_agent_op_expint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_expint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(EXP, stack, AMP_TYPE_INT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_expint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned int32 exponentiation
- */
-tnv_t *amp_agent_op_expuint(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_expuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(EXP, stack, AMP_TYPE_UINT);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_expuint BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Int64 exponentiation
- */
-tnv_t *amp_agent_op_expvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_expvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = amp_agent_binary_num_op(EXP, stack, AMP_TYPE_VAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_expvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Unsigned Int64 exponentiation
- */
-tnv_t *amp_agent_op_expuvast(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_expuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(EXP, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_expuvast BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real32 exponentiation
- */
-tnv_t *amp_agent_op_expreal32(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_expreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(EXP, stack, AMP_TYPE_REAL32);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_expreal32 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Real64 exponentiation
- */
-tnv_t *amp_agent_op_expreal64(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_expreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(EXP, stack, AMP_TYPE_REAL64);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_expreal64 BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Bitwise and
- */
-tnv_t *amp_agent_op_bitand(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_bitand BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(BITAND, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_bitand BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Bitwise or
- */
-tnv_t *amp_agent_op_bitor(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_bitor BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(BITOR, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_bitor BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Bitwise xor
- */
-tnv_t *amp_agent_op_bitxor(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_bitxor BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(BITXOR, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_bitxor BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Bitwise not
- */
-tnv_t *amp_agent_op_bitnot(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_bitnot BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_unary_num_op(BITNOT, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_bitnot BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Logical and
- */
-tnv_t *amp_agent_op_logand(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_logand BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = adm_agent_binary_log_op(LOGAND, stack);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_logand BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Logical or
- */
-tnv_t *amp_agent_op_logor(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_logor BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_binary_log_op(LOGOR, stack);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_logor BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Logical not
- */
-tnv_t *amp_agent_op_lognot(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_lognot BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_binary_log_op(LOGNOT, stack);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_lognot BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * absolute value
- */
-tnv_t *amp_agent_op_abs(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_abs BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_unary_num_op(ABS, stack, AMP_TYPE_UVAST);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_abs BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * <
- */
-tnv_t *amp_agent_op_lessthan(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_lessthan BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_binary_log_op(LT, stack);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_lessthan BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * >
- */
-tnv_t *amp_agent_op_greaterthan(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_greaterthan BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_binary_log_op(GT, stack);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_greaterthan BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * <=
- */
-tnv_t *amp_agent_op_lessequal(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_lessequal BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_binary_log_op(LTE, stack);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_lessequal BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * >=
- */
-tnv_t *amp_agent_op_greaterequal(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_greaterequal BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_binary_log_op(GTE, stack);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_greaterequal BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * !=
- */
-tnv_t *amp_agent_op_notequal(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_notequal BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_binary_log_op(NEQ, stack);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_notequal BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * ==
- */
-tnv_t *amp_agent_op_equal(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_equal BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = adm_agent_binary_log_op(EQ, stack);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_equal BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * <<
- */
-tnv_t *amp_agent_op_bitshiftleft(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_bitshiftleft BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = amp_agent_binary_num_op(BITLSHFT, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_bitshiftleft BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * >>
- */
-tnv_t *amp_agent_op_bitshiftright(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_bitshiftright BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = amp_agent_binary_num_op(BITRSHFT, stack, AMP_TYPE_UVAST);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_bitshiftright BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Store value of parm 2 in parm 1
- */
-tnv_t *amp_agent_op_stor(vector_t *stack)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION op_stor BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	AMP_DEBUG_ERR("stor","Not Implemented.", NULL);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION op_stor BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
diff --git a/nm/agent/adm_amp_agent_impl.h b/nm/agent/adm_amp_agent_impl.h
deleted file mode 100644
index 0eabd374..00000000
--- a/nm/agent/adm_amp_agent_impl.h
+++ /dev/null
@@ -1,194 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_amp_agent_impl.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-16  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-#ifndef ADM_AMP_AGENT_IMPL_H_
-#define ADM_AMP_AGENT_IMPL_H_
-
-/*   START CUSTOM INCLUDES HERE  */
-/*             TODO              */
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/utils/utils.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-#include "shared/primitives/tnv.h"
-
-/*   START typeENUM */
-
-typedef enum
-{
-  PLUS,
-  MINUS,
-  MULT,
-  DIV,
-  MOD,
-  EXP,
-  BITAND,
-  BITOR,
-  BITXOR,
-  BITNOT,
-  LOGAND,
-  LOGOR,
-  LOGNOT,
-  ABS,
-  LT,
-  GT,
-  LTE,
-  GTE,
-  NEG,
-  NEQ,
-  EQ,
-  BITLSHFT,
-  BITRSHFT
-} amp_agent_op_e;
-
-/*   STOP typeENUM  */
-
-void name_adm_init_agent();
-
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                     Retrieval Functions                                     +
- * +---------------------------------------------------------------------------------------------+
- */
-/*   START CUSTOM FUNCTIONS HERE */
-
-void amp_agent_collect_ari_keys(rh_elt_t *elt, void *tag);
-int amp_agent_build_ari_table(tbl_t *table, rhht_t *ht);
-int adm_agent_op_prep(uint8_t num, tnv_t **lval, tnv_t **rval, vector_t *stack);
-tnv_t *amp_agent_binary_num_op(amp_agent_op_e op, vector_t *stack, amp_type_e result_type);
-tnv_t *adm_agent_unary_num_op(amp_agent_op_e op, vector_t *stack, amp_type_e result_type);
-
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void amp_agent_setup();
-void amp_agent_cleanup();
-
-
-/* Metadata Functions */
-tnv_t *amp_agent_meta_name(tnvc_t *parms);
-tnv_t *amp_agent_meta_namespace(tnvc_t *parms);
-tnv_t *amp_agent_meta_version(tnvc_t *parms);
-tnv_t *amp_agent_meta_organization(tnvc_t *parms);
-
-/* Constant Functions */
-tnv_t *amp_agent_get_amp_epoch(tnvc_t *parms);
-
-/* Collect Functions */
-tnv_t *amp_agent_get_num_rpt_tpls(tnvc_t *parms);
-tnv_t *amp_agent_get_num_tbl_tpls(tnvc_t *parms);
-tnv_t *amp_agent_get_sent_reports(tnvc_t *parms);
-tnv_t *amp_agent_get_num_tbr(tnvc_t *parms);
-tnv_t *amp_agent_get_run_tbr(tnvc_t *parms);
-tnv_t *amp_agent_get_num_sbr(tnvc_t *parms);
-tnv_t *amp_agent_get_run_sbr(tnvc_t *parms);
-tnv_t *amp_agent_get_num_const(tnvc_t *parms);
-tnv_t *amp_agent_get_num_var(tnvc_t *parms);
-tnv_t *amp_agent_get_num_macros(tnvc_t *parms);
-tnv_t *amp_agent_get_run_macros(tnvc_t *parms);
-tnv_t *amp_agent_get_num_controls(tnvc_t *parms);
-tnv_t *amp_agent_get_run_controls(tnvc_t *parms);
-tnv_t *amp_agent_get_cur_time(tnvc_t *parms);
-
-
-/* Control Functions */
-tnv_t *amp_agent_ctrl_add_var(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_del_var(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_add_rptt(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_del_rptt(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_desc_rptt(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_gen_rpts(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_gen_tbls(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_add_macro(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_del_macro(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_desc_macro(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_add_tbr(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_add_sbr(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_del_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_desc_rule(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_store_var(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *amp_agent_ctrl_reset_counts(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-
-
-/* OP Functions */
-tnv_t *amp_agent_op_plusint(vector_t *stack);
-tnv_t *amp_agent_op_plusuint(vector_t *stack);
-tnv_t *amp_agent_op_plusvast(vector_t *stack);
-tnv_t *amp_agent_op_plusuvast(vector_t *stack);
-tnv_t *amp_agent_op_plusreal32(vector_t *stack);
-tnv_t *amp_agent_op_plusreal64(vector_t *stack);
-tnv_t *amp_agent_op_minusint(vector_t *stack);
-tnv_t *amp_agent_op_minusuint(vector_t *stack);
-tnv_t *amp_agent_op_minusvast(vector_t *stack);
-tnv_t *amp_agent_op_minusuvast(vector_t *stack);
-tnv_t *amp_agent_op_minusreal32(vector_t *stack);
-tnv_t *amp_agent_op_minusreal64(vector_t *stack);
-tnv_t *amp_agent_op_multint(vector_t *stack);
-tnv_t *amp_agent_op_multuint(vector_t *stack);
-tnv_t *amp_agent_op_multvast(vector_t *stack);
-tnv_t *amp_agent_op_multuvast(vector_t *stack);
-tnv_t *amp_agent_op_multreal32(vector_t *stack);
-tnv_t *amp_agent_op_multreal64(vector_t *stack);
-tnv_t *amp_agent_op_divint(vector_t *stack);
-tnv_t *amp_agent_op_divuint(vector_t *stack);
-tnv_t *amp_agent_op_divvast(vector_t *stack);
-tnv_t *amp_agent_op_divuvast(vector_t *stack);
-tnv_t *amp_agent_op_divreal32(vector_t *stack);
-tnv_t *amp_agent_op_divreal64(vector_t *stack);
-tnv_t *amp_agent_op_modint(vector_t *stack);
-tnv_t *amp_agent_op_moduint(vector_t *stack);
-tnv_t *amp_agent_op_modvast(vector_t *stack);
-tnv_t *amp_agent_op_moduvast(vector_t *stack);
-tnv_t *amp_agent_op_modreal32(vector_t *stack);
-tnv_t *amp_agent_op_modreal64(vector_t *stack);
-tnv_t *amp_agent_op_expint(vector_t *stack);
-tnv_t *amp_agent_op_expuint(vector_t *stack);
-tnv_t *amp_agent_op_expvast(vector_t *stack);
-tnv_t *amp_agent_op_expuvast(vector_t *stack);
-tnv_t *amp_agent_op_expreal32(vector_t *stack);
-tnv_t *amp_agent_op_expreal64(vector_t *stack);
-tnv_t *amp_agent_op_bitand(vector_t *stack);
-tnv_t *amp_agent_op_bitor(vector_t *stack);
-tnv_t *amp_agent_op_bitxor(vector_t *stack);
-tnv_t *amp_agent_op_bitnot(vector_t *stack);
-tnv_t *amp_agent_op_logand(vector_t *stack);
-tnv_t *amp_agent_op_logor(vector_t *stack);
-tnv_t *amp_agent_op_lognot(vector_t *stack);
-tnv_t *amp_agent_op_abs(vector_t *stack);
-tnv_t *amp_agent_op_lessthan(vector_t *stack);
-tnv_t *amp_agent_op_greaterthan(vector_t *stack);
-tnv_t *amp_agent_op_lessequal(vector_t *stack);
-tnv_t *amp_agent_op_greaterequal(vector_t *stack);
-tnv_t *amp_agent_op_notequal(vector_t *stack);
-tnv_t *amp_agent_op_equal(vector_t *stack);
-tnv_t *amp_agent_op_bitshiftleft(vector_t *stack);
-tnv_t *amp_agent_op_bitshiftright(vector_t *stack);
-tnv_t *amp_agent_op_stor(vector_t *stack);
-
-
-/* Table Build Functions */
-tbl_t *amp_agent_tblt_adms(ari_t *id);
-tbl_t *amp_agent_tblt_variables(ari_t *id);
-tbl_t *amp_agent_tblt_rptts(ari_t *id);
-tbl_t *amp_agent_tblt_macros(ari_t *id);
-tbl_t *amp_agent_tblt_rules(ari_t *id);
-tbl_t *amp_agent_tblt_tblts(ari_t *id);
-
-#endif //ADM_AMP_AGENT_IMPL_H_
diff --git a/nm/agent/adm_ion_admin_agent.c b/nm/agent/adm_ion_admin_agent.c
deleted file mode 100644
index d876f3fb..00000000
--- a/nm/agent/adm_ion_admin_agent.c
+++ /dev/null
@@ -1,157 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_admin_agent.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ion_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "adm_ion_admin_impl.h"
-#include "agent/rda.h"
-
-
-
-#define _HAVE_DTN_ION_IONADMIN_ADM_
-#ifdef _HAVE_DTN_ION_IONADMIN_ADM_
-
-static vec_idx_t g_dtn_ion_ionadmin_idx[11];
-
-void dtn_ion_ionadmin_init()
-{
-	adm_add_adm_info("dtn_ion_ionadmin", ADM_ENUM_DTN_ION_IONADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_ionadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_ionadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_ionadmin_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_ionadmin_setup();
-	dtn_ion_ionadmin_init_meta();
-	dtn_ion_ionadmin_init_cnst();
-	dtn_ion_ionadmin_init_edd();
-	dtn_ion_ionadmin_init_op();
-	dtn_ion_ionadmin_init_var();
-	dtn_ion_ionadmin_init_ctrl();
-	dtn_ion_ionadmin_init_mac();
-	dtn_ion_ionadmin_init_rpttpl();
-	dtn_ion_ionadmin_init_tblt();
-}
-
-void dtn_ion_ionadmin_init_meta()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionadmin_idx[ADM_META_IDX], DTN_ION_IONADMIN_META_NAME), dtn_ion_ionadmin_meta_name);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionadmin_idx[ADM_META_IDX], DTN_ION_IONADMIN_META_NAMESPACE), dtn_ion_ionadmin_meta_namespace);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionadmin_idx[ADM_META_IDX], DTN_ION_IONADMIN_META_VERSION), dtn_ion_ionadmin_meta_version);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionadmin_idx[ADM_META_IDX], DTN_ION_IONADMIN_META_ORGANIZATION), dtn_ion_ionadmin_meta_organization);
-}
-
-void dtn_ion_ionadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_ionadmin_init_edd()
-{
-
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CLOCK_ERROR), dtn_ion_ionadmin_get_clock_error);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CLOCK_SYNC), dtn_ion_ionadmin_get_clock_sync);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CONGESTION_ALARM_CONTROL), dtn_ion_ionadmin_get_congestion_alarm_control);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CONGESTION_END_TIME_FORECASTS), dtn_ion_ionadmin_get_congestion_end_time_forecasts);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CONSUMPTION_RATE), dtn_ion_ionadmin_get_consumption_rate);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_INBOUND_FILE_SYSTEM_OCCUPANCY_LIMIT), dtn_ion_ionadmin_get_inbound_file_system_occupancy_limit);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_INBOUND_HEAP_OCCUPANCY_LIMIT), dtn_ion_ionadmin_get_inbound_heap_occupancy_limit);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_NUMBER), dtn_ion_ionadmin_get_number);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_OUTBOUND_FILE_SYSTEM_OCCUPANCY_LIMIT), dtn_ion_ionadmin_get_outbound_file_system_occupancy_limit);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_OUTBOUND_HEAP_OCCUPANCY_LIMIT), dtn_ion_ionadmin_get_outbound_heap_occupancy_limit);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_PRODUCTION_RATE), dtn_ion_ionadmin_get_production_rate);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_REF_TIME), dtn_ion_ionadmin_get_ref_time);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_TIME_DELTA), dtn_ion_ionadmin_get_time_delta);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_VERSION), dtn_ion_ionadmin_get_version);
-}
-
-void dtn_ion_ionadmin_init_op()
-{
-
-}
-
-void dtn_ion_ionadmin_init_var()
-{
-
-}
-
-void dtn_ion_ionadmin_init_ctrl()
-{
-
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_INIT, 2, dtn_ion_ionadmin_ctrl_node_init);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CLOCK_ERROR_SET, 1, dtn_ion_ionadmin_ctrl_node_clock_error_set);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CLOCK_SYNC_SET, 1, dtn_ion_ionadmin_ctrl_node_clock_sync_set);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONGESTION_ALARM_CONTROL_SET, 1, dtn_ion_ionadmin_ctrl_node_congestion_alarm_control_set);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONGESTION_END_TIME_FORECASTS_SET, 1, dtn_ion_ionadmin_ctrl_node_congestion_end_time_forecasts_set);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONSUMPTION_RATE_SET, 1, dtn_ion_ionadmin_ctrl_node_consumption_rate_set);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONTACT_ADD, 6, dtn_ion_ionadmin_ctrl_node_contact_add);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONTACT_DEL, 3, dtn_ion_ionadmin_ctrl_node_contact_del);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_INBOUND_HEAP_OCCUPANCY_LIMIT_SET, 2, dtn_ion_ionadmin_ctrl_node_inbound_heap_occupancy_limit_set);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_OUTBOUND_HEAP_OCCUPANCY_LIMIT_SET, 2, dtn_ion_ionadmin_ctrl_node_outbound_heap_occupancy_limit_set);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_PRODUCTION_RATE_SET, 1, dtn_ion_ionadmin_ctrl_node_production_rate_set);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_RANGE_ADD, 5, dtn_ion_ionadmin_ctrl_node_range_add);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_RANGE_DEL, 3, dtn_ion_ionadmin_ctrl_node_range_del);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_REF_TIME_SET, 1, dtn_ion_ionadmin_ctrl_node_ref_time_set);
-	adm_add_ctrldef(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_TIME_DELTA_SET, 1, dtn_ion_ionadmin_ctrl_node_time_delta_set);
-}
-
-void dtn_ion_ionadmin_init_mac()
-{
-
-}
-
-void dtn_ion_ionadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_ionadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* CONTACTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ionadmin_idx[ADM_TBLT_IDX], DTN_ION_IONADMIN_TBLT_CONTACTS), dtn_ion_ionadmin_tblt_contacts);
-	tblt_add_col(def, AMP_TYPE_TV, "start_time");
-	tblt_add_col(def, AMP_TYPE_TV, "stop_time");
-	tblt_add_col(def, AMP_TYPE_UINT, "source_node");
-	tblt_add_col(def, AMP_TYPE_UINT, "dest_node");
-	tblt_add_col(def, AMP_TYPE_UVAST, "xmit_data");
-	tblt_add_col(def, AMP_TYPE_UVAST, "confidence");
-	adm_add_tblt(def);
-
-	/* RANGES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ionadmin_idx[ADM_TBLT_IDX], DTN_ION_IONADMIN_TBLT_RANGES), dtn_ion_ionadmin_tblt_ranges);
-	tblt_add_col(def, AMP_TYPE_TV, "start");
-	tblt_add_col(def, AMP_TYPE_TV, "stop");
-	tblt_add_col(def, AMP_TYPE_UINT, "node");
-	tblt_add_col(def, AMP_TYPE_UINT, "other_node");
-	tblt_add_col(def, AMP_TYPE_UINT, "distance");
-	adm_add_tblt(def);
-}
-
-#endif // _HAVE_DTN_ION_IONADMIN_ADM_
diff --git a/nm/agent/adm_ion_admin_impl.c b/nm/agent/adm_ion_admin_impl.c
deleted file mode 100644
index 8387f786..00000000
--- a/nm/agent/adm_ion_admin_impl.c
+++ /dev/null
@@ -1,1307 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_admin_impl.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "rfx.h"
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/adm/adm.h"
-#include "adm_ion_admin_impl.h"
-
-/*   START CUSTOM FUNCTIONS HERE */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_ionadmin_setup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-void dtn_ion_ionadmin_cleanup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-
-/* Metadata Functions */
-
-
-tnv_t *dtn_ion_ionadmin_meta_name(tnvc_t *parms)
-{
-	return tnv_from_str("ion_admin");
-}
-
-
-tnv_t *dtn_ion_ionadmin_meta_namespace(tnvc_t *parms)
-{
-	return tnv_from_str("DTN/ION/ionadmin");
-}
-
-
-tnv_t *dtn_ion_ionadmin_meta_version(tnvc_t *parms)
-{
-	return tnv_from_str("v0.0");
-}
-
-
-tnv_t *dtn_ion_ionadmin_meta_organization(tnvc_t *parms)
-{
-	return tnv_from_str("JHUAPL");
-}
-
-
-/* Constant Functions */
-/* Table Functions */
-
-
-/*
- * This table shows all scheduled periods of data transmission.
- */
-tbl_t *dtn_ion_ionadmin_tblt_contacts(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_contacts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	Sdr             sdr = getIonsdr();
-	PsmPartition    ionwm = getIonwm();
-	IonVdb          *vdb = getIonVdb();
-	PsmAddress      elt;
-	PsmAddress      addr;
-	IonCXref        *contact;
-	tnvc_t *cur_row = NULL;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (elt = sm_rbt_first(ionwm, vdb->contactIndex); elt;
-			elt = sm_rbt_next(ionwm, elt))
-	{
-		addr = sm_rbt_data(ionwm, elt);
-		CHKNULL(addr);
-
-		if((contact = (IonCXref *) psp(getIonwm(), addr)) == NULL)
-		{
-			AMP_DEBUG_WARN("dtn_ion_ionadmin_tblt_contacts","NULL contact encountered. Skipping.", NULL);
-			continue;
-		}
-
-		 /* Table is: (TV)Start, (TV)Stop, (UINT)Src Node, (UINT)Dest Node, (UVAST)Xmit, (UVAST)Confidence */
-		if((cur_row = tnvc_create(6)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_tv((uvast)(contact->fromTime)));
- 			tnvc_insert(cur_row, tnv_from_tv((uvast)(contact->toTime)));
-			tnvc_insert(cur_row, tnv_from_uint(contact->fromNode));
-			tnvc_insert(cur_row, tnv_from_uint(contact->toNode));
-			tnvc_insert(cur_row, tnv_from_uvast(contact->xmitRate));
-			tnvc_insert(cur_row, tnv_from_uvast(contact->confidence));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_ionadmin_tblt_contacts", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_contacts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * This table shows all predicted periods of constant distance between nodes.
- */
-tbl_t *dtn_ion_ionadmin_tblt_ranges(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_ranges BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr             sdr = getIonsdr();
-	PsmPartition    ionwm = getIonwm();
-	IonVdb          *vdb = getIonVdb();
-	PsmAddress      elt;
-	PsmAddress      addr;
-	IonRXref        *range = NULL;
-	tnvc_t *cur_row = NULL;
-
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (elt = sm_rbt_first(ionwm, vdb->rangeIndex); elt;
-			elt = sm_rbt_next(ionwm, elt))
-	{
-		addr = sm_rbt_data(ionwm, elt);
-		CHKNULL(addr);
-
-        if((range = (IonRXref *) psp(getIonwm(), addr)) == NULL)
-        {
-			AMP_DEBUG_WARN("dtn_ion_ionadmin_tblt_ranges","NULL contact encountered. Skipping.", NULL);
-			continue;
-		}
-
-		 /* Table is: (TV)Start, (TV)Stop, (UINT) Node, (UINT)Other Node, (UINT) Dist */
-		if((cur_row = tnvc_create(5)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_uvast(range->fromTime));
-			tnvc_insert(cur_row, tnv_from_uvast(range->toTime));
-			tnvc_insert(cur_row, tnv_from_uint(range->fromNode));
-			tnvc_insert(cur_row, tnv_from_uint(range->toNode));
-			tnvc_insert(cur_row, tnv_from_uint(range->owlt));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_ionadmin_tblt_contacts", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	  sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_ranges BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/* Collect Functions */
-/*
- * This is how accurate the ION Agent's clock is described as number of seconds, an absolute value.
- */
-tnv_t *dtn_ion_ionadmin_get_clock_error(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_clock_error BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	 Sdr     sdr = getIonsdr();
-	 Object  iondbObj = getIonDbObject();
-	 IonDB   iondb;
-
-	 CHKNULL(sdr_begin_xn(sdr));
-	 sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-	 result = tnv_from_int(iondb.maxClockError);
-	 sdr_end_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_clock_error BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is whether or not the the computer on which the local ION node is running has a synchronized cl
- * ock.
- */
-tnv_t *dtn_ion_ionadmin_get_clock_sync(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_clock_sync BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	Sdr     sdr;
-	Object  iondbObj;
-	IonDB   iondb;
-
-	sdr = getIonsdr();
-	iondbObj = getIonDbObject();
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-	result = tnv_from_int(iondb.clockIsSynchronized);
-	sdr_end_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_clock_sync BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is whether or not the node has a control that will set off alarm if it will become congested at
- *  some future time.
- */
-tnv_t *dtn_ion_ionadmin_get_congestion_alarm_control(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_congestion_alarm_control BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-	char    alarmBuffer[40 + TIMESTAMPBUFSZ]; // Pulled from ION
-
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-
-
-	if (iondb.alarmScript)
-	{
-		memset(alarmBuffer,0,sizeof(alarmBuffer));
-		sdr_string_read(sdr, alarmBuffer, iondb.alarmScript);
-		result = tnv_from_str(alarmBuffer);
-	}
-
-	sdr_end_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_congestion_alarm_control BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the time horizon beyond which we don't attempt to forecast congestion
- */
-tnv_t *dtn_ion_ionadmin_get_congestion_end_time_forecasts(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_congestion_end_time_forecasts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-	result = tnv_from_uint(iondb.horizon);
-	sdr_end_xn(sdr);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_congestion_end_time_forecasts BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the mean rate of continuous data delivery to local BP applications.
- */
-tnv_t *dtn_ion_ionadmin_get_consumption_rate(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_consumption_rate BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-	result = tnv_from_uint(iondb.consumptionRate);
-	sdr_end_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_consumption_rate BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the maximum number of megabytes of storage space in ION's local file system that can be used
- *  for the storage of inbound zero-copy objects. The default heap limit is 1 Terabyte.
- */
-tnv_t *dtn_ion_ionadmin_get_inbound_file_system_occupancy_limit(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_inbound_file_system_occupancy_limit BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-	vast    fileLimit;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	fileLimit = zco_get_max_file_occupancy(sdr, ZcoInbound);
-	result = tnv_from_vast(fileLimit);
-	sdr_end_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_inbound_file_system_occupancy_limit BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the maximum number of megabytes of storage space in ION's SDR non-volatile heap that can be 
- * used for the storage of inbound zero-copy objects. The default heap limit is 20% of the SDR data spa
- * ce's total heap size.
- */
-tnv_t *dtn_ion_ionadmin_get_inbound_heap_occupancy_limit(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_inbound_heap_occupancy_limit BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-	vast    heapLimit;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	heapLimit = zco_get_max_heap_occupancy(sdr, ZcoInbound);
-	result = tnv_from_vast(heapLimit);
-	sdr_end_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_inbound_heap_occupancy_limit BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is a CBHE node number which uniquely identifies the node in the delay-tolerant network.
- */
-tnv_t *dtn_ion_ionadmin_get_number(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_number BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-	
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-	result = tnv_from_uvast(iondb.ownNodeNbr);
-	sdr_end_xn(sdr);
-	  
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_number BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the maximum number of megabytes of storage space in ION's local file system that can be used
- *  for the storage of outbound zero-copy objects. The default heap limit is 1 Terabyte.
- */
-tnv_t *dtn_ion_ionadmin_get_outbound_file_system_occupancy_limit(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_outbound_file_system_occupancy_limit BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-	vast    fileLimit;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	fileLimit = zco_get_max_file_occupancy(sdr, ZcoOutbound);
-	result = tnv_from_vast(fileLimit);
-	sdr_end_xn(sdr);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_outbound_file_system_occupancy_limit BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the maximum number of megabytes of storage space in ION's SDR non-volatile heap that can be 
- * used for the storage of outbound zero-copy objects. The default heap limit is 20% of the SDR data sp
- * ace's total heap size.
- */
-tnv_t *dtn_ion_ionadmin_get_outbound_heap_occupancy_limit(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_outbound_heap_occupancy_limit BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-	vast    heapLimit;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	heapLimit = zco_get_max_heap_occupancy(sdr, ZcoOutbound);
-	result = tnv_from_vast(heapLimit);
-	sdr_end_xn(sdr);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_outbound_heap_occupancy_limit BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the rate of local data production.
- */
-tnv_t *dtn_ion_ionadmin_get_production_rate(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_production_rate BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr sdr = getIonsdr();
-	Object iondbObj = getIonDbObject();
-	IonDB iondb;
-	  
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-	result = tnv_from_int(iondb.productionRate);
-	sdr_end_xn(sdr);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_production_rate BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the reference time that will be used for interpreting relative time values from now until th
- * e next revision of reference time.
- */
-tnv_t *dtn_ion_ionadmin_get_ref_time(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_ref_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_ref_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The time delta is used to compensate for error (drift) in clocks, particularly spacecraft clocks. Th
- * e hardware clock on a spacecraft might gain or lose a few seconds every month, to the point at which
- *  its understanding of the current time - as reported out by the operating system - might differ sign
- * ificantly from the actual value of Unix Epoch time as reported by authoritative clocks on Earth. To 
- * compensate for this difference without correcting the clock itself (which can be difficult and dange
- * rous), ION simply adds the time delta to the Epoch time reported by the operating system.
- */
-tnv_t *dtn_ion_ionadmin_get_time_delta(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_time_delta BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-		
-	Sdr sdr = getIonsdr();
-	Object iondbObj = getIonDbObject();
-	IonDB iondb;
-	  
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-	result = tnv_from_int(iondb.deltaFromUTC);
-	sdr_end_xn(sdr);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_time_delta BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is the version of ION that is currently installed.
- */
-tnv_t *dtn_ion_ionadmin_get_version(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	char buffer[80]; // pulled from ionadmin.c
-	isprintf(buffer, sizeof(buffer), "%s", IONVERSIONNUMBER);
-	result = tnv_from_str(buffer);
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* Control Functions */
-
-/*
- * Until this control is executed, the local ION node does not exist and most ionadmin controls will fa
- * il. The control configures the local node to be identified by node_number, a CBHE node number which 
- * uniquely identifies the node in the delay-tolerant network.  It also configures ION's data space (SD
- * R) and shared working-memory region.  For this purpose it uses a set of default settings if no argum
- * ent follows node_number or if the argument following node_number is ''; otherwise it uses the config
- * uration settings found in a configuration file.  If configuration file name is provided, then the co
- * nfiguration file's name is implicitly 'hostname.ionconfig'; otherwise, ion_config_filename is taken 
- * to be the explicit configuration file name.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_init(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_init BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_init BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This management control sets ION's understanding of the accuracy of the scheduled start and stop tim
- * es of planned contacts, in seconds.  The default value is 1.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_clock_error_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_clock_error_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	 Sdr      sdr = getIonsdr();
-	 Object   iondbObj = getIonDbObject();
-	 IonDB    iondb;
-	 uint32_t newMaxClockError;
-	 int      success = 0;
-
-
-	 newMaxClockError = adm_get_parm_uint(parms,0,&success);
-
-	 if ((success) && (newMaxClockError >= 60) && (newMaxClockError <= 60))
-	 {
-		 CHKNULL(sdr_begin_xn(sdr));
-		 sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-		 iondb.maxClockError = newMaxClockError;
-		 sdr_write(sdr, iondbObj, (char *) &iondb, sizeof(IonDB));
-		 sdr_end_xn(sdr);
-		 *status = CTRL_SUCCESS;
-	 }
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_clock_error_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This management control reports whether or not the computer on which the local ION node is running h
- * as a synchronized clock.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_clock_sync_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_clock_sync_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	 Sdr     sdr;
-	 Object  iondbObj;
-	 IonDB   iondb;
-	 int     newSyncVal;
-	 int     success = 0;
-
-	 newSyncVal = adm_get_parm_uint(parms,0,&success);
-
-	 if(success)
-	 {
-		 sdr = getIonsdr();
-		 iondbObj = getIonDbObject();
-		 CHKNULL(sdr_begin_xn(sdr));
-		 sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-		 iondb.clockIsSynchronized = (!(newSyncVal == 0));
-		 sdr_write(sdr, iondbObj, (char *) &iondb, sizeof(IonDB));
-		 sdr_end_xn(sdr);
-		 *status = CTRL_SUCCESS;
-	 }
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_clock_sync_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This management control establishes a control which will automatically be executed whenever ionadmin
- *  predicts that the node will become congested at some future time.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_congestion_alarm_control_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_congestion_alarm_control_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-	char    *newAlarmScript;
-
-	newAlarmScript = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	if(strlen(newAlarmScript) <= 255)
-	{
-
-		CHKNULL(sdr_begin_xn(sdr));
-		sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-        if (iondb.alarmScript != 0)
-        {
-        	sdr_free(sdr, iondb.alarmScript);
-        }
-
-        iondb.alarmScript = sdr_string_create(sdr, newAlarmScript);
-        sdr_write(sdr, iondbObj, (char *) &iondb, sizeof(IonDB));
-        sdr_end_xn(sdr);
-        *status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_congestion_alarm_control_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This management control sets the end time for computed congestion forecasts. Setting congestion fore
- * cast horizon to zero sets the congestion forecast end time to infinite time in the future: if there 
- * is any predicted net growth in bundle storage space occupancy at all, following the end of the last 
- * scheduled contact, then eventual congestion will be predicted. The default value is zero, i.e., no e
- * nd time.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_congestion_end_time_forecasts_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_congestion_end_time_forecasts_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	char    *horizonString;
-	time_t  refTime;
-	time_t  horizon;
-	IonDB   iondb;
-
-	horizonString = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	if (*horizonString == '0' && *(horizonString + 1) == 0)
-	{
-		horizon = 0;    /*      Remove horizon from database.   */
-	}
-	else
-	{
-//		refTime = _referenceTime(NULL); TODO: Figure out how to get this
-		//horizon = readTimestampUTC(horizonString, refTime);
-		horizon = readTimestampUTC(horizonString, 0);
-	}
-
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-	iondb.horizon = horizon;
-	sdr_write(sdr, iondbObj, (char *) &iondb, sizeof(IonDB));
-	sdr_end_xn(sdr);
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_congestion_end_time_forecasts_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This management control sets ION's expectation of the mean rate of continuous data delivery to local
- *  BP applications throughout the period of time over which congestion forecasts are computed. For nod
- * es that function only as routers this variable will normally be zero. A value of -1, which is the de
- * fault, indicates that the rate of local data consumption is unknown; in that case local data consump
- * tion is not considered in the computation of congestion forecasts.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_consumption_rate_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_consumption_rate_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr     sdr = getIonsdr();
-	Object  iondbObj = getIonDbObject();
-	IonDB   iondb;
-	int     newRate;
-	int 	success = 0;
-
-	newRate = adm_get_parm_uint(parms, 0, &success);
-
-	if(success)
-	{
-		if (newRate < 0)
-		{
-			newRate = -1;                   /*      Not metered.    */
-		}
-
-		CHKNULL(sdr_begin_xn(sdr));
-		sdr_stage(sdr, (char *) &iondb, iondbObj, sizeof(IonDB));
-		iondb.consumptionRate = newRate;
-		sdr_write(sdr, iondbObj, (char *) &iondb, sizeof(IonDB));
-		sdr_end_xn(sdr);
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_consumption_rate_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control schedules a period of data transmission from source_node to dest_node. The period of tr
- * ansmission will begin at start_time and end at stop_time, and the rate of data transmission will be 
- * xmit_data_rate bytes/second. Our confidence in the contact defaults to 1.0, indicating that the cont
- * act is scheduled - not that non-occurrence of the contact is impossible, just that occurrence of the
- *  contact is planned and scheduled rather than merely imputed from past node behavior. In the latter 
- * case, confidence indicates our estimation of the likelihood of this potential contact.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_contact_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_contact_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	time_t      fromTime = 0;
-	time_t      toTime = 0;
-	uvast       fromNodeNbr = 0;
-	uvast       toNodeNbr = 0;
-	uint32_t       regionNbr;
-	PsmAddress  xaddr;
-	uvast    	xmitRate;
-	uvast       confidence;
-	int     	success = 0;
-
-	fromTime = adm_get_parm_uint(parms, 0, &success);
-
-	if(success)
-	{
-		toTime = adm_get_parm_uint(parms, 1, &success);
-	}
-
-	if (toTime <= fromTime)
-	{
-		return NULL;
-	}
-
-	if(success)
-	{
-		fromNodeNbr = adm_get_parm_uvast(parms, 2, &success);
-	}
-
-	if(success)
-	{
-		toNodeNbr = adm_get_parm_uvast(parms, 3, &success);
-	}
-
-	oK(ionRegionOf(fromNodeNbr, toNodeNbr, &regionNbr));
-	if(success)
-	{
-		xmitRate = adm_get_parm_uvast(parms, 4, &success);
-	}
-
-	if(success)
-	{
-		confidence = adm_get_parm_uvast(parms, 5, &success);
-	}
-
-	if(success)
-	{
-		if(rfx_insert_contact(regionNbr, fromTime, toTime, fromNodeNbr,
-			toNodeNbr, xmitRate, confidence, &xaddr, 0) == 0)
-		{
-			*status = CTRL_SUCCESS;
-		}
-	}
-
-
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_contact_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control deletes the scheduled period of data transmission from source_node to dest_node startin
- * g at start_time. To delete all contacts between some pair of nodes, use '*' as start_time.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_contact_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_contact_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	time_t  timestamp = 0;
-	uvast   fromNodeNbr = 0;
-	uvast   toNodeNbr = 0;
-	int 	success = 0;
-	uint32_t	regionNbr;
-
-	timestamp = adm_get_parm_uint(parms, 0, &success);
-
-	if(success)
-	{
-		fromNodeNbr = adm_get_parm_uint(parms, 1, &success);
-	}
-	if(success)
-	{
-		toNodeNbr = adm_get_parm_uint(parms, 2, &success);
-	}
-
-	if(success)
-	{
-		// TODO refTime = _referenceTime(NULL);
-	    // TODO  timestamp = readTimestampUTC(tokens[2], refTime);
-
-		if (timestamp == 0)
-		{
-			return NULL;
-		}
-
-		oK(ionRegionOf(fromNodeNbr, toNodeNbr, &regionNbr));
-		if(rfx_remove_contact(regionNbr, &timestamp, fromNodeNbr,
-				toNodeNbr, 0) == 0)
-		{
-			// TODO _forecastNeeded(1);
-			*status = CTRL_SUCCESS;
-		}
-	}
-
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_contact_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This management control sets the maximum number of megabytes of storage space in ION's SDR non-volat
- * ile heap that can be used for the storage of inbound zero-copy objects. A value of -1 for either lim
- * it signifies 'leave unchanged'. The default heap limit is 30% of the SDR data space's total heap siz
- * e.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_inbound_heap_occupancy_limit_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_inbound_heap_occupancy_limit_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_inbound_heap_occupancy_limit_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This management control sets the maximum number of megabytes of storage space in ION's SDR non-volat
- * ile heap that can be used for the storage of outbound zero-copy objects.  A value of  -1 for either 
- * limit signifies 'leave unchanged'. The default heap  limit is 30% of the SDR data space's total heap
- *  size.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_outbound_heap_occupancy_limit_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_outbound_heap_occupancy_limit_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_outbound_heap_occupancy_limit_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This management control sets ION's expectation of the mean rate of continuous data origination by lo
- * cal BP applications throughout the period of time over which congestion forecasts are computed. For 
- * nodes that function only as routers this variable will normally be zero. A value of -1, which is the
- *  default, indicates that the rate of local data production is unknown; in that case local data produ
- * ction is not considered in the computation of congestion forecasts.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_production_rate_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_production_rate_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_production_rate_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control predicts a period of time during which the distance from node to other_node will be con
- * stant to within one light second. The period will begin at start_time and end at stop_time, and the 
- * distance between the nodes during that time will be distance light seconds.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_range_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_range_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	time_t  start = 0;
-	time_t  stop  = 0;
-	uint32_t    from_node = 0;
-	uint32_t    to_node   = 0;
-	uint32_t    distance  = 0;
-	int 	success   = 0;
-	PsmAddress xaddr;
-
-	start = adm_get_parm_uint(parms, 0, &success);
-
-	if(success)
-	{
-	  stop = adm_get_parm_uint(parms, 1, &success);
-	}
-	if(success)
-	{
-	  from_node = adm_get_parm_uint(parms, 2, &success);
-	}
-	if(success)
-	{
-	  to_node = adm_get_parm_uint(parms, 3, &success);
-	}
-	if(success)
-	{
-	  distance = adm_get_parm_uint(parms, 4, &success);
-	}   
-
-	if(success)
-	{
-	  if(stop <= start) 
-	  {
-	    return NULL;
-	  }
-	  
-	  if (rfx_insert_range(start, stop, from_node, to_node, distance,
-			&xaddr, 0) >= 0 && xaddr != 0)
-	  {
-	    *status = CTRL_SUCCESS;
-	  }
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_range_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control deletes the predicted period of constant distance between node and other_node starting 
- * at start_time. To delete all ranges between some pair of nodes, use '*' as start_time.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_range_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_range_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	
-	time_t  start = 0;
-	uint32_t    from_node = 0;
-	uint32_t    to_node   = 0;
-	int 	success   = 0;
-	PsmAddress xaddr;
-
-	start = adm_get_parm_uint(parms, 0, &success);
-
-	if(success)
-	{
-	  from_node = adm_get_parm_uint(parms, 1, &success);
-	}
-	if(success)
-	{
-	  to_node = adm_get_parm_uint(parms, 2, &success);
-	}
-
-	if(success)
-	{
-	  if(rfx_remove_range(&start, from_node, to_node, 0) >= 0)
-	  {
-	    *status = CTRL_SUCCESS;
-	  }
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_range_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This is used to set the reference time that will be used for interpreting relative time values from 
- * now until the next revision of reference time. Note that the new reference time can be a relative ti
- * me, i.e., an offset beyond the current reference time.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_ref_time_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_ref_time_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_ref_time_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This management control sets ION's understanding of the current difference between correct time and 
- * the Unix Epoch time values reported by the clock for the local ION node's computer. This delta is au
- * tomatically applied to locally obtained time values whenever ION needs to know the current time.
- */
-tnv_t *dtn_ion_ionadmin_ctrl_node_time_delta_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_node_time_delta_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_node_time_delta_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* OP Functions */
diff --git a/nm/agent/adm_ion_admin_impl.h b/nm/agent/adm_ion_admin_impl.h
deleted file mode 100644
index d28e0589..00000000
--- a/nm/agent/adm_ion_admin_impl.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_admin_impl.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-#ifndef ADM_ION_ADMIN_IMPL_H_
-#define ADM_ION_ADMIN_IMPL_H_
-
-/*   START CUSTOM INCLUDES HERE  */
-/*             TODO              */
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/utils/utils.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-#include "shared/primitives/tnv.h"
-
-/*   START typeENUM */
-/*             TODO              */
-/*   STOP typeENUM  */
-
-void name_adm_init_agent();
-
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                     Retrieval Functions                                     +
- * +---------------------------------------------------------------------------------------------+
- */
-/*   START CUSTOM FUNCTIONS HERE */
-/*             TODO              */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_ionadmin_setup();
-void dtn_ion_ionadmin_cleanup();
-
-
-/* Metadata Functions */
-tnv_t *dtn_ion_ionadmin_meta_name(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_meta_namespace(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_meta_version(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_meta_organization(tnvc_t *parms);
-
-/* Constant Functions */
-
-/* Collect Functions */
-tnv_t *dtn_ion_ionadmin_get_clock_error(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_clock_sync(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_congestion_alarm_control(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_congestion_end_time_forecasts(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_consumption_rate(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_inbound_file_system_occupancy_limit(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_inbound_heap_occupancy_limit(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_number(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_outbound_file_system_occupancy_limit(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_outbound_heap_occupancy_limit(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_production_rate(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_ref_time(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_time_delta(tnvc_t *parms);
-tnv_t *dtn_ion_ionadmin_get_version(tnvc_t *parms);
-
-
-/* Control Functions */
-tnv_t *dtn_ion_ionadmin_ctrl_node_init(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_clock_error_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_clock_sync_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_congestion_alarm_control_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_congestion_end_time_forecasts_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_consumption_rate_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_contact_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_contact_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_inbound_heap_occupancy_limit_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_outbound_heap_occupancy_limit_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_production_rate_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_range_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_range_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_ref_time_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionadmin_ctrl_node_time_delta_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-
-
-/* OP Functions */
-
-
-/* Table Build Functions */
-tbl_t *dtn_ion_ionadmin_tblt_contacts(ari_t *id);
-tbl_t *dtn_ion_ionadmin_tblt_ranges(ari_t *id);
-
-#endif //ADM_ION_ADMIN_IMPL_H_
diff --git a/nm/agent/adm_ion_ipn_admin_agent.c b/nm/agent/adm_ion_ipn_admin_agent.c
deleted file mode 100644
index ee12a3e7..00000000
--- a/nm/agent/adm_ion_ipn_admin_agent.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ipn_admin_agent.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ion_ipn_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "adm_ion_ipn_admin_impl.h"
-#include "agent/rda.h"
-
-
-
-#define _HAVE_DTN_ION_IPNADMIN_ADM_
-#ifdef _HAVE_DTN_ION_IPNADMIN_ADM_
-
-static vec_idx_t g_dtn_ion_ipnadmin_idx[11];
-
-void dtn_ion_ipnadmin_init()
-{
-	adm_add_adm_info("dtn_ion_ipnadmin", ADM_ENUM_DTN_ION_IPNADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IPNADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_ipnadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IPNADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_ipnadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IPNADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_ipnadmin_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IPNADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_ipnadmin_setup();
-	dtn_ion_ipnadmin_init_meta();
-	dtn_ion_ipnadmin_init_cnst();
-	dtn_ion_ipnadmin_init_edd();
-	dtn_ion_ipnadmin_init_op();
-	dtn_ion_ipnadmin_init_var();
-	dtn_ion_ipnadmin_init_ctrl();
-	dtn_ion_ipnadmin_init_mac();
-	dtn_ion_ipnadmin_init_rpttpl();
-	dtn_ion_ipnadmin_init_tblt();
-}
-
-void dtn_ion_ipnadmin_init_meta()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ipnadmin_idx[ADM_META_IDX], DTN_ION_IPNADMIN_META_NAME), dtn_ion_ipnadmin_meta_name);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ipnadmin_idx[ADM_META_IDX], DTN_ION_IPNADMIN_META_NAMESPACE), dtn_ion_ipnadmin_meta_namespace);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ipnadmin_idx[ADM_META_IDX], DTN_ION_IPNADMIN_META_VERSION), dtn_ion_ipnadmin_meta_version);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ipnadmin_idx[ADM_META_IDX], DTN_ION_IPNADMIN_META_ORGANIZATION), dtn_ion_ipnadmin_meta_organization);
-}
-
-void dtn_ion_ipnadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_edd()
-{
-
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ipnadmin_idx[ADM_EDD_IDX], DTN_ION_IPNADMIN_EDD_ION_VERSION), dtn_ion_ipnadmin_get_ion_version);
-}
-
-void dtn_ion_ipnadmin_init_op()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_var()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_ctrl()
-{
-
-	adm_add_ctrldef(g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_EXIT_ADD, 3, dtn_ion_ipnadmin_ctrl_exit_add);
-	adm_add_ctrldef(g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_EXIT_CHANGE, 3, dtn_ion_ipnadmin_ctrl_exit_change);
-	adm_add_ctrldef(g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_EXIT_DEL, 2, dtn_ion_ipnadmin_ctrl_exit_del);
-	adm_add_ctrldef(g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_PLAN_ADD, 2, dtn_ion_ipnadmin_ctrl_plan_add);
-	adm_add_ctrldef(g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_PLAN_CHANGE, 2, dtn_ion_ipnadmin_ctrl_plan_change);
-	adm_add_ctrldef(g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_PLAN_DEL, 1, dtn_ion_ipnadmin_ctrl_plan_del);
-}
-
-void dtn_ion_ipnadmin_init_mac()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* EXITS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ipnadmin_idx[ADM_TBLT_IDX], DTN_ION_IPNADMIN_TBLT_EXITS), dtn_ion_ipnadmin_tblt_exits);
-	tblt_add_col(def, AMP_TYPE_UVAST, "first_node_nbr");
-	tblt_add_col(def, AMP_TYPE_UVAST, "last_node_nbr");
-	tblt_add_col(def, AMP_TYPE_STR, "gateway_endpoint_id");
-	adm_add_tblt(def);
-
-	/* PLANS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ipnadmin_idx[ADM_TBLT_IDX], DTN_ION_IPNADMIN_TBLT_PLANS), dtn_ion_ipnadmin_tblt_plans);
-	tblt_add_col(def, AMP_TYPE_UVAST, "node_nbr");
-	tblt_add_col(def, AMP_TYPE_STR, "action");
-	tblt_add_col(def, AMP_TYPE_STR, "spec");
-	adm_add_tblt(def);
-}
-
-#endif // _HAVE_DTN_ION_IPNADMIN_ADM_
diff --git a/nm/agent/adm_ion_ipn_admin_impl.c b/nm/agent/adm_ion_ipn_admin_impl.c
deleted file mode 100644
index 4e6d103a..00000000
--- a/nm/agent/adm_ion_ipn_admin_impl.c
+++ /dev/null
@@ -1,480 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ipn_admin_impl.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "ipn/ipnfw.h"
-
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/adm/adm.h"
-#include "adm_ion_ipn_admin_impl.h"
-
-/*   START CUSTOM FUNCTIONS HERE */
-/*             TODO              */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_ipnadmin_setup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-void dtn_ion_ipnadmin_cleanup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-
-/* Metadata Functions */
-
-
-tnv_t *dtn_ion_ipnadmin_meta_name(tnvc_t *parms)
-{
-	return tnv_from_str("ion_ipn_admin");
-}
-
-
-tnv_t *dtn_ion_ipnadmin_meta_namespace(tnvc_t *parms)
-{
-	return tnv_from_str("DTN/ION/ipnadmin");
-}
-
-
-tnv_t *dtn_ion_ipnadmin_meta_version(tnvc_t *parms)
-{
-	return tnv_from_str("v0.0");
-}
-
-
-tnv_t *dtn_ion_ipnadmin_meta_organization(tnvc_t *parms)
-{
-	return tnv_from_str("JHUAPL");
-}
-
-
-/* Constant Functions */
-/* Table Functions */
-
-
-/*
- * This table lists all of the exits that are defined in the IPN database for the local node.
- */
-tbl_t *dtn_ion_ipnadmin_tblt_exits(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_exits BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr	sdr = getIonsdr();
-	Object	elt;
-	OBJ_POINTER(IpnExit, exit);
-	char	eidString[SDRSTRING_BUFSZ];
-	tnvc_t  *cur_row = NULL;
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (elt = sdr_list_first(sdr, (getIpnConstants())->exits); elt;
-				elt = sdr_list_next(sdr, elt))
-	{
-		GET_OBJ_POINTER(sdr, IpnExit, exit, sdr_list_data(sdr, elt));
-
-		sdr_string_read(getIonsdr(), eidString, exit->eid);
-
-		/* (uint) FirstNode (UINT) last node (STR) gatewaye EID */
-		if((cur_row = tnvc_create(4)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_uvast(exit->firstNodeNbr));
-			tnvc_insert(cur_row, tnv_from_uvast(exit->lastNodeNbr));
-			tnvc_insert(cur_row, tnv_from_str(eidString));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_bpadmin_tblt_protocols", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_exits BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * This table lists all of the egress plans that are established in the IPN database for the local node
- * .
- */
-tbl_t *dtn_ion_ipnadmin_tblt_plans(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_plans BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr	sdr = getIonsdr();
-	Object	elt;
-	OBJ_POINTER(BpPlan, plan);
-	char	*action = "none";
-	char	viaEid[SDRSTRING_BUFSZ];
-	char	*spec = "none";
-	Object	ductElt;
-	Object	outductElt;
-	Outduct	outduct;
-	tnvc_t  *cur_row = NULL;
-
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (elt = sdr_list_first(sdr, (getBpConstants())->plans); elt;
-			elt = sdr_list_next(sdr, elt))
-	{
-		GET_OBJ_POINTER(sdr, BpPlan, plan, sdr_list_data(sdr, elt));
-		if (plan->neighborNodeNbr == 0)	/*	Not CBHE.	*/
-		{
-			continue;
-		}
-
-		if (plan->viaEid)
-		{
-			action = "relay";
-			sdr_string_read(sdr, viaEid, plan->viaEid);
-			spec = viaEid;
-		}
-		else
-		{
-			action = "xmit";
-			ductElt = sdr_list_first(sdr, plan->ducts);
-			if (ductElt)
-			{
-				outductElt = sdr_list_data(sdr, ductElt);
-				sdr_read(sdr, (char *) &outduct, sdr_list_data(sdr,
-						outductElt), sizeof(Outduct));
-				spec = outduct.name;
-			}
-		}
-
-		/* (uint) FirstNode (UINT) last node (STR) gatewaye EID */
-		if((cur_row = tnvc_create(3)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_uvast(plan->neighborNodeNbr));
-			tnvc_insert(cur_row, tnv_from_str(action));
-			tnvc_insert(cur_row, tnv_from_str(spec));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_ipnadmin_tblt_plans", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_plans BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/* Collect Functions */
-/*
- * This is the version of ion is that currently installed.
- */
-tnv_t *dtn_ion_ipnadmin_get_ion_version(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_ion_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	result = tnv_from_str(IONVERSIONNUMBER);
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_ion_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* Control Functions */
-
-/*
- * This control establishes an exit for static default routing.
- */
-tnv_t *dtn_ion_ipnadmin_ctrl_exit_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_exit_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	int success = 0;
-	uvast firstNodeNbr = 0;
-	uvast lastNodeNbr = 0;
-	char *endpointId = NULL;
-
-	firstNodeNbr = adm_get_parm_uvast(parms,0,&success);
-	if(success){
-		lastNodeNbr = adm_get_parm_uvast(parms,1,&success);
-	}
-	if(success){
-		endpointId = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-	}
-	if(success){
-		if(ipn_addExit(firstNodeNbr,lastNodeNbr,endpointId) > 0)
-		{
-			*status = CTRL_SUCCESS;
-		}
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_exit_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control changes the gateway node number for the exit identified by firstNodeNbr and lastNodeNbr
- * .
- */
-tnv_t *dtn_ion_ipnadmin_ctrl_exit_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_exit_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	int success = 0;
-	uvast firstNodeNbr = 0;
-	uvast lastNodeNbr = 0;
-	char *endpointId = NULL;
-
-	firstNodeNbr = adm_get_parm_uvast(parms,0,&success);
-	if(success){
-		lastNodeNbr = adm_get_parm_uvast(parms,1,&success);
-	}
-	if(success){
-		endpointId = adm_get_parm_obj(parms, 2, AMP_TYPE_STR);
-	}
-	if(success){
-		if(ipn_updateExit(firstNodeNbr,lastNodeNbr,endpointId) > 0)
-		{
-			*status = CTRL_SUCCESS;
-		}
-	}
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_exit_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control deletes the exit identified by firstNodeNbr and lastNodeNbr.
- */
-tnv_t *dtn_ion_ipnadmin_ctrl_exit_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_exit_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	int success = 0;
-	uvast firstNodeNbr = 0;
-	uvast lastNodeNbr = 0;
-
-	firstNodeNbr = adm_get_parm_uvast(parms,0,&success);
-	if(success){
-		lastNodeNbr = adm_get_parm_uvast(parms,1,&success);
-	}
-	if(success){
-		if(ipn_removeExit(firstNodeNbr,lastNodeNbr) > 0)
-		{
-			*status = CTRL_SUCCESS;
-		}
-	}
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_exit_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control establishes an egress plan for the bundles that must be transmitted to the neighboring 
- * node that is identified by it's nodeNbr.
- */
-tnv_t *dtn_ion_ipnadmin_ctrl_plan_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_plan_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	int success = 0;
-	uvast nodeNbr = 0;
-	unsigned int xmitRate = 0;
-
-	nodeNbr = adm_get_parm_uvast(parms,0,&success);
-	if(success){
-		xmitRate = adm_get_parm_uint(parms, 1, &success);
-	}
-	if(success){
-		if(ipn_addPlan(nodeNbr,xmitRate) > 0)
-		{
-			*status = CTRL_SUCCESS;
-		}
-	}
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_plan_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control changes the duct expression for the indicated plan.
- */
-tnv_t *dtn_ion_ipnadmin_ctrl_plan_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_plan_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	int success = 0;
-	uvast nodeNbr = 0;
-	unsigned int xmitRate = 0;
-
-	nodeNbr = adm_get_parm_uvast(parms,0,&success);
-	if(success){
-		xmitRate = adm_get_parm_uint(parms, 1, &success);
-	}
-	if(success){
-		if(ipn_updatePlan(nodeNbr,xmitRate) > 0)
-		{
-			*status = CTRL_SUCCESS;
-		}
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_plan_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control deletes the egress plan for the node that is identified by it's nodeNbr.
- */
-tnv_t *dtn_ion_ipnadmin_ctrl_plan_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_plan_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	int success;
-	uvast nodeNbr = 0;
-
-	nodeNbr = adm_get_parm_uvast(parms,0,&success);
-	if(success){
-		if(ipn_removePlan(nodeNbr) > 0)
-		{
-			*status = CTRL_SUCCESS;
-		}
-	}
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_plan_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* OP Functions */
diff --git a/nm/agent/adm_ion_ipn_admin_impl.h b/nm/agent/adm_ion_ipn_admin_impl.h
deleted file mode 100644
index 836bf1ab..00000000
--- a/nm/agent/adm_ion_ipn_admin_impl.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ipn_admin_impl.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-#ifndef ADM_ION_IPN_ADMIN_IMPL_H_
-#define ADM_ION_IPN_ADMIN_IMPL_H_
-
-/*   START CUSTOM INCLUDES HERE  */
-//#include "../shared/adm/adm_bp.h"
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/utils/utils.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-#include "shared/primitives/tnv.h"
-
-/*   START typeENUM */
-/*   STOP typeENUM  */
-
-void name_adm_init_agent();
-
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                     Retrieval Functions                                     +
- * +---------------------------------------------------------------------------------------------+
- */
-/*   START CUSTOM FUNCTIONS HERE */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_ipnadmin_setup();
-void dtn_ion_ipnadmin_cleanup();
-
-
-/* Metadata Functions */
-tnv_t *dtn_ion_ipnadmin_meta_name(tnvc_t *parms);
-tnv_t *dtn_ion_ipnadmin_meta_namespace(tnvc_t *parms);
-tnv_t *dtn_ion_ipnadmin_meta_version(tnvc_t *parms);
-tnv_t *dtn_ion_ipnadmin_meta_organization(tnvc_t *parms);
-
-/* Constant Functions */
-
-/* Collect Functions */
-tnv_t *dtn_ion_ipnadmin_get_ion_version(tnvc_t *parms);
-
-
-/* Control Functions */
-tnv_t *dtn_ion_ipnadmin_ctrl_exit_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ipnadmin_ctrl_exit_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ipnadmin_ctrl_exit_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ipnadmin_ctrl_plan_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ipnadmin_ctrl_plan_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ipnadmin_ctrl_plan_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-
-
-/* OP Functions */
-
-
-/* Table Build Functions */
-tbl_t *dtn_ion_ipnadmin_tblt_exits(ari_t *id);
-tbl_t *dtn_ion_ipnadmin_tblt_plans(ari_t *id);
-
-#endif //ADM_ION_IPN_ADMIN_IMPL_H_
diff --git a/nm/agent/adm_ion_ltp_admin_agent.c b/nm/agent/adm_ion_ltp_admin_agent.c
deleted file mode 100644
index a7589368..00000000
--- a/nm/agent/adm_ion_ltp_admin_agent.c
+++ /dev/null
@@ -1,130 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ltp_admin_agent.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ion_ltp_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "adm_ion_ltp_admin_impl.h"
-#include "agent/rda.h"
-
-
-
-#define _HAVE_DTN_ION_LTPADMIN_ADM_
-#ifdef _HAVE_DTN_ION_LTPADMIN_ADM_
-
-static vec_idx_t g_dtn_ion_ltpadmin_idx[11];
-
-void dtn_ion_ltpadmin_init()
-{
-	adm_add_adm_info("dtn_ion_ltpadmin", ADM_ENUM_DTN_ION_LTPADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_LTPADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_ltpadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_LTPADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_ltpadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_LTPADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_ltpadmin_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_LTPADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_ltpadmin_setup();
-	dtn_ion_ltpadmin_init_meta();
-	dtn_ion_ltpadmin_init_cnst();
-	dtn_ion_ltpadmin_init_edd();
-	dtn_ion_ltpadmin_init_op();
-	dtn_ion_ltpadmin_init_var();
-	dtn_ion_ltpadmin_init_ctrl();
-	dtn_ion_ltpadmin_init_mac();
-	dtn_ion_ltpadmin_init_rpttpl();
-	dtn_ion_ltpadmin_init_tblt();
-}
-
-void dtn_ion_ltpadmin_init_meta()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ltpadmin_idx[ADM_META_IDX], DTN_ION_LTPADMIN_META_NAME), dtn_ion_ltpadmin_meta_name);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ltpadmin_idx[ADM_META_IDX], DTN_ION_LTPADMIN_META_NAMESPACE), dtn_ion_ltpadmin_meta_namespace);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ltpadmin_idx[ADM_META_IDX], DTN_ION_LTPADMIN_META_VERSION), dtn_ion_ltpadmin_meta_version);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ltpadmin_idx[ADM_META_IDX], DTN_ION_LTPADMIN_META_ORGANIZATION), dtn_ion_ltpadmin_meta_organization);
-}
-
-void dtn_ion_ltpadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_edd()
-{
-
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ltpadmin_idx[ADM_EDD_IDX], DTN_ION_LTPADMIN_EDD_ION_VERSION), dtn_ion_ltpadmin_get_ion_version);
-}
-
-void dtn_ion_ltpadmin_init_op()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_var()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_ctrl()
-{
-
-	adm_add_ctrldef(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_MANAGE_HEAP, 1, dtn_ion_ltpadmin_ctrl_manage_heap);
-	adm_add_ctrldef(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_MANAGE_MAX_BER, 1, dtn_ion_ltpadmin_ctrl_manage_max_ber);
-	adm_add_ctrldef(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_MANAGE_OWN_QUEUE_TIME, 1, dtn_ion_ltpadmin_ctrl_manage_own_queue_time);
-	adm_add_ctrldef(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_MANAGE_SCREENING, 1, dtn_ion_ltpadmin_ctrl_manage_screening);
-	adm_add_ctrldef(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_SPAN_ADD, 8, dtn_ion_ltpadmin_ctrl_span_add);
-	adm_add_ctrldef(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_SPAN_CHANGE, 8, dtn_ion_ltpadmin_ctrl_span_change);
-	adm_add_ctrldef(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_SPAN_DEL, 1, dtn_ion_ltpadmin_ctrl_span_del);
-	adm_add_ctrldef(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_STOP, 0, dtn_ion_ltpadmin_ctrl_stop);
-	adm_add_ctrldef(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_WATCH_SET, 1, dtn_ion_ltpadmin_ctrl_watch_set);
-}
-
-void dtn_ion_ltpadmin_init_mac()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* SPANS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ltpadmin_idx[ADM_TBLT_IDX], DTN_ION_LTPADMIN_TBLT_SPANS), dtn_ion_ltpadmin_tblt_spans);
-	tblt_add_col(def, AMP_TYPE_UVAST, "peer_engine_nbr");
-	tblt_add_col(def, AMP_TYPE_UINT, "max_export_sessions");
-	tblt_add_col(def, AMP_TYPE_UINT, "max_import_sessions");
-	tblt_add_col(def, AMP_TYPE_UINT, "max_segment_size");
-	tblt_add_col(def, AMP_TYPE_UINT, "aggregation_size_limit");
-	tblt_add_col(def, AMP_TYPE_UINT, "aggregation_time_limit");
-	tblt_add_col(def, AMP_TYPE_STR, "lso_control");
-	tblt_add_col(def, AMP_TYPE_UINT, "queueing_latency");
-	adm_add_tblt(def);
-}
-
-#endif // _HAVE_DTN_ION_LTPADMIN_ADM_
diff --git a/nm/agent/adm_ion_ltp_admin_impl.c b/nm/agent/adm_ion_ltp_admin_impl.c
deleted file mode 100644
index a96699dd..00000000
--- a/nm/agent/adm_ion_ltp_admin_impl.c
+++ /dev/null
@@ -1,614 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ltp_admin_impl.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "ltpP.h"
-
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/adm/adm.h"
-#include "adm_ion_ltp_admin_impl.h"
-
-/*   START CUSTOM FUNCTIONS HERE */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_ltpadmin_setup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	ltpAttach();
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-void dtn_ion_ltpadmin_cleanup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-
-/* Metadata Functions */
-
-
-tnv_t *dtn_ion_ltpadmin_meta_name(tnvc_t *parms)
-{
-	return tnv_from_str("ion_ltp_admin");
-}
-
-
-tnv_t *dtn_ion_ltpadmin_meta_namespace(tnvc_t *parms)
-{
-	return tnv_from_str("DTN/ION/ltpadmin");
-}
-
-
-tnv_t *dtn_ion_ltpadmin_meta_version(tnvc_t *parms)
-{
-	return tnv_from_str("v0.0");
-}
-
-
-tnv_t *dtn_ion_ltpadmin_meta_organization(tnvc_t *parms)
-{
-	return tnv_from_str("JHUAPL");
-}
-
-
-/* Constant Functions */
-/* Table Functions */
-
-
-/*
- * This table lists all spans of potential LTP data interchange that exists between the local LTP engin
- * e and the indicated (neighboring) LTP engine.
- */
-tbl_t *dtn_ion_ltpadmin_tblt_spans(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_spans BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr		sdr = getIonsdr();
-	LtpVdb		*vdb = getLtpVdb();
-	PsmPartition	ionwm = getIonwm();
-	Object		ltpdbObj = getLtpDbObject();
-	OBJ_POINTER(LtpDB, ltpdb);
-	PsmAddress	elt;
-	LtpVspan	*vspan;
-	char	cmd[SDRSTRING_BUFSZ];
-	OBJ_POINTER(LtpSpan, span);
-	tnvc_t  *cur_row = NULL;
-
-
-	CHKNULL(sdr_begin_xn(sdr));	/*	Just to lock memory.	*/
-	GET_OBJ_POINTER(sdr, LtpDB, ltpdb, ltpdbObj);
-
-	for (elt = sm_list_first(ionwm, vdb->spans); elt; elt = sm_list_next(ionwm, elt))
-	{
-		vspan = (LtpVspan *) psp(ionwm, sm_list_data(ionwm, elt));
-
-		GET_OBJ_POINTER(sdr, LtpSpan, span, sdr_list_data(sdr, vspan->spanElt));
-		sdr_string_read(sdr, cmd, span->lsoCmd);
-
-
-		/* (UINT) peer_engine_nbr, (UINT) max_export_sess, (UINT) max_import_sess,
-		 * (UINT) max-seg-size, (UINT) agg_size_limit, (UINT) agg_time_limit,
-		 * (STR) lso_ctrl, (UINT) q_latency
-		 */
-		if((cur_row = tnvc_create(8)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_uvast(vspan->engineId));
-			tnvc_insert(cur_row, tnv_from_uint(span->maxExportSessions));
-			tnvc_insert(cur_row, tnv_from_uint(span->maxImportSessions));
-			tnvc_insert(cur_row, tnv_from_uint(span->maxSegmentSize));
-			tnvc_insert(cur_row, tnv_from_uint(span->aggrSizeLimit));
-			tnvc_insert(cur_row, tnv_from_uint(span->aggrTimeLimit));
-			tnvc_insert(cur_row, tnv_from_str(cmd));
-			tnvc_insert(cur_row, tnv_from_uint(span->remoteQtime));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_ltpadmin_tblt_spans", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_spans BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/* Collect Functions */
-/*
- * This is the version of ION that is currently installed.
- */
-tnv_t *dtn_ion_ltpadmin_get_ion_version(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_ion_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	result = tnv_from_str(IONVERSIONNUMBER);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_ion_version BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* Control Functions */
-
-/*
- * This control declares the maximum number of bytes of SDR heap space that will be occupied by the acq
- * uisition of any single LTP block. All data acquired in excess of this limit will be written to a tem
- * porary file pending extraction and dispatching of the acquired block. Default is the minimum allowed
- *  value (560 bytes), which is the approximate size of a ZCO file reference object; this is the minimu
- * m SDR heap space occupancy in the event that all acquisition is into a file.
- */
-tnv_t *dtn_ion_ltpadmin_ctrl_manage_heap(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_manage_heap BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr		sdr = getIonsdr();
-	Object		ltpdbObj = getLtpDbObject();
-	LtpDB		ltpdb;
-	int success;
-	unsigned int heapmax = adm_get_parm_uint(parms, 0, &success);
-
-	if (heapmax < 560)
-	{
-		AMP_DEBUG_ERR("dtn_ion_ltpadmin_ctrl_manage_heap", "Heapmax must be at least 560, not %lu", heapmax);
-		return result;
-	}
-
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &ltpdb, ltpdbObj, sizeof(LtpDB));
-	ltpdb.maxAcqInHeap = heapmax;
-	sdr_write(sdr, ltpdbObj, (char *) &ltpdb, sizeof(LtpDB));
-	if (sdr_end_xn(sdr) < 0)
-	{
-		AMP_DEBUG_ERR("dtn_ion_ltpadmin_ctrl_manage_heap", "Can't change maxAcqInHeap.", NULL);
-	}
-	else
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_manage_heap BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control sets the expected maximum bit error rate(BER) that LTP should provide for in computing 
- * the maximum number of transmission efforts to initiate in the transmission of a given block.(Note th
- * at this computation is also sensitive to data segment size and to the size of the block that is to b
- * e transmitted.) The default value is .0001 (10^-4).
- */
-tnv_t *dtn_ion_ltpadmin_ctrl_manage_max_ber(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_manage_max_ber BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr		sdr = getIonsdr();
-	Object		ltpdbObj = getLtpDbObject();
-	PsmPartition	ionwm = getIonwm();
-	LtpVdb		*vdb = getLtpVdb();
-	LtpDB		ltpdb;
-	double		newMaxBER;
-	PsmAddress	elt;
-	LtpVspan	*vspan;
-	int success;
-	newMaxBER = adm_get_parm_real32(parms, 0, &success);
-
-	if (newMaxBER < 0.0)
-	{
-		AMP_DEBUG_ERR("dtn_ion_ltpadmin_ctrl_manage_max_ber","Max BER invalid %f", newMaxBER);
-		return NULL;
-	}
-
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &ltpdb, ltpdbObj, sizeof(LtpDB));
-	ltpdb.maxBER = newMaxBER;
-	sdr_write(sdr, ltpdbObj, (char *) &ltpdb, sizeof(LtpDB));
-	for (elt = sm_list_first(ionwm, vdb->spans); elt;
-			elt = sm_list_next(ionwm, elt))
-	{
-		vspan = (LtpVspan *) psp(ionwm, sm_list_data(ionwm, elt));
-		computeRetransmissionLimits(vspan);
-	}
-
-	if (sdr_end_xn(sdr) < 0)
-	{
-		AMP_DEBUG_ERR("dtn_ion_ltpadmin_ctrl_manage_max_ber","Can't change maximum bit error rate.", NULL);
-	}
-	else
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_manage_max_ber BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control sets the number of seconds of predicted additional latency attributable to processing d
- * elay within the local engine itself that should be included whenever LTP computes the nominal round-
- * trip time for an exchange of data with any remote engine.The default value is 1.
- */
-tnv_t *dtn_ion_ltpadmin_ctrl_manage_own_queue_time(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_manage_own_queue_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr	sdr = getIonsdr();
-	Object	ltpdbObj = getLtpDbObject();
-	LtpDB	ltpdb;
-	int	newOwnQtime;
-	int success;
-
-	newOwnQtime = adm_get_parm_uint(parms, 0, &success);
-
-	if (newOwnQtime < 0)
-	{
-		AMP_DEBUG_WARN("dtn_ion_ltpadmin_ctrl_manage_own_queue_time", "Own Q time invalid: %d", newOwnQtime);
-		return NULL;
-	}
-
-	CHKNULL(sdr_begin_xn(sdr));
-	sdr_stage(sdr, (char *) &ltpdb, ltpdbObj, sizeof(LtpDB));
-	ltpdb.ownQtime = newOwnQtime;
-	sdr_write(sdr, ltpdbObj, (char *) &ltpdb, sizeof(LtpDB));
-	if (sdr_end_xn(sdr) < 0)
-	{
-		AMP_DEBUG_ERR("dtn_ion_ltpadmin_ctrl_manage_own_queue_time", "Can't change own LTP queuing time.", NULL);
-	}
-	else
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_manage_own_queue_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control enables or disables the screening of received LTP segments per the periods of scheduled
- *  reception in the node's contact graph. By default, screening is disabled. When screening is enabled
- * , such segments are silently discarded. Note that when screening is enabled the ranges declared in t
- * he contact graph must be accurate and clocks must be synchronized; otherwise, segments will be arriv
- * ing at times other than the scheduled contact intervals and will be discarded.
- */
-tnv_t *dtn_ion_ltpadmin_ctrl_manage_screening(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_manage_screening BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	AMP_DEBUG_WARN("dtn_ion_ltpadmin_ctrl_manage_screening","Note: LTP screening is now always on, cannot be disabled.", NULL);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_manage_screening BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control declares that a span of potential LTP data interchange exists between the local LTP eng
- * ine and the indicated (neighboring) LTP engine.
- */
-tnv_t *dtn_ion_ltpadmin_ctrl_span_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_span_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	int success;
-	uvast engineId = adm_get_parm_uvast(parms, 0, &success);
-	unsigned int maxExportSessions = adm_get_parm_uint(parms, 1, &success);
-	unsigned int maxImportSessions = adm_get_parm_uint(parms, 2, &success);
-	unsigned int maxSegmentSize = adm_get_parm_uint(parms, 3, &success);
-	unsigned int aggrSizeLimit = adm_get_parm_uint(parms, 4, &success);
-	unsigned int aggrTimeLimit = adm_get_parm_uint(parms, 5, &success);
-	char *lsoCmd = adm_get_parm_obj(parms, 6, AMP_TYPE_STR);
-	unsigned int qTime = adm_get_parm_uint(parms, 7, &success);
-	int purge = 0;
-
-	if (qTime == 0)
-	{
-		purge = 1;
-		qTime = 0 - qTime;
-	}
-
-	if(addSpan(engineId, maxExportSessions, maxImportSessions, maxSegmentSize, aggrSizeLimit, aggrTimeLimit, lsoCmd, qTime, purge) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_span_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control sets the indicated span's configuration parameters to the values provided as arguments
- */
-tnv_t *dtn_ion_ltpadmin_ctrl_span_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_span_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	uvast engineId = adm_get_parm_uvast(parms, 0, &success);
-	unsigned int maxExportSessions = adm_get_parm_uint(parms, 1, &success);
-	unsigned int maxImportSessions = adm_get_parm_uint(parms, 2, &success);
-	unsigned int maxSegmentSize = adm_get_parm_uint(parms, 3, &success);
-	unsigned int aggrSizeLimit = adm_get_parm_uint(parms, 4, &success);
-	unsigned int aggrTimeLimit = adm_get_parm_uint(parms, 5, &success);
-	char *lsoCmd = adm_get_parm_obj(parms, 6, AMP_TYPE_STR);
-	unsigned int qTime = adm_get_parm_uint(parms, 7, &success);
-	int purge = 0;
-
-	if (qTime == 0)
-	{
-		purge = 1;
-		qTime = 0 - qTime;
-	}
-
-	if(updateSpan(engineId, maxExportSessions, maxImportSessions, maxSegmentSize, aggrSizeLimit, aggrTimeLimit, lsoCmd, qTime, purge) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_span_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control deletes the span identified by peerEngineNumber. The control will fail if any outbound 
- * segments for this span are pending transmission or any inbound blocks from the peer engine are incom
- * plete.
- */
-tnv_t *dtn_ion_ltpadmin_ctrl_span_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_span_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	uvast engineId = adm_get_parm_uvast(parms, 0, &success);
-	if(removeSpan(engineId) > 0)
-	{
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_span_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control stops all link service input and output tasks for the local LTP engine.
- */
-tnv_t *dtn_ion_ltpadmin_ctrl_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	ltpStop();
-	*status = CTRL_SUCCESS;
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_stop BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control enables and disables production of a continuous stream of user- selected LTP activity i
- * ndication characters. Activity parameter of 1 selects all LTP activity indication characters; 0 de-s
- * elects all LTP activity indication characters; any other activitySpec such as df{] selects all activ
- * ity indication characters in the string, de-selecting all others. LTP will print each selected activ
- * ity indication character to stdout every time a processing event of the associated type occurs: d bu
- * ndle appended to block for next session, e segment of block is queued for transmission, f block has 
- * been fully segmented for transmission, g segment popped from transmission queue, h positive ACK rece
- * ived for block and session ended, s segment received, t block has been fully received, @ negative AC
- * K received for block and segments retransmitted, = unacknowledged checkpoint was retransmitted, + un
- * acknowledged report segment was retransmitted, { export session canceled locally (by sender), } impo
- * rt session canceled by remote sender, [ import session canceled locally (by receiver), ] export sess
- * ion canceled by remote receiver
- */
-tnv_t *dtn_ion_ltpadmin_ctrl_watch_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_watch_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success;
-	Sdr	sdr = getIonsdr();
-	Object	dbObj = getLtpDbObject();
-	LtpDB	db;
-	char *name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	LtpVdb	*vdb = getLtpVdb();
-	int i;
-
-	*status = CTRL_SUCCESS;
-
-	if (strcmp(name, "1") == 0)
-	{
-		vdb->watching = -1;
-		return result;
-	}
-
-	vdb->watching = 0;
-	if (strcmp(name, "0") == 0)
-	{
-		return result;
-	}
-
-	for(i = 0; i < strlen(name); i++)
-	{
-		switch(name[i])
-		{
-			case 'd': vdb->watching |= WATCH_d; break;
-			case 'e': vdb->watching |= WATCH_e; break;
-			case 'f': vdb->watching |= WATCH_f; break;
-			case 'g': vdb->watching |= WATCH_g; break;
-			case 'h': vdb->watching |= WATCH_h; break;
-			case 's': vdb->watching |= WATCH_s; break;
-			case 't': vdb->watching |= WATCH_t; break;
-			case '@': vdb->watching |= WATCH_nak; break;
-			case '{': vdb->watching |= WATCH_CLS; break;
-			case '}': vdb->watching |= WATCH_handleCLS;  break;
-			case '[': vdb->watching |= WATCH_CR; break;
-			case ']': vdb->watching |= WATCH_handleCR; break;
-			case '=': vdb->watching |= WATCH_resendCP;   break;
-			case '+': vdb->watching |= WATCH_resendRS; break;
-			default:
-				AMP_DEBUG_WARN("dtn_ion_ltpadmin_ctrl_watch_set", "Invalid watch char %c.", name[i]);
-				break;
-		}
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_watch_set BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* OP Functions */
diff --git a/nm/agent/adm_ion_ltp_admin_impl.h b/nm/agent/adm_ion_ltp_admin_impl.h
deleted file mode 100644
index ee7a8f7a..00000000
--- a/nm/agent/adm_ion_ltp_admin_impl.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ltp_admin_impl.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-#ifndef ADM_ION_LTP_ADMIN_IMPL_H_
-#define ADM_ION_LTP_ADMIN_IMPL_H_
-
-/*   START CUSTOM INCLUDES HERE  */
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/utils/utils.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-#include "shared/primitives/tnv.h"
-
-/*   START typeENUM */
-/*             TODO              */
-/*   STOP typeENUM  */
-
-void name_adm_init_agent();
-
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                     Retrieval Functions                                     +
- * +---------------------------------------------------------------------------------------------+
- */
-/*   START CUSTOM FUNCTIONS HERE */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_ltpadmin_setup();
-void dtn_ion_ltpadmin_cleanup();
-
-
-/* Metadata Functions */
-tnv_t *dtn_ion_ltpadmin_meta_name(tnvc_t *parms);
-tnv_t *dtn_ion_ltpadmin_meta_namespace(tnvc_t *parms);
-tnv_t *dtn_ion_ltpadmin_meta_version(tnvc_t *parms);
-tnv_t *dtn_ion_ltpadmin_meta_organization(tnvc_t *parms);
-
-/* Constant Functions */
-
-/* Collect Functions */
-tnv_t *dtn_ion_ltpadmin_get_ion_version(tnvc_t *parms);
-
-
-/* Control Functions */
-tnv_t *dtn_ion_ltpadmin_ctrl_manage_heap(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ltpadmin_ctrl_manage_max_ber(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ltpadmin_ctrl_manage_own_queue_time(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ltpadmin_ctrl_manage_screening(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ltpadmin_ctrl_span_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ltpadmin_ctrl_span_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ltpadmin_ctrl_span_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ltpadmin_ctrl_stop(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ltpadmin_ctrl_watch_set(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-
-
-/* OP Functions */
-
-
-/* Table Build Functions */
-tbl_t *dtn_ion_ltpadmin_tblt_spans(ari_t *id);
-
-#endif //ADM_ION_LTP_ADMIN_IMPL_H_
diff --git a/nm/agent/adm_ionsec_admin_agent.c b/nm/agent/adm_ionsec_admin_agent.c
deleted file mode 100644
index 84f6f3f9..00000000
--- a/nm/agent/adm_ionsec_admin_agent.c
+++ /dev/null
@@ -1,134 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ionsec_admin_agent.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ionsec_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "adm_ionsec_admin_impl.h"
-#include "agent/rda.h"
-
-
-
-#define _HAVE_DTN_ION_IONSECADMIN_ADM_
-#ifdef _HAVE_DTN_ION_IONSECADMIN_ADM_
-
-static vec_idx_t g_dtn_ion_ionsecadmin_idx[11];
-
-void dtn_ion_ionsecadmin_init()
-{
-	adm_add_adm_info("dtn_ion_ionsecadmin", ADM_ENUM_DTN_ION_IONSECADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONSECADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_ionsecadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONSECADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_ionsecadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONSECADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_ionsecadmin_setup();
-	dtn_ion_ionsecadmin_init_meta();
-	dtn_ion_ionsecadmin_init_cnst();
-	dtn_ion_ionsecadmin_init_edd();
-	dtn_ion_ionsecadmin_init_op();
-	dtn_ion_ionsecadmin_init_var();
-	dtn_ion_ionsecadmin_init_ctrl();
-	dtn_ion_ionsecadmin_init_mac();
-	dtn_ion_ionsecadmin_init_rpttpl();
-	dtn_ion_ionsecadmin_init_tblt();
-}
-
-void dtn_ion_ionsecadmin_init_meta()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionsecadmin_idx[ADM_META_IDX], DTN_ION_IONSECADMIN_META_NAME), dtn_ion_ionsecadmin_meta_name);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionsecadmin_idx[ADM_META_IDX], DTN_ION_IONSECADMIN_META_NAMESPACE), dtn_ion_ionsecadmin_meta_namespace);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionsecadmin_idx[ADM_META_IDX], DTN_ION_IONSECADMIN_META_VERSION), dtn_ion_ionsecadmin_meta_version);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionsecadmin_idx[ADM_META_IDX], DTN_ION_IONSECADMIN_META_ORGANIZATION), dtn_ion_ionsecadmin_meta_organization);
-}
-
-void dtn_ion_ionsecadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_edd()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_op()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_var()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_ctrl()
-{
-
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_KEY_ADD, 2, dtn_ion_ionsecadmin_ctrl_key_add);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_KEY_CHANGE, 2, dtn_ion_ionsecadmin_ctrl_key_change);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_KEY_DEL, 1, dtn_ion_ionsecadmin_ctrl_key_del);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_RX_RULE_ADD, 3, dtn_ion_ionsecadmin_ctrl_ltp_rx_rule_add);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_RX_RULE_CHANGE, 3, dtn_ion_ionsecadmin_ctrl_ltp_rx_rule_change);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_RX_RULE_DEL, 1, dtn_ion_ionsecadmin_ctrl_ltp_rx_rule_del);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_TX_RULE_ADD, 3, dtn_ion_ionsecadmin_ctrl_ltp_tx_rule_add);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_TX_RULE_CHANGE, 3, dtn_ion_ionsecadmin_ctrl_ltp_tx_rule_change);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_TX_RULE_DEL, 1, dtn_ion_ionsecadmin_ctrl_ltp_tx_rule_del);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LIST_KEYS, 0, dtn_ion_ionsecadmin_ctrl_list_keys);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LIST_LTP_RX_RULES, 0, dtn_ion_ionsecadmin_ctrl_list_ltp_rx_rules);
-	adm_add_ctrldef(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LIST_LTP_TX_RULES, 0, dtn_ion_ionsecadmin_ctrl_list_ltp_tx_rules);
-}
-
-void dtn_ion_ionsecadmin_init_mac()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* LTP_RX_RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ionsecadmin_idx[ADM_TBLT_IDX], DTN_ION_IONSECADMIN_TBLT_LTP_RX_RULES), dtn_ion_ionsecadmin_tblt_ltp_rx_rules);
-	tblt_add_col(def, AMP_TYPE_UINT, "ltp_engine_id");
-	tblt_add_col(def, AMP_TYPE_UINT, "ciphersuite_nbr");
-	tblt_add_col(def, AMP_TYPE_STR, "key_name");
-	adm_add_tblt(def);
-
-	/* LTP_TX_RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ionsecadmin_idx[ADM_TBLT_IDX], DTN_ION_IONSECADMIN_TBLT_LTP_TX_RULES), dtn_ion_ionsecadmin_tblt_ltp_tx_rules);
-	tblt_add_col(def, AMP_TYPE_UINT, "ltp_engine_id");
-	tblt_add_col(def, AMP_TYPE_UINT, "ciphersuite_nbr");
-	tblt_add_col(def, AMP_TYPE_STR, "key_name");
-	adm_add_tblt(def);
-}
-
-#endif // _HAVE_DTN_ION_IONSECADMIN_ADM_
diff --git a/nm/agent/adm_ionsec_admin_impl.c b/nm/agent/adm_ionsec_admin_impl.c
deleted file mode 100644
index 104902db..00000000
--- a/nm/agent/adm_ionsec_admin_impl.c
+++ /dev/null
@@ -1,521 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ionsec_admin_impl.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "ion.h"
-#include "ionsec.h"
-#include "ltpsec.h"
-#include "bpsec.h"
-
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/adm/adm.h"
-#include "adm_ionsec_admin_impl.h"
-
-/*   START CUSTOM FUNCTIONS HERE */
-
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_ionsecadmin_setup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-void dtn_ion_ionsecadmin_cleanup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-
-/* Metadata Functions */
-
-
-tnv_t *dtn_ion_ionsecadmin_meta_name(tnvc_t *parms)
-{
-	return tnv_from_str("ionsec_admin");
-}
-
-
-tnv_t *dtn_ion_ionsecadmin_meta_namespace(tnvc_t *parms)
-{
-	return tnv_from_str("DTN/ION/ionsecadmin");
-}
-
-
-tnv_t *dtn_ion_ionsecadmin_meta_version(tnvc_t *parms)
-{
-	return tnv_from_str("v0.0");
-}
-
-
-tnv_t *dtn_ion_ionsecadmin_meta_organization(tnvc_t *parms)
-{
-	return tnv_from_str("JHUAPL");
-}
-
-
-/* Constant Functions */
-/* Table Functions */
-
-
-/*
- * This table lists all LTP segment authentication rulesin the security policy database.
- */
-tbl_t *dtn_ion_ionsecadmin_tblt_ltp_rx_rules(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_ltp_rx_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	Sdr	sdr = getIonsdr();
-	OBJ_POINTER(SecDB, db);
-	OBJ_POINTER(LtpRecvAuthRule, rule);
-	Object	elt;
-	Object	obj;
-	tnvc_t  *cur_row = NULL;
-
-	GET_OBJ_POINTER(sdr, SecDB, db, getSecDbObject());
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (elt = sdr_list_first(sdr, db->ltpRecvAuthRules); elt;
-			elt = sdr_list_next(sdr, elt))
-	{
-		obj = sdr_list_data(sdr, elt);
-		GET_OBJ_POINTER(sdr, LtpRecvAuthRule, rule, obj);
-
-		/* (UINT engine_id, (UINT) cipher_nbr, (STR) key ame */
-		if((cur_row = tnvc_create(3)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_uint(rule->ltpEngineId));
-			tnvc_insert(cur_row, tnv_from_uint(rule->ciphersuiteNbr));
-			tnvc_insert(cur_row, tnv_from_str(rule->keyName));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_ionsecadmin_tblt_ltp_rx_rules", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_ltp_rx_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/*
- * This table lists all LTP segment signing rules in the security policy database.
- */
-tbl_t *dtn_ion_ionsecadmin_tblt_ltp_tx_rules(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_ltp_tx_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	Sdr	sdr = getIonsdr();
-	OBJ_POINTER(SecDB, db);
-	OBJ_POINTER(LtpXmitAuthRule, rule);
-	Object	elt;
-	Object	obj;
-	tnvc_t  *cur_row = NULL;
-
-	GET_OBJ_POINTER(sdr, SecDB, db, getSecDbObject());
-
-	CHKNULL(sdr_begin_xn(sdr));
-	for (elt = sdr_list_first(sdr, db->ltpXmitAuthRules); elt;
-			elt = sdr_list_next(sdr, elt))
-	{
-		obj = sdr_list_data(sdr, elt);
-		GET_OBJ_POINTER(sdr, LtpXmitAuthRule, rule, obj);
-
-		/* (UINT engine_id, (UINT) cipher_nbr, (STR) key ame */
-		if((cur_row = tnvc_create(3)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_uint(rule->ltpEngineId));
-			tnvc_insert(cur_row, tnv_from_uint(rule->ciphersuiteNbr));
-			tnvc_insert(cur_row, tnv_from_str(rule->keyName));
-
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ion_ionsecadmin_tblt_ltp_tx_rules", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_ltp_tx_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/* Collect Functions */
-
-/* Control Functions */
-
-/*
- * This control adds a named key value to the security policy database. The content of file_name is tak
- * en as the value of the key.Named keys can be referenced by other elements of thesecurity policy data
- * base.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_key_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_key_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *key_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *file_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-
-	if((key_name != NULL) && (file_name != NULL))
-	{
-		sec_addKey(key_name, file_name);
-		*status = CTRL_SUCCESS;
-	}
-
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_key_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control changes the value of the named key, obtaining the new key value from the content of fil
- * e_name.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_key_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_key_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *key_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-	char *file_name = adm_get_parm_obj(parms, 1, AMP_TYPE_STR);
-
-	if((key_name != NULL) && (file_name != NULL))
-	{
-		sec_updateKey(key_name, file_name);
-		*status = CTRL_SUCCESS;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_key_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control deletes the key identified by name.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_key_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_key_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	char *key_name = adm_get_parm_obj(parms, 0, AMP_TYPE_STR);
-
-	sec_removeKey(key_name);
-	*status = CTRL_SUCCESS;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_key_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control adds a rule specifying the manner in which LTP segment authentication will be applied t
- * o LTP segmentsrecieved from the indicated LTP engine. A segment from the indicated LTP engine will o
- * nly be deemed authentic if it contains an authentication extension computed via the ciphersuite iden
- * tified by ciphersuite_nbr using the applicable key value. If ciphersuite_nbr is 255 then the applica
- * ble key value is a hard-coded constant and key_name must be omitted; otherwise key_nameis required a
- * nd the applicable key value is the current value of the key named key_name in the local security pol
- * icy database. Valid values of ciphersuite_nbr are: 0: HMAC-SHA1-80 1: RSA-SHA256 255: NULL
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_rx_rule_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_ltp_rx_rule_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-		/*TODO
-		unsure which function to use ltprecvauthrule vs ltpxmitauthrule for add */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_ltp_rx_rule_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control changes the parameters of the LTP segment authentication rule for the indicated LTP eng
- * ine.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_rx_rule_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_ltp_rx_rule_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-		/*TODO
-		unsure which function to use ltprecvauthrule vs ltpxmitauthrule for change*/
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_ltp_rx_rule_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control deletes the LTP segment authentication rule for the indicated LTP engine.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_rx_rule_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_ltp_rx_rule_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-		/*TODO
-		unsure which function to use ltprecvauthrule vs ltpxmitauthrule for remove*/
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_ltp_rx_rule_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control adds a rule specifying the manner in which LTP segments transmitted to the indicated LT
- * P engine mustbe signed. Signing a segment destined for the indicated LTP engineentails computing an 
- * authentication extension via the ciphersuite identified by ciphersuite_nbr using the applicable key 
- * value. If ciphersuite_nbr is 255 then the applicable key value is a hard-coded constant and key_name
- *  must be omitted; otherwise key_nameis required and the applicable key value is the current value of
- *  the key named key_name in the local security policy database.Valid values of ciphersuite_nbr are: 0
- * :HMAC_SHA1-80 1: RSA_SHA256 255: NULL
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_tx_rule_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_ltp_tx_rule_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-		/*TODO
-		unsure which function to use ltprecvauthrule vs ltpxmitauthrule for add*/
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_ltp_tx_rule_add BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control changes the parameters of the LTP segment signing rule for the indicated LTP engine.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_tx_rule_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_ltp_tx_rule_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-		/*TODO
-		unsure which function to use ltprecvauthrule vs ltpxmitauthrule for change*/
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_ltp_tx_rule_change BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control deletes the LTP segment signing rule forthe indicated LTP engine.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_tx_rule_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_ltp_tx_rule_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*TODO
-		unsure which function to use ltprecvauthrule vs ltpxmitauthrule for remove*/
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_ltp_tx_rule_del BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control lists the names of keys available in the key policy database.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_list_keys(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_list_keys BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_list_keys BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control lists all LTP segment authentication rules in the security policy database.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_list_ltp_rx_rules(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_list_ltp_rx_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_list_ltp_rx_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * This control lists all LTP segment signing rules in the security policy database.
- */
-tnv_t *dtn_ion_ionsecadmin_ctrl_list_ltp_tx_rules(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_list_ltp_tx_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_list_ltp_tx_rules BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* OP Functions */
diff --git a/nm/agent/adm_ionsec_admin_impl.h b/nm/agent/adm_ionsec_admin_impl.h
deleted file mode 100644
index b5f55322..00000000
--- a/nm/agent/adm_ionsec_admin_impl.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ionsec_admin_impl.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-#ifndef ADM_IONSEC_ADMIN_IMPL_H_
-#define ADM_IONSEC_ADMIN_IMPL_H_
-
-/*   START CUSTOM INCLUDES HERE  */
-#define	EPOCH_2000_SEC	946684800
-/*		LTP authentication ciphersuite numbers			*/
-#define LTP_AUTH_HMAC_SHA1_80	0
-#define LTP_AUTH_RSA_SHA256	1
-#define LTP_AUTH_NULL		255
-
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/utils/utils.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-#include "shared/primitives/tnv.h"
-
-/*   START typeENUM */
-
-/*   STOP typeENUM  */
-
-void name_adm_init_agent();
-
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                     Retrieval Functions                                     +
- * +---------------------------------------------------------------------------------------------+
- */
-/*   START CUSTOM FUNCTIONS HERE */
-//static void	printBspBabRule(Object ruleAddr);
-//static void	printBspBibRule(Object ruleAddr);
-//static void printBspBcbRule(Object ruleAddr);
-//static void	printLtpRecvAuthRule(Object ruleAddr);
-//static void	printLtpXmitAuthRule(Object ruleAddr);
-
-/*	*	Functions for managing security information.		*/
-
-extern void	sec_findKey(char *keyName, Object *keyAddr, Object *eltp);
-extern int	sec_addKey(char *keyName, char *fileName);
-extern int	sec_updateKey(char *keyName, char *fileName);
-extern int	sec_removeKey(char *keyName);
-extern int	sec_activeKey(char *keyName);
-extern int	sec_addKeyValue(char *keyName, char *keyVal, uint32_t keyLen);
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ion_ionsecadmin_setup();
-void dtn_ion_ionsecadmin_cleanup();
-
-
-/* Metadata Functions */
-tnv_t *dtn_ion_ionsecadmin_meta_name(tnvc_t *parms);
-tnv_t *dtn_ion_ionsecadmin_meta_namespace(tnvc_t *parms);
-tnv_t *dtn_ion_ionsecadmin_meta_version(tnvc_t *parms);
-tnv_t *dtn_ion_ionsecadmin_meta_organization(tnvc_t *parms);
-
-/* Constant Functions */
-
-/* Collect Functions */
-
-
-/* Control Functions */
-tnv_t *dtn_ion_ionsecadmin_ctrl_key_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_key_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_key_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_rx_rule_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_rx_rule_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_rx_rule_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_tx_rule_add(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_tx_rule_change(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_ltp_tx_rule_del(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_list_keys(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_list_ltp_rx_rules(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-tnv_t *dtn_ion_ionsecadmin_ctrl_list_ltp_tx_rules(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-
-
-/* OP Functions */
-
-
-/* Table Build Functions */
-tbl_t *dtn_ion_ionsecadmin_tblt_ltp_rx_rules(ari_t *id);
-tbl_t *dtn_ion_ionsecadmin_tblt_ltp_tx_rules(ari_t *id);
-
-#endif //ADM_IONSEC_ADMIN_IMPL_H_
diff --git a/nm/agent/adm_ltp_agent_agent.c b/nm/agent/adm_ltp_agent_agent.c
deleted file mode 100644
index fec51548..00000000
--- a/nm/agent/adm_ltp_agent_agent.c
+++ /dev/null
@@ -1,204 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ltp_agent_agent.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ltp_agent.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "adm_ltp_agent_impl.h"
-#include "agent/rda.h"
-
-
-
-#define _HAVE_DTN_LTP_AGENT_ADM_
-#ifdef _HAVE_DTN_LTP_AGENT_ADM_
-
-static vec_idx_t g_dtn_ltp_agent_idx[11];
-
-void dtn_ltp_agent_init()
-{
-	adm_add_adm_info("dtn_ltp_agent", ADM_ENUM_DTN_LTP_AGENT);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_META_IDX), &(g_dtn_ltp_agent_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_TBLT_IDX), &(g_dtn_ltp_agent_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_RPTT_IDX), &(g_dtn_ltp_agent_idx[ADM_RPTT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_EDD_IDX), &(g_dtn_ltp_agent_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_CTRL_IDX), &(g_dtn_ltp_agent_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ltp_agent_setup();
-	dtn_ltp_agent_init_meta();
-	dtn_ltp_agent_init_cnst();
-	dtn_ltp_agent_init_edd();
-	dtn_ltp_agent_init_op();
-	dtn_ltp_agent_init_var();
-	dtn_ltp_agent_init_ctrl();
-	dtn_ltp_agent_init_mac();
-	dtn_ltp_agent_init_rpttpl();
-	dtn_ltp_agent_init_tblt();
-}
-
-void dtn_ltp_agent_init_meta()
-{
-
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ltp_agent_idx[ADM_META_IDX], DTN_LTP_AGENT_META_NAME), dtn_ltp_agent_meta_name);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ltp_agent_idx[ADM_META_IDX], DTN_LTP_AGENT_META_NAMESPACE), dtn_ltp_agent_meta_namespace);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ltp_agent_idx[ADM_META_IDX], DTN_LTP_AGENT_META_VERSION), dtn_ltp_agent_meta_version);
-	adm_add_cnst(adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ltp_agent_idx[ADM_META_IDX], DTN_LTP_AGENT_META_ORGANIZATION), dtn_ltp_agent_meta_organization);
-}
-
-void dtn_ltp_agent_init_cnst()
-{
-
-}
-
-void dtn_ltp_agent_init_edd()
-{
-
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_REMOTE_ENGINE_NBR), dtn_ltp_agent_get_span_remote_engine_nbr);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_EXPT_SESS), dtn_ltp_agent_get_span_cur_expt_sess);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_OUT_SEG), dtn_ltp_agent_get_span_cur_out_seg);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_IMP_SESS), dtn_ltp_agent_get_span_cur_imp_sess);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_IN_SEG), dtn_ltp_agent_get_span_cur_in_seg);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_RESET_TIME), dtn_ltp_agent_get_span_reset_time);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_CNT), dtn_ltp_agent_get_span_out_seg_q_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_BYTES), dtn_ltp_agent_get_span_out_seg_q_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_CNT), dtn_ltp_agent_get_span_out_seg_pop_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_BYTES), dtn_ltp_agent_get_span_out_seg_pop_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_XMIT_CNT), dtn_ltp_agent_get_span_out_ckpt_xmit_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_POS_ACK_RX_CNT), dtn_ltp_agent_get_span_out_pos_ack_rx_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_NEG_ACK_RX_CNT), dtn_ltp_agent_get_span_out_neg_ack_rx_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_RX_CNT), dtn_ltp_agent_get_span_out_cancel_rx_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_REXMIT_CNT), dtn_ltp_agent_get_span_out_ckpt_rexmit_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_XMIT_CNT), dtn_ltp_agent_get_span_out_cancel_xmit_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_COMPLETE_CNT), dtn_ltp_agent_get_span_out_complete_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_CNT), dtn_ltp_agent_get_span_in_seg_rx_red_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_BYTES), dtn_ltp_agent_get_span_in_seg_rx_red_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_CNT), dtn_ltp_agent_get_span_in_seg_rx_green_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_BYTES), dtn_ltp_agent_get_span_in_seg_rx_green_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_CNT), dtn_ltp_agent_get_span_in_seg_rx_redundant_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_BYTES), dtn_ltp_agent_get_span_in_seg_rx_redundant_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_CNT), dtn_ltp_agent_get_span_in_seg_rx_mal_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_BYTES), dtn_ltp_agent_get_span_in_seg_rx_mal_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_CNT), dtn_ltp_agent_get_span_in_seg_rx_unk_sender_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_BYTES), dtn_ltp_agent_get_span_in_seg_rx_unk_sender_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_CNT), dtn_ltp_agent_get_span_in_seg_rx_unk_client_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_BYTES), dtn_ltp_agent_get_span_in_seg_rx_unk_client_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_CNT), dtn_ltp_agent_get_span_in_seg_stray_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_BYTES), dtn_ltp_agent_get_span_in_seg_stray_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_CNT), dtn_ltp_agent_get_span_in_seg_miscolor_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_BYTES), dtn_ltp_agent_get_span_in_seg_miscolor_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_CNT), dtn_ltp_agent_get_span_in_seg_closed_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_BYTES), dtn_ltp_agent_get_span_in_seg_closed_bytes);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CKPT_RX_CNT), dtn_ltp_agent_get_span_in_ckpt_rx_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_POS_ACK_TX_CNT), dtn_ltp_agent_get_span_in_pos_ack_tx_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_NEG_ACK_TX_CNT), dtn_ltp_agent_get_span_in_neg_ack_tx_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_TX_CNT), dtn_ltp_agent_get_span_in_cancel_tx_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_ACK_RETX_CNT), dtn_ltp_agent_get_span_in_ack_retx_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_RX_CNT), dtn_ltp_agent_get_span_in_cancel_rx_cnt);
-	adm_add_edd(adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_COMPLETE_CNT), dtn_ltp_agent_get_span_in_complete_cnt);
-}
-
-void dtn_ltp_agent_init_op()
-{
-
-}
-
-void dtn_ltp_agent_init_var()
-{
-
-}
-
-void dtn_ltp_agent_init_ctrl()
-{
-
-	adm_add_ctrldef(g_dtn_ltp_agent_idx[ADM_CTRL_IDX], DTN_LTP_AGENT_CTRL_RESET, 1, dtn_ltp_agent_ctrl_reset);
-}
-
-void dtn_ltp_agent_init_mac()
-{
-
-}
-
-void dtn_ltp_agent_init_rpttpl()
-{
-
-	rpttpl_t *def = NULL;
-
-	/* ENDPOINTREPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_ltp_agent_idx[ADM_RPTT_IDX], DTN_LTP_AGENT_RPTTPL_ENDPOINTREPORT));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_REMOTE_ENGINE_NBR, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_EXPT_SESS, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_OUT_SEG, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_IMP_SESS, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_IN_SEG, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_RESET_TIME, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_XMIT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_POS_ACK_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_NEG_ACK_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_REXMIT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_XMIT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_COMPLETE_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CKPT_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_POS_ACK_TX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_NEG_ACK_TX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_TX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_ACK_RETX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_COMPLETE_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	adm_add_rpttpl(def);
-}
-
-void dtn_ltp_agent_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* ENGINES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ltp_agent_idx[ADM_TBLT_IDX], DTN_LTP_AGENT_TBLT_ENGINES), dtn_ltp_agent_tblt_engines);
-	tblt_add_col(def, AMP_TYPE_UVAST, "peer_engine_nbr");
-	adm_add_tblt(def);
-}
-
-#endif // _HAVE_DTN_LTP_AGENT_ADM_
diff --git a/nm/agent/adm_ltp_agent_impl.c b/nm/agent/adm_ltp_agent_impl.c
deleted file mode 100644
index 45206cca..00000000
--- a/nm/agent/adm_ltp_agent_impl.c
+++ /dev/null
@@ -1,1381 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ltp_agent_impl.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "../shared/primitives/table.h"
-#include "ltpP.h"
-
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/adm/adm.h"
-#include "adm_ltp_agent_impl.h"
-
-/*   START CUSTOM FUNCTIONS HERE */
-
-int8_t get_span(tnvc_t *parms, NmltpSpan *stats)
-{
-  int success = 0;
-  uint32_t id = adm_get_parm_uint(parms, 0, &success);
-
-  if(success == 1)
-  {
-	  ltpnm_span_get(id, stats, (int *) &success);
-  }
-
-  return success;
-}
-
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ltp_agent_setup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	ltpAttach();
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION setup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-void dtn_ltp_agent_cleanup()
-{
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION cleanup BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-}
-
-
-/* Metadata Functions */
-
-
-tnv_t *dtn_ltp_agent_meta_name(tnvc_t *parms)
-{
-	return tnv_from_str("ltp_agent");
-}
-
-
-tnv_t *dtn_ltp_agent_meta_namespace(tnvc_t *parms)
-{
-	return tnv_from_str("DTN/ltp_agent");
-}
-
-
-tnv_t *dtn_ltp_agent_meta_version(tnvc_t *parms)
-{
-	return tnv_from_str("v0.0");
-}
-
-
-tnv_t *dtn_ltp_agent_meta_organization(tnvc_t *parms)
-{
-	return tnv_from_str("JHUAPL");
-}
-
-
-/* Constant Functions */
-/* Table Functions */
-
-
-/*
- * This table lists all known remote engine ids.
- */
-tbl_t *dtn_ltp_agent_tblt_engines(ari_t *id)
-{
-	tbl_t *table = NULL;
-	if((table = tbl_create(id)) == NULL)
-	{
-		return NULL;
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION tblt_engines BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	Sdr		sdr = getIonsdr();
-	LtpVdb		*vdb = getLtpVdb();
-	PsmPartition	ionwm = getIonwm();
-	Object		ltpdbObj = getLtpDbObject();
-	OBJ_POINTER(LtpDB, ltpdb);
-	PsmAddress	elt;
-	LtpVspan	*vspan;
-	tnvc_t  *cur_row = NULL;
-
-
-	CHKNULL(sdr_begin_xn(sdr));	/*	Just to lock memory.	*/
-	GET_OBJ_POINTER(sdr, LtpDB, ltpdb, ltpdbObj);
-
-	for (elt = sm_list_first(ionwm, vdb->spans); elt; elt = sm_list_next(ionwm, elt))
-	{
-		vspan = (LtpVspan *) psp(ionwm, sm_list_data(ionwm, elt));
-
-		/* (UVAST) peer_engine_nbr */
-		if((cur_row = tnvc_create(1)) != NULL)
-		{
-			tnvc_insert(cur_row, tnv_from_uvast(vspan->engineId));
-			tbl_add_row(table, cur_row);
-		}
-		else
-		{
-			AMP_DEBUG_WARN("dtn_ltp_agent_tblt_engines", "Can't allocate row. Skipping.", NULL);
-		}
-	}
-
-	sdr_exit_xn(sdr);
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION tblt_engines BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return table;
-}
-
-
-/* Collect Functions */
-/*
- * The remote engine number of this span.
- */
-tnv_t *dtn_ltp_agent_get_span_remote_engine_nbr(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_remote_engine_nbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.remoteEngineNbr);
-	}
-
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_remote_engine_nbr BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * Expected sessions on this span.
- */
-tnv_t *dtn_ltp_agent_get_span_cur_expt_sess(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_cur_expt_sess BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.currentExportSessions);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_cur_expt_sess BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The current number of outbound segments for this span.
- */
-tnv_t *dtn_ltp_agent_get_span_cur_out_seg(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_cur_out_seg BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.currentOutboundSegments);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_cur_out_seg BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The current number of import segments for this span.
- */
-tnv_t *dtn_ltp_agent_get_span_cur_imp_sess(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_cur_imp_sess BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.currentImportSessions);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_cur_imp_sess BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The current number of inbound segments for this span.
- */
-tnv_t *dtn_ltp_agent_get_span_cur_in_seg(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_cur_in_seg BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.currentInboundSegments);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_cur_in_seg BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The last time the span counters were reset.
- */
-tnv_t *dtn_ltp_agent_get_span_reset_time(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_reset_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.lastResetTime);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_reset_time BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output segment queued count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_seg_q_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_seg_q_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputSegQueuedCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_seg_q_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output segment queued bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_seg_q_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_seg_q_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputSegQueuedBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_seg_q_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output segment popped count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_seg_pop_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_seg_pop_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputSegPoppedCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_seg_pop_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output segment popped bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_seg_pop_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_seg_pop_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputSegPoppedBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_seg_pop_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output checkpoint transmit count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_ckpt_xmit_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_ckpt_xmit_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputCkptXmitCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_ckpt_xmit_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output positive acknowledgement received count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_pos_ack_rx_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_pos_ack_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputPosAckRecvCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_pos_ack_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output negative acknowledgement received count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_neg_ack_rx_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_neg_ack_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputNegAckRecvCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_neg_ack_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output cancelled received count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_cancel_rx_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_cancel_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputCancelRecvCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_cancel_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output checkpoint retransmit count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_ckpt_rexmit_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_ckpt_rexmit_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputCkptReXmitCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_ckpt_rexmit_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output cancel retransmit count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_cancel_xmit_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_cancel_xmit_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputCancelXmitCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_cancel_xmit_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The output completed count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_out_complete_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_out_complete_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.outputCompleteCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_out_complete_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment received red count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_red_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_red_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegRecvRedCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_red_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment received red bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_red_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_red_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegRecvRedBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_red_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment received green count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_green_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_green_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegRecvGreenCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_green_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment received green bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_green_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_green_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegRecvGreenBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_green_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment received redundant count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_redundant_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_redundant_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegRedundantCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_redundant_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment received redundant bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_redundant_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_redundant_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegRedundantBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_redundant_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment malformed count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_mal_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_mal_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegMalformedCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_mal_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment malformed bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_mal_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_mal_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegMalformedBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_mal_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment unknown sender count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_unk_sender_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_unk_sender_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegUnkSenderCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_unk_sender_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment unknown sender bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_unk_sender_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_unk_sender_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegUnkSenderBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_unk_sender_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment unknown client count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_unk_client_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_unk_client_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegUnkClientCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_unk_client_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment unknown client bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_unk_client_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_rx_unk_client_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegUnkClientBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_rx_unk_client_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment stray count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_stray_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_stray_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegStrayCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_stray_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment stray bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_stray_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_stray_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegStrayBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_stray_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment miscolored count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_miscolor_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_miscolor_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegMiscolorCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_miscolor_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment miscolored bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_miscolor_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_miscolor_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegMiscolorBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_miscolor_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment closed count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_closed_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_closed_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegClosedCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_closed_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input segment closed bytes for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_seg_closed_bytes(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_seg_closed_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputSegClosedBytes);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_seg_closed_bytes BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input checkpoint receive count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_ckpt_rx_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_ckpt_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputCkptRecvCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_ckpt_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input positive acknolwedgement transmitted count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_pos_ack_tx_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_pos_ack_tx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputPosAckXmitCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_pos_ack_tx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input negative acknolwedgement transmitted count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_neg_ack_tx_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_neg_ack_tx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputNegAckXmitCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_neg_ack_tx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input cancel transmitted count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_cancel_tx_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_cancel_tx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputCancelXmitCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_cancel_tx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input acknolwedgement retransmit count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_ack_retx_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_ack_retx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputAckReXmitCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_ack_retx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input cancel receive count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_cancel_rx_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_cancel_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputCancelRecvCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_cancel_rx_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-/*
- * The input completed count for the span.
- */
-tnv_t *dtn_ltp_agent_get_span_in_complete_cnt(tnvc_t *parms)
-{
-	tnv_t *result = NULL;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION get_span_in_complete_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	NmltpSpan stats;
-
-	if(get_span(parms, &stats) == 1)
-	{
-		result = tnv_from_uint(stats.inputCompleteCount);
-	}
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION get_span_in_complete_cnt BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* Control Functions */
-
-/*
- * Resets the counters associated with the engine and updates the last reset time for the span to be th
- * e time when this control was run.
- */
-tnv_t *dtn_ltp_agent_ctrl_reset(eid_t *def_mgr, tnvc_t *parms, int8_t *status)
-{
-	tnv_t *result = NULL;
-	*status = CTRL_FAILURE;
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |START CUSTOM FUNCTION ctrl_reset BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-
-	int success = 0;
-	uint32_t id = adm_get_parm_uint(parms, 0, &success);
-
-	if(success == 1)
-	{
-		ltpnm_span_reset(id, (int*) &success);
-		if(success == 1)
-		{
-			*status = CTRL_SUCCESS;
-		}
-	}
-
-	
-	/*
-	 * +-------------------------------------------------------------------------+
-	 * |STOP CUSTOM FUNCTION ctrl_reset BODY
-	 * +-------------------------------------------------------------------------+
-	 */
-	return result;
-}
-
-
-
-/* OP Functions */
diff --git a/nm/agent/adm_ltp_agent_impl.h b/nm/agent/adm_ltp_agent_impl.h
deleted file mode 100644
index e1f9ce6e..00000000
--- a/nm/agent/adm_ltp_agent_impl.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ltp_agent_impl.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-#ifndef ADM_LTP_AGENT_IMPL_H_
-#define ADM_LTP_AGENT_IMPL_H_
-
-/*   START CUSTOM INCLUDES HERE  */
-#include "ltpnm.h"
-
-/*   STOP CUSTOM INCLUDES HERE  */
-
-
-#include "shared/utils/utils.h"
-#include "shared/primitives/ctrl.h"
-#include "shared/primitives/table.h"
-#include "shared/primitives/tnv.h"
-
-/*   START typeENUM */
-/*   STOP typeENUM  */
-
-void name_adm_init_agent();
-
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                     Retrieval Functions                                     +
- * +---------------------------------------------------------------------------------------------+
- */
-/*   START CUSTOM FUNCTIONS HERE */
-/*   STOP CUSTOM FUNCTIONS HERE  */
-
-void dtn_ltp_agent_setup();
-void dtn_ltp_agent_cleanup();
-
-
-/* Metadata Functions */
-tnv_t *dtn_ltp_agent_meta_name(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_meta_namespace(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_meta_version(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_meta_organization(tnvc_t *parms);
-
-/* Constant Functions */
-
-/* Collect Functions */
-tnv_t *dtn_ltp_agent_get_span_remote_engine_nbr(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_cur_expt_sess(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_cur_out_seg(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_cur_imp_sess(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_cur_in_seg(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_reset_time(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_seg_q_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_seg_q_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_seg_pop_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_seg_pop_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_ckpt_xmit_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_pos_ack_rx_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_neg_ack_rx_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_cancel_rx_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_ckpt_rexmit_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_cancel_xmit_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_out_complete_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_red_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_red_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_green_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_green_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_redundant_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_redundant_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_mal_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_mal_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_unk_sender_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_unk_sender_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_unk_client_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_rx_unk_client_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_stray_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_stray_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_miscolor_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_miscolor_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_closed_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_seg_closed_bytes(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_ckpt_rx_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_pos_ack_tx_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_neg_ack_tx_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_cancel_tx_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_ack_retx_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_cancel_rx_cnt(tnvc_t *parms);
-tnv_t *dtn_ltp_agent_get_span_in_complete_cnt(tnvc_t *parms);
-
-
-/* Control Functions */
-tnv_t *dtn_ltp_agent_ctrl_reset(eid_t *def_mgr, tnvc_t *parms, int8_t *status);
-
-
-/* OP Functions */
-
-
-/* Table Build Functions */
-tbl_t *dtn_ltp_agent_tblt_engines(ari_t *id);
-
-#endif //ADM_LTP_AGENT_IMPL_H_
diff --git a/nm/agent/ingest.c b/nm/agent/ingest.c
index feddff29..0cc73900 100644
--- a/nm/agent/ingest.c
+++ b/nm/agent/ingest.c
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2011-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -25,10 +36,14 @@
  **  10/04/18  E. Birrane      Updated to AMP v0.5 (JHU/APL)
  *****************************************************************************/
 
+#include <inttypes.h>
+#include <pthread.h>
 #include "ingest.h"
 #include "instr.h"
-#include "nmagent.h"
 #include "lcc.h"
+#include "nmagent.h"
+#include "../shared/msg/msg_if.h"
+#include "../shared/utils/daemon_run.h"
 #include "../shared/utils/db.h"
 #include "../shared/primitives/ctrl.h"
 
@@ -53,11 +68,12 @@
  *  10/04/18  E. Birrane     Update to AMP v0.5 (JHU/APL)
  *****************************************************************************/
 
-void *rx_thread(int *running) {
+void *rx_thread(void *arg) {
+    nmagent_t *agent = arg;
 #ifndef mingw
-    AMP_DEBUG_ENTRY("rx_thread","(0x%X)",(unsigned long) pthread_self());
+    AMP_DEBUG_ENTRY("rx_thread","agent(%p)", agent);;
 #endif
-    AMP_DEBUG_INFO("rx_thread","Receiver thread running...", NULL);
+    AMP_DEBUG_INFO("rx_thread","Receiver thread running...");
     
 
     vecit_t it;
@@ -71,13 +87,14 @@ void *rx_thread(int *running) {
      * g_running controls the overall execution of threads in the
      * NM Agent.
      */
-    while(*running)
+    while(daemon_run_get(&agent->running))
     {
-        
-    	result = iif_receive(&ion_ptr, &meta, NM_RECEIVE_TIMEOUT_SEC, &success);
+    	result = mif_receive(&agent->mif, &meta, &agent->running, &success);
     	if(success != AMP_OK)
     	{
-    		*running = 0;
+                AMP_DEBUG_INFO("rx_thread","Got mif_receive success=%d, stopping.", success);
+                daemon_run_stop(&agent->running);
+                continue;
     	}
     	else if(result != NULL)
         {
@@ -88,11 +105,11 @@ void *rx_thread(int *running) {
     		if((grp == NULL) || (success != AMP_OK))
     		{
     			AMP_DEBUG_ERR("rx_thread","Discarding invalid message.", NULL);
-    			break;
+    			continue;
     		}
 
             AMP_DEBUG_ALWAYS("rx_thread","Group had %d msgs", vec_num_entries(grp->msgs));
-            AMP_DEBUG_ALWAYS("rx_thread","Group timestamp %lu", grp->time);
+            AMP_DEBUG_ALWAYS("rx_thread","Group timestamp %lu", grp->timestamp);
 
             /* For each message in the bundle. */
             for(it = vecit_first(&grp->msgs); vecit_valid(it); it = vecit_next(it))
@@ -119,8 +136,8 @@ void *rx_thread(int *running) {
    
     AMP_DEBUG_ALWAYS("rx_thread","Shutting Down Agent Receive Thread.",NULL);
     AMP_DEBUG_EXIT("rx_thread","->.", NULL);
-    pthread_exit(NULL);
-    return NULL; /* Defensive. */
+
+    return NULL;
 }
 
 
@@ -156,8 +173,8 @@ void rx_handle_perf_ctrl(msg_metadata_t *meta, blob_t *contents)
 	int success;
 	vec_idx_t i;
 
-	AMP_DEBUG_ENTRY("rx_handle_perf_ctrl","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-					(uaddr)meta, (uaddr) contents);
+	AMP_DEBUG_ENTRY("rx_handle_perf_ctrl","(%"PRIxPTR",%"PRIxPTR")",
+					meta, contents);
 
 	if((meta == NULL) || (contents == NULL))
 	{
@@ -186,17 +203,19 @@ void rx_handle_perf_ctrl(msg_metadata_t *meta, blob_t *contents)
 			break;
 		}
 
-		ctrl_set_exec(ctrl, msg->start, meta->senderEid);
-
+		ctrl_set_exec(ctrl, msg->start, meta->source);
 
-		if(ctrl->start == 0)
+                AMP_DEBUG_ERR("rx_handle_perf_ctrl","Executing ctrl at time %d (from %d start TV)", OS_TimeGetTotalSeconds(ctrl->start), msg->start);
+                OS_time_t nowtime;
+                OS_GetLocalTime(&nowtime);
+		if(TimeCompare(ctrl->start, nowtime) <= 0)
 		{
 			lcc_run_ctrl(ctrl, NULL);
 			ctrl_release(ctrl, 1);
 		}
 		else
 		{
-
+#if 0
 			if(db_persist_ctrl(ctrl) != AMP_OK)
 			{
 				AMP_DEBUG_ERR("rx_ingest_ctrl", "Cannot persist ctrl.", NULL);
@@ -213,6 +232,7 @@ void rx_handle_perf_ctrl(msg_metadata_t *meta, blob_t *contents)
 				ctrl_release(ctrl, 1);
 				break;
 			}
+#endif
 		}
 	}
 
diff --git a/nm/agent/ingest.h b/nm/agent/ingest.h
index b1d0c9b9..8bbd2d4c 100644
--- a/nm/agent/ingest.h
+++ b/nm/agent/ingest.h
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -27,7 +38,15 @@
 
 #include "../shared/msg/msg.h"
 
-void *rx_thread(int *running);
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void *rx_thread(void *arg);
 void rx_handle_perf_ctrl(msg_metadata_t *meta, blob_t *contents);
 
-#endif /* _INGEST_H_ */
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _INGEST_H_ */
diff --git a/nm/agent/instr.c b/nm/agent/instr.c
index 143c1391..8716c631 100644
--- a/nm/agent/instr.c
+++ b/nm/agent/instr.c
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
diff --git a/nm/agent/instr.h b/nm/agent/instr.h
index 940e0dc7..845996ee 100644
--- a/nm/agent/instr.h
+++ b/nm/agent/instr.h
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -20,6 +31,7 @@
  **  MM/DD/YY  AUTHOR         DESCRIPTION
  **  --------  ------------   ---------------------------------------------
  **  07/04/13  E. Birrane     Initial Implementation (JHU/APL)
+ **  11/23/21  E. Birrane     Added counting of sent table sets (JHU/APL)
  *****************************************************************************/
 
 
@@ -29,6 +41,11 @@
 
 #include "../shared/utils/nm_types.h"
 
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
@@ -53,6 +70,7 @@
 
 typedef struct {
 	unsigned long num_sent_rpts;
+	unsigned long num_sent_tbls;
 	unsigned long num_tbrs;
 	unsigned long num_tbrs_run;
 	unsigned long num_sbrs;
@@ -75,4 +93,9 @@ void agent_instr_clear();
 
 extern agent_instr_t gAgentInstr;
 
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* _INSTR_H_ */
diff --git a/nm/agent/lcc.c b/nm/agent/lcc.c
index 22006885..5507811b 100644
--- a/nm/agent/lcc.c
+++ b/nm/agent/lcc.c
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: lcc.c
@@ -23,6 +34,7 @@
  **  05/17/15  E. Birrane     Add Macro support, updated to DTNMP v0.1 (Secure DTN - NASA: NNX14CS58P)
  *****************************************************************************/
 
+#include <inttypes.h>
 #include "lcc.h"
 
 #include "../shared/primitives/rules.h"
@@ -94,7 +106,7 @@ int lcc_run_ctrl(ctrl_t *ctrl, tnvc_t *parent_parms)
     tnvc_t *new_parms = NULL;
     eid_t rx_eid;
 
-	AMP_DEBUG_ENTRY("lcc_run_ctrl","("ADDR_FIELDSPEC")", (uaddr) ctrl);
+	AMP_DEBUG_ENTRY("lcc_run_ctrl","(%"PRIxPTR")", ctrl);
 
 	if(ctrl == NULL)
 	{
@@ -103,7 +115,7 @@ int lcc_run_ctrl(ctrl_t *ctrl, tnvc_t *parent_parms)
 
 	if(strlen(ctrl->caller.name) <= 0)
 	{
-		rx_eid = manager_eid;
+		strcpy(rx_eid.name, "dtn:none");// = manager_eid;
 	}
 	else
 	{
@@ -220,7 +232,10 @@ void lcc_send_retval(eid_t *rx, tnv_t *retval, ctrl_t *ctrl, tnvc_t *parms)
 	ari_t *ctrl_ari = ctrl_get_id(ctrl);
 	ari = ari_copy_ptr(ctrl_ari);
 	ari_replace_parms(ari, parms);
-	report = rpt_create(ari, getCtime(), NULL);
+
+	OS_time_t timestamp;
+	OS_GetLocalTime(&timestamp);
+	report = rpt_create(ari, timestamp, NULL);
 	CHKVOID(report);
 
 	/* Add the single entry to this report. */
diff --git a/nm/agent/lcc.h b/nm/agent/lcc.h
index a00b20df..df1c48ad 100644
--- a/nm/agent/lcc.h
+++ b/nm/agent/lcc.h
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -29,6 +40,10 @@
 #include "../shared/adm/adm.h"
 #include "../shared/utils/nm_types.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #define LCC_MAX_NESTING 5
 
 
@@ -45,5 +60,9 @@ int lcc_run_macro(macdef_t *mac, tnvc_t *parent_parms);
 void lcc_send_retval(eid_t *rx, tnv_t *retval, ctrl_t *ctrl, tnvc_t *parms);
 
 
-#endif // _LCC_H_
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _LCC_H_ */
 
diff --git a/nm/agent/ldc.c b/nm/agent/ldc.c
index e54db3ab..8bb44142 100644
--- a/nm/agent/ldc.c
+++ b/nm/agent/ldc.c
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2011-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -25,6 +36,7 @@
  **  10/04/18  E. Birrane     UPdate to AMP V0.5. (JHU/APL)
  *****************************************************************************/
 
+#include <inttypes.h>
 #include "../shared/adm/adm.h"
 #include "../shared/primitives/report.h"
 #include "../shared/primitives/expr.h"
@@ -116,7 +128,10 @@ tnv_t *ldc_collect_rpt(ari_t *id, tnvc_t *parms)
 
 	/* Build a report for this template. */
 	new_id = ari_copy_ptr(new_tpl->id);
-	if((rpt = rpt_create(new_id, getCtime(), NULL)) == NULL)
+
+        OS_time_t timestamp;
+        OS_GetLocalTime(&timestamp);
+	if((rpt = rpt_create(new_id, timestamp, NULL)) == NULL)
 	{
 		rpttpl_release(new_tpl, 1);
 		ari_release(new_id, 1);
@@ -149,6 +164,7 @@ tnv_t *ldc_collect_var(ari_t *id, tnvc_t *parms)
 	var = VDB_FINDKEY_VAR(id);
 	if(var == NULL)
 	{
+		AMP_DEBUG_ERR("ldc_collect_var","Can't find ARI.", NULL);
 		return NULL;
 	}
 
@@ -194,8 +210,7 @@ int ldc_fill_rpt(rpttpl_t *rpttpl, rpt_t *rpt)
 	uint8_t i;
 	int success;
 
-	AMP_DEBUG_ENTRY("ldc_fill_rpt","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-			          (uaddr) rpttpl, (uaddr) rpt);
+	AMP_DEBUG_ENTRY("ldc_fill_rpt","(%p,%p)", rpttpl, rpt);
 
 	CHKUSR(rpttpl, AMP_FAIL);
 	CHKUSR(rpt, AMP_FAIL);
diff --git a/nm/agent/ldc.h b/nm/agent/ldc.h
index 81c581a5..2ac7d32e 100644
--- a/nm/agent/ldc.h
+++ b/nm/agent/ldc.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2011-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -30,6 +42,10 @@
 
 #include "../shared/primitives/report.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #define LDC_MAX_NESTING (5)
 
 
@@ -44,5 +60,9 @@ tnv_t *ldc_collect_var(ari_t *id, tnvc_t *parms);
 int    ldc_fill_rpt(rpttpl_t *rpttpl, rpt_t *rpt);
 
 
-#endif // _LDC_H_
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _LDC_H_ */
 
diff --git a/nm/agent/nmagent.c b/nm/agent/nmagent.c
index aaa2dfcf..cc118779 100644
--- a/nm/agent/nmagent.c
+++ b/nm/agent/nmagent.c
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2011-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: nmagent.c
@@ -24,13 +35,11 @@
  **  10/04/18  E. Birrane      Updated to AMP v0.5 (JHU/APL)
  *****************************************************************************/
 
-// System headers.
-#include "unistd.h"
-
-// ION headers.
-#include "platform.h"
+#include <inttypes.h>
+#include <unistd.h>
+#include <errno.h>
+#include "shared/platform.h"
 
-// Application headers.
 #include "../shared/nm.h"
 #include "../shared/adm/adm.h"
 #include "../shared/utils/db.h"
@@ -38,57 +47,30 @@
 #include "nmagent.h"
 #include "ingest.h"
 #include "rda.h"
-
 #include "instr.h"
 
-static void agent_signal_handler(int signum);
-
-
-// Definitions of global data.
-iif_t        ion_ptr;
-uint8_t      gRunning;
-eid_t        manager_eid;
-eid_t        agent_eid;
-
-
-
-/******************************************************************************
- *
- * \par Function Name: agent_register
- *
- * \par Send a broadcast registration message for this agent.
- *
- * \par Notes:
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- *  06/10/13  E. Birrane     Initial implementation.
- *  10/04/18  E. Birrane     Update to AMP v0.5 (JHU/APL)
- *****************************************************************************/
 
-void agent_register()
+bool nmagent_init(nmagent_t *agent)
 {
-	msg_agent_t *msg = NULL;
+  memset(agent, 0, sizeof(nmagent_t));
+  daemon_run_init(&agent->running);
 
-	if((msg = msg_agent_create()) == NULL)
-	{
-		AMP_DEBUG_ERR("agent_register","Unable to create agent registration.",NULL);
-		return;
-	}
-
-	msg_agent_set_agent(msg, agent_eid);
-
-	if(iif_send_msg(&ion_ptr, MSG_TYPE_REG_AGENT, msg, manager_eid.name) != AMP_OK)
-	{
-		AMP_DEBUG_ERR("agent_register","Couldn't send agent reg.", NULL);
-	}
+  if ((utils_mem_int() != AMP_OK)
+      || (db_init("nmagent_db", &adm_common_init) != AMP_OK))
+  {
+    db_destroy();
+    AMP_DEBUG_ERR("nmagent_init", "Unable to initialize DB.", NULL);
+    return false;
+  }
 
-	msg_agent_release(msg, 1);
+  return true;
 }
 
-
-
+bool nmagent_destroy(nmagent_t *agent)
+{
+  daemon_run_cleanup(&agent->running);
+  return true;
+}
 
 /******************************************************************************
  *
@@ -96,9 +78,6 @@ void agent_register()
  *
  * \par Main agent processing function.
  *
- * \param[in]  argc    # command line arguments.
- * \param[in]  argv[]  Command-line arguments.
- *
  * \par Notes:
  *
  * Modification History:
@@ -110,179 +89,32 @@ void agent_register()
  **  02/23/15  E. Birrane      Updated to support ION_LWT targets
  **  10/04/18  E. Birrane      Updated to AMP v0.5 (JHU/APL)
  *****************************************************************************/
-
-#if defined (ION_LWT) || defined(TEST_MAIN)
-int	nmagent(saddr a1, saddr a2, saddr a3, saddr a4, saddr a5,
-		saddr a6, saddr a7, saddr a8, saddr a9, saddr a10)
+bool nmagent_start(nmagent_t *agent)
 {
-
-	/* Step 0: Sanity check. */
-	int argc = 3;
-	char *argv[3];
-
-	argv[0] = (char *) a1;
-	argv[1] = (char *) a2;
-	argv[2] = (char *) a3;
-
-#else
-int	main(int argc, char *argv[])
-{
-#endif
-
-    pthread_t ingest_thr;
-    pthread_t rda_thr;
-    
-    char ingest_thr_name[]  = "ingest_thread";
-    char rda_thr_name[]     = "rda_thread";
     int rc;
-    errno = 0;
-
-
-    AMP_DEBUG_ENTRY("agent_main","(%d,"ADDR_FIELDSPEC")", argc, (uaddr)argv);
-
-    /* Step 1: Process Command Line Arguments. */
-    if(argc != 3)
-    {
-        printf("Usage: nmagent <agent eid> <manager eid>\n");
-        printf("AMP Protocol Version %d - %s/%02d, built on %s %s\n", AMP_VERSION, AMP_PROTOCOL_URL, AMP_VERSION, __DATE__, __TIME__);
-        return 0;
-    }
-    
-    if(((argv[0] == NULL) || (strlen(argv[0]) <= 0)) ||
-       ((argv[1] == NULL) || (strlen(argv[1]) <= 0) || (strlen(argv[1]) >= AMP_MAX_EID_LEN)) ||
-       ((argv[2] == NULL) || (strlen(argv[2]) <= 0) || (strlen(argv[2]) >= AMP_MAX_EID_LEN))
-        )
-    {
-		AMP_DEBUG_ERR("agent_main", "Invalid Parameters (NULL or 0).", NULL);
-		return -1;
-    }
-
-    AMP_DEBUG_INFO("agent main","Agent EID: %s, Mgr EID: %s", argv[1], argv[2]);
-    
-    strcpy((char *) manager_eid.name, argv[2]);
-    strcpy((char *) agent_eid.name, argv[1]);
-
-
-    /* Step 2: Make sure that ION is running and we can attach. */
-	if (ionAttach() < 0)
-	{
-		AMP_DEBUG_ERR("agent_main", "Agent can't attach to ION.", NULL);
-		return -1;
-	}
-
-    if(iif_register_node(&ion_ptr, agent_eid) != 1)
-    {
-        AMP_DEBUG_ERR("agent_main","Unable to register BP Node. Exiting.",
-        		         NULL);
-        return -1;
-    }
-   
-    if (iif_is_registered(&ion_ptr))
-    {
-        AMP_DEBUG_INFO("agent_main","Agent registered with ION, EID: %s",
-        		           iif_get_local_eid(&ion_ptr).name);
-    }
-    else
-    {
-        AMP_DEBUG_ERR("agent_main","Failed to register agent with ION, EID %s",
-        		         iif_get_local_eid(&ion_ptr).name);
-    	return -1;
-    }
-   
-
-	/* Step 3: Initialize objects and instrumentation. */
-
-	if((utils_mem_int()       != AMP_OK) ||
-	   (db_init("nmagent_db",&adm_init) != AMP_OK))
-	{
-		db_destroy();
-		AMP_DEBUG_ERR("agent_main","Unable to initialize DB.", NULL);
-		return -1;
-	}
-
-	agent_instr_init();
-
-    /* Step 4: Register signal handlers. */
-    isignal(SIGINT, agent_signal_handler);
-    isignal(SIGTERM, agent_signal_handler);
+    AMP_DEBUG_ENTRY("nmagent_start","(%p)", agent);
 
+    rda_init();
 
     /* Step 5: Start agent threads. */
-    gRunning = 1;
-    /*! use pthread_begin() so thread can be named and have its stacksize adjusted on some OS's */
-    /*! and provide threads with a pointer to gRunning, so threads will shutdown */
-    //rc = pthread_create(&ingest_thr, NULL, (void *)rx_thread, (void *)ingest_thr_name);
-    rc = pthread_begin(&ingest_thr, NULL, (void *)rx_thread, (void *)&gRunning, "nmagent_ingest");
-
-    if (rc)
+    threadinfo_t threadinfo[] = {
+        {&rx_thread, "rx_thread"},
+        {&rda_ctrls, "rda_ctrls"},
+        {&rda_reports, "rda_reports"},
+        {&rda_rules, "rda_rules"},
+    };
+    rc = threadset_start(&agent->threads, threadinfo, sizeof(threadinfo)/sizeof(threadinfo_t), agent);
+    if (rc != AMP_OK)
     {
-        AMP_DEBUG_ERR("agent_main","Unable to create pthread %s, errno = %s",
-        		ingest_thr_name, strerror(errno));
-
-        db_destroy();
-
-    	AMP_DEBUG_EXIT("agent_main","->-1",NULL);
-    	return -1;
+      db_destroy();
+      AMP_DEBUG_EXIT("agent_main","->-1",NULL);
+      return false;
     }
-   
-    //rc = pthread_create(&rda_thr, NULL, (void *)rda_thread, (void *)rda_thr_name);
-    rc = pthread_begin(&rda_thr, NULL, (void *)rda_thread, (void *)&gRunning, "nmagent_rda");
-
-    if (rc)
-    {
-       AMP_DEBUG_ERR("agent_main","Unable to create pthread %s, errno = %s",
-    		           rda_thr_name, strerror(errno));
 
-       db_destroy();
-
-       AMP_DEBUG_EXIT("agent_main","->-1",NULL);
-       return -1;
-    }
-   
     AMP_DEBUG_ALWAYS("agent_main","Threads started...", NULL);
-
-
-    /* Step 6: Send out agent broadcast message. */
-    agent_register();
-
-    /* Step 7: Join threads and wait for them to complete. */
-    if (pthread_join(ingest_thr, NULL))
-    {
-        AMP_DEBUG_ERR("agent_main","Unable to join pthread %s, errno = %s",
-     		           ingest_thr_name, strerror(errno));
-
-        db_destroy();
-
-        AMP_DEBUG_EXIT("agent_main","->-1",NULL);
-        return -1;
-    }
-
-    if (pthread_join(rda_thr, NULL))
-    {
-        AMP_DEBUG_ERR("agent_main","Unable to join pthread %s, errno = %s",
-     		           rda_thr_name, strerror(errno));
-
-           db_destroy();
-
-        AMP_DEBUG_EXIT("agent_main","->-1",NULL);
-        return -1;
-    }
-   
-    /* Step 8: Cleanup. */
-    AMP_DEBUG_ALWAYS("agent_main","Cleaning Agent Resources.",NULL);
-
-    db_destroy();
-
-    AMP_DEBUG_ALWAYS("agent_main","Stopping Agent.",NULL);
-
-    AMP_DEBUG_INFO("agent_main","Exiting Agent after cleanup.", NULL);
-
-	utils_mem_teardown();
-    return 0;
+    return true;
 }
 
-
-
 /******************************************************************************
  *
  * \par Function Name: agent_signal_handler
@@ -297,10 +129,40 @@ int	main(int argc, char *argv[])
  **  08/18/13  E. Birrane    Initial Implementation
  *****************************************************************************/
 
-static void agent_signal_handler(int signum)
+bool nmagent_stop(nmagent_t *agent)
 {
-	isignal(SIGINT,agent_signal_handler);
-	isignal(SIGTERM, agent_signal_handler);
+  /* Notify threads */
+  daemon_run_stop(&agent->running);
+  rda_signal_shutdown();
+  threadset_join(&agent->threads);
+
+  /* Step 8: Cleanup. */
+  AMP_DEBUG_ALWAYS("agent_main","Cleaning Agent Resources.",NULL);
+  
+  rda_cleanup();
+  
+  AMP_DEBUG_ALWAYS("agent_main","Stopping Agent.",NULL);
+  
+  return true;
+}
 
-	gRunning = 0;
+bool nmagent_register(nmagent_t *agent, const eid_t *agent_eid, const eid_t *mgr_eid)
+{
+  bool valid = true;
+  msg_agent_t *msg = NULL;
+
+  if((msg = msg_agent_create()) == NULL)
+  {
+    AMP_DEBUG_ERR("agent_register","Unable to create agent registration.",NULL);
+    return false;
+  }
+  msg_agent_set_agent(msg, *agent_eid);
+  if(mif_send_msg(&agent->mif, MSG_TYPE_REG_AGENT, msg, mgr_eid, AMP_TV_ZERO) != AMP_OK)
+  {
+    AMP_DEBUG_ERR("agent_register","Couldn't send agent reg.", NULL);
+    valid = false;
+  }
+
+  msg_agent_release(msg, 1);
+  return valid;
 }
diff --git a/nm/agent/nmagent.h b/nm/agent/nmagent.h
index 819a5d4d..af1d6e02 100644
--- a/nm/agent/nmagent.h
+++ b/nm/agent/nmagent.h
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: nmagent.h
@@ -28,21 +39,22 @@
 #define DEBUG 1
 
 // Standard includes
-#include "stdint.h"
-#include "pthread.h"
-
-// ION includes
-#include "platform.h"
+#include <stdint.h>
 
 // Application includes
-
-#include "../shared/utils/nm_types.h"
-#include "../shared/msg/ion_if.h"
-
-#include "../shared/primitives/ari.h"
-#include "../shared/primitives/rules.h"
-
-#include "../shared/msg/msg.h"
+#include "shared/platform.h"
+#include "shared/utils/daemon_run.h"
+#include "shared/utils/nm_types.h"
+#include "shared/utils/daemon_run.h"
+#include "shared/utils/threadset.h"
+#include "shared/primitives/ari.h"
+#include "shared/primitives/rules.h"
+#include "shared/msg/msg.h"
+#include "shared/msg/msg_if.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /*
  * +--------------------------------------------------------------------------+
@@ -50,9 +62,6 @@
  * +--------------------------------------------------------------------------+
  */
 
-static const int32_t NM_RECEIVE_TIMEOUT_SEC = 1;
-
-
 
 /*
  * +--------------------------------------------------------------------------+
@@ -66,6 +75,15 @@ static const int32_t NM_RECEIVE_TIMEOUT_SEC = 1;
  * |							  DATA TYPES  								  +
  * +--------------------------------------------------------------------------+
  */
+typedef struct {
+  /// Running state
+  daemon_run_t running;
+  /// Messaging configuration
+  mif_cfg_t mif;
+  /// Threads associated with the agent
+  list_thread_t threads;
+
+} nmagent_t;
 
 /*
  * +--------------------------------------------------------------------------+
@@ -73,17 +91,18 @@ static const int32_t NM_RECEIVE_TIMEOUT_SEC = 1;
  * +--------------------------------------------------------------------------+
  */
 
-#if defined (ION_LWT)
-int	nmagent(saddr a1, saddr a2, saddr a3, saddr a4, saddr a5,
-		saddr a6, saddr a7, saddr a8, saddr a9, saddr a10);
-#else
-	int	main(int argc, char *argv[]);
-#endif
+bool nmagent_init(nmagent_t *agent);
 
-void agent_register();
+bool nmagent_destroy(nmagent_t *agent);
 
+bool nmagent_start(nmagent_t *agent);
 
+bool nmagent_stop(nmagent_t *agent);
 
+/** Once the agent is running, send a registration message
+ * @sa nmagent_start
+ */
+bool nmagent_register(nmagent_t *agent, const eid_t *agent_eid, const eid_t *mgr_eid);
 
 
 /*
@@ -92,30 +111,10 @@ void agent_register();
  * +--------------------------------------------------------------------------+
  */
 
-/**
- * Indicates if the thread loops should continue to run. This
- * value is updated by the main() and read by the subordinate
- * threads.
- **/
- extern uint8_t g_running;
-
-
-/**
- * The endpoint identifier (EID) of the network manager node.
- * TODO: Make this a vector and handle multiple managers.
- **/
-extern eid_t manager_eid;
-
-/**
- * The endpoint identifier (EID) of this agent node.
- **/
-extern eid_t agent_eid;
-
-/**
- * The interface object the ION system.
- **/
-extern iif_t ion_ptr;
 
 
+#ifdef __cplusplus
+}
+#endif
 
-#endif //_NM_AGENT_H_
+#endif  /* _NM_AGENT_H_ */
diff --git a/nm/agent/rda.c b/nm/agent/rda.c
index 02e4b238..b3857512 100644
--- a/nm/agent/rda.c
+++ b/nm/agent/rda.c
@@ -1,12 +1,23 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  ** \file rda.c
- ** 
+ **
  ** File Name: rda.c
  **
  **
@@ -19,7 +30,7 @@
  **              rules, constructs the appropriate data reports, and queues
  **              them for transmission.
  **
- ** Notes:  
+ ** Notes:
  **
  ** Assumptions:
  **      1. We assume that this code is not under such tight profiling
@@ -36,22 +47,34 @@
  **  10/04/18  E. Birrane     Update to AMP v0.5 (JHU/APL)
  *****************************************************************************/
 
-#include "platform.h"
+#include <inttypes.h>
+#include "shared/platform.h"
+#include "shared/primitives/time.h"
 
 #include "../shared/utils/utils.h"
 #include "instr.h"
 #include "../shared/primitives/expr.h"
 
 #include "../shared/utils/db.h"
+#include "../shared/msg/msg_if.h"
 
-#include "nmagent.h"
 #include "ldc.h"
 #include "lcc.h"
 #include "rda.h"
+#include "nmagent.h"
 
 
 agent_db_t gAgentDb;
 
+/** Context for active rule scanning. */
+typedef struct
+{
+  /// Scanning time
+  OS_time_t nowtime;
+  /// Vector of valid rules
+  vector_t *vec;
+} rda_scan_context_t;
+
 /******************************************************************************
  *
  * \par Function Name: rda_cleanup
@@ -68,25 +91,46 @@ agent_db_t gAgentDb;
  *  10/21/11  E. Birrane     Initial implementation,
  *  05/20/15  E. Birrane     Switched to global, mutex-protected lysts.
  *  10/04/18  E. Birrane     Updated to AMP V0.5 (JHU/APL)
+ *  11/23/21  E. Birrane     Added table sets (JHU/APL)
  *****************************************************************************/
 
 void rda_cleanup()
 {
-	vec_release(&(gAgentDb.rpt_msgs), 0);
-	vec_release(&(gAgentDb.tbrs), 0);
-	vec_release(&(gAgentDb.sbrs), 0);
+        vec_release(&(gAgentDb.rpt_msgs), 0);
+        vec_release(&(gAgentDb.tbl_msgs), 0);
+        vec_release(&(gAgentDb.tbrs), 0);
+        vec_release(&(gAgentDb.sbrs), 0);
 }
 
 int rda_init()
 {
-	int success;
+        int success;
 
-	gAgentDb.rpt_msgs = vec_create(RDA_DEF_NUM_RPTS, msg_rpt_cb_del_fn, NULL, NULL, 0, &success);
+        gAgentDb.rpt_msgs = vec_create(RDA_DEF_NUM_RPTS, msg_rpt_cb_del_fn, NULL, NULL, 0, &success);
+        gAgentDb.tbl_msgs = vec_create(RDA_DEF_NUM_TBLS, msg_tbl_cb_del_fn, NULL, NULL, 0, &success);
 
-	gAgentDb.tbrs = vec_create(RDA_DEF_NUM_TBRS, NULL, NULL, NULL, 0, &success);
-	gAgentDb.sbrs = vec_create(RDA_DEF_NUM_SBRS, NULL, NULL, NULL, 0, &success);
+        gAgentDb.tbrs = vec_create(RDA_DEF_NUM_TBRS, NULL, NULL, NULL, 0, &success);
+        gAgentDb.sbrs = vec_create(RDA_DEF_NUM_SBRS, NULL, NULL, NULL, 0, &success);
 
-	return success;
+        return success;
+}
+
+void rda_signal_shutdown()
+{
+  vector_t *vec = &(gVDB.ctrls);
+  pthread_mutex_lock(&vec->lock);
+  pthread_cond_broadcast(&vec->cond_ins_mod);
+  pthread_mutex_unlock(&vec->lock);
+
+  rhht_t *ht = &(gVDB.rules);
+  pthread_mutex_lock(&ht->lock);
+  pthread_cond_broadcast(&ht->cond_ins_mod);
+  pthread_mutex_unlock(&ht->lock);
+
+  vec = &(gAgentDb.rpt_msgs);
+  pthread_mutex_lock(&vec->lock);
+  pthread_cond_broadcast(&vec->cond_ins_mod);
+  pthread_mutex_unlock(&vec->lock);
 }
 
 /******************************************************************************
@@ -115,17 +159,17 @@ int rda_init()
 
 msg_rpt_t *rda_get_msg_rpt(eid_t recipient)
 {
-	vecit_t it;
-	int success;
-	msg_rpt_t *msg_rpt;
+        vecit_t it;
+        int success;
+        msg_rpt_t *msg_rpt;
 
     AMP_DEBUG_ENTRY("rda_get_report","(%s)", recipient.name);
-    
+
     /* Step 0: Sanity check. */
     if(strlen(recipient.name) <= 0)
     {
-    	AMP_DEBUG_ERR("rda_get_report","Bad parms.",NULL);
-    	return NULL;
+        AMP_DEBUG_ERR("rda_get_report","Bad parms.",NULL);
+        return NULL;
     }
 
     /* Step 1: See if we already have a report message going to
@@ -133,29 +177,114 @@ msg_rpt_t *rda_get_msg_rpt(eid_t recipient)
      */
     for(it = vecit_first(&(gAgentDb.rpt_msgs)); vecit_valid(it); it = vecit_next(it))
     {
-    	msg_rpt_t *cur = vecit_data(it);
+        msg_rpt_t *cur = vecit_data(it);
 
-    	vec_find(&(cur->rx), recipient.name, &success);
-    	if(success == AMP_OK)
-    	{
-    		return cur;
-    	}
+        vec_find(&(cur->rx), recipient.name, &success);
+        if(success == AMP_OK)
+        {
+                return cur;
+        }
     }
 
     /* Step 2; If we get here, create a new report for that recipient. */
     if((msg_rpt = msg_rpt_create(recipient.name)) != NULL)
     {
-    	if(vec_push(&(gAgentDb.rpt_msgs), msg_rpt) != VEC_OK)
-    	{
-    		msg_rpt_release(msg_rpt, 1);
-    		return NULL;
-    	}
+        if(vec_push(&(gAgentDb.rpt_msgs), msg_rpt) != VEC_OK)
+        {
+                msg_rpt_release(msg_rpt, 1);
+                return NULL;
+        }
     }
 
     return msg_rpt;
 }
 
 
+/******************************************************************************
+ *
+ * \par Function Name: rda_get_msg_tbl
+ *
+ * \par Purpose: Find the table set intended for a given recipient. The
+ *               agent will, when possible, combine table sets for a single
+ *               recipient.
+ *
+ * \param[in]  recipient     - The recipient for which we are searching for
+ *                             a table set.
+ *
+ * \par Notes:
+ *
+ * \return !NULL - Report for this recipient.
+ *         NULL  - Error.
+ *
+ * Modification History:
+ *  MM/DD/YY  AUTHOR         DESCRIPTION
+ *  --------  ------------   ---------------------------------------------
+ *  11/23/21  E. Birrane     Initial Implementation (JHU/APL)
+ *****************************************************************************/
+
+msg_tbl_t *rda_get_msg_tbl(eid_t recipient)
+{
+    vecit_t it;
+    msg_tbl_t *msg_tbl;
+
+    AMP_DEBUG_ENTRY("rda_get_msg_tbl","(%s)", recipient.name);
+
+    /* Step 0: Sanity check. */
+    if(strlen(recipient.name) <= 0)
+    {
+        AMP_DEBUG_ERR("rda_get_msg_tbl","Bad parms.",NULL);
+        return NULL;
+    }
+
+    /* Step 1: See if we already have a report message going to
+     * that recipient. If so, return it.
+     */
+    for(it = vecit_first(&(gAgentDb.tbl_msgs)); vecit_valid(it); it = vecit_next(it))
+    {
+        int success;
+        msg_tbl_t *cur = vecit_data(it);
+
+        vec_find(&(cur->rx), recipient.name, &success);
+        if(success == AMP_OK)
+        {
+            return cur;
+        }
+    }
+
+    /* Step 2; If we get here, create a new report for that recipient. */
+    if((msg_tbl = msg_tbl_create(recipient.name)) != NULL)
+    {
+        if(vec_push(&(gAgentDb.tbl_msgs), msg_tbl) != VEC_OK)
+        {
+            msg_tbl_release(msg_tbl, 1);
+            return NULL;
+        }
+    }
+
+    return msg_tbl;
+}
+
+
+OS_time_t rda_earliest_ctrl()
+{
+  OS_time_t earliest = OS_TIME_MAX;
+  vecit_t it;
+
+  vec_lock(&(gVDB.ctrls));
+  for(it = vecit_first(&(gVDB.ctrls)); vecit_valid(it); it = vecit_next(it))
+  {
+    ctrl_t *ctrl = vecit_data(it);
+    if(ctrl == NULL)
+    {
+      continue;
+    }
+    earliest = TimeMin(earliest, ctrl->start);
+  }
+  vec_unlock(&(gVDB.ctrls));
+  return earliest;
+}
+
+
 /******************************************************************************
  *
  * \par Function Name: rda_process_ctrls
@@ -172,32 +301,95 @@ msg_rpt_t *rda_get_msg_rpt(eid_t recipient)
  *  10/21/11  E. Birrane     Initial implementation,
  *  10/04/18  E. Birrane     Update to AMP v0.5 (JHU/APL)
  *****************************************************************************/
-int rda_process_ctrls()
+int rda_process_ctrls(OS_time_t nowtime)
 {
-	vec_idx_t i;
-	ctrl_t *ctrl;
-	time_t curtime = getCtime();
+        vec_idx_t i;
+        ctrl_t *ctrl;
     vecit_t it;
 
-	vec_lock(&(gVDB.ctrls));
+        vec_lock(&(gVDB.ctrls));
     for(i = 0, it = vecit_first(&(gVDB.ctrls)); vecit_valid(it); it = vecit_next(it),i++)
-	{
+        {
         ctrl = vecit_data(it);
 
-		if(ctrl != NULL)
-		{
-			if(curtime > ctrl->start)
-			{
-				lcc_run_ctrl(ctrl, NULL);
-				db_forget(&(ctrl->desc), gDB.ctrls);
-
-				/* Don't access ctrl after this call...*/
-				vec_del(&(gVDB.ctrls), i);
-			}
-		}
-	}
-	vec_unlock(&(gVDB.ctrls));
-	return AMP_OK;
+                if(ctrl != NULL)
+                {
+                        if(TimeCompare(nowtime, ctrl->start) >= 0)
+                        {
+                                lcc_run_ctrl(ctrl, NULL);
+//                                db_forget(&(ctrl->desc), gDB.ctrls);
+
+                                /* Don't access ctrl after this call...*/
+                                vec_del(&(gVDB.ctrls), i);
+                        }
+                }
+        }
+        vec_unlock(&(gVDB.ctrls));
+        return AMP_OK;
+}
+
+
+void* rda_ctrls(void *arg)
+{
+  nmagent_t *agent = arg;
+  bool running = true;
+#ifndef mingw
+    AMP_DEBUG_ENTRY("rda_ctrls","(0x%X)", (unsigned long) pthread_self()); //threadId);
+#endif
+
+    AMP_DEBUG_INFO("rda_ctrls","Running Remote Data Aggregator Thread.", NULL);
+
+    /* While the DTNMP Agent is running...*/
+    while(running)
+    {
+        OS_time_t nowtime;
+
+        if (pthread_mutex_lock(&gVDB.ctrls.lock))
+        {
+          AMP_DEBUG_ERR("rda_ctrls", "failed mutex %d lock", gVDB.ctrls.lock);
+          return NULL;
+        }
+        if (!daemon_run_get(&agent->running))
+        {
+          // exit thread after queued items are handled
+          AMP_DEBUG_INFO("rda_ctrls","Daemon shutdown", NULL);
+          running = false;
+        }
+
+        if (running)
+        {
+          OS_GetLocalTime(&nowtime);
+          OS_time_t next_ctrl = rda_earliest_ctrl();
+          AMP_DEBUG_INFO("rda_ctrls", "next CTRL start at %lld", next_ctrl.ticks);
+          if (TimeCompare(next_ctrl, nowtime) > 0)
+          {
+            int ret;
+            OS_time_t delta;
+            delta = OS_TimeSubtract(next_ctrl, nowtime);
+            AMP_DEBUG_INFO("rda_ctrls", "sleeping up to %lld", delta.ticks);
+
+            const struct timespec abstime = TimeToTimespec(next_ctrl);
+            ret = pthread_cond_timedwait(&gVDB.ctrls.cond_ins_mod, &gVDB.ctrls.lock, &abstime);
+            // return may have been earlier than the timeout
+            OS_GetLocalTime(&nowtime);
+            AMP_DEBUG_INFO("rda_ctrls", "running at %lld from %d (%s)", nowtime.ticks, ret, strerror(ret));
+          }
+        }
+        if (pthread_mutex_unlock(&gVDB.ctrls.lock))
+        {
+          AMP_DEBUG_ERR("rda_ctrls", "failed mutex %p unlock", &gVDB.ctrls.lock);
+          return NULL;
+        }
+
+        /* Run any ctrls that are due and forget them if they are done. */
+        if(rda_process_ctrls(nowtime) != AMP_OK)
+        {
+                AMP_DEBUG_ERR("rda_ctrls","Problem processing ctrls.", NULL);
+        }
+    } // end while
+
+    AMP_DEBUG_ALWAYS("rda_ctrls","Shutting Down Remote Data Aggregator Thread.",NULL);
+    return NULL;
 }
 
 
@@ -224,30 +416,26 @@ int rda_process_ctrls()
 
 void rda_scan_tbrs_cb(rh_elt_t *elt, void *tag)
 {
-	rule_t *rule;
-	vector_t *vec = (vector_t *) tag;
-
-	if((elt == NULL) || (elt->value == NULL) || (tag == NULL))
-	{
-		return;
-	}
-
-	rule = (rule_t*) elt->value;
-
-	if(rule->id.type == AMP_TYPE_SBR)
-	{
-		return;
-	}
-
-	if(rule->ticks_left > 0)
-	{
-		rule->ticks_left--;
-	}
-
-	/* If rule is inactive or still waiting, skip it. */
-	if((rule->ticks_left <= 0) && (RULE_IS_ACTIVE(rule->flags)))
-	{
-		vec_push(vec, rule);
+        rule_t *rule;
+        rda_scan_context_t *ctx = (rda_scan_context_t *) tag;
+
+        if((elt == NULL) || (elt->value == NULL) || (tag == NULL))
+        {
+                return;
+        }
+
+        rule = (rule_t*) elt->value;
+
+        if(rule->id.type == AMP_TYPE_SBR)
+        {
+                return;
+        }
+
+        /* If rule is inactive or still waiting, skip it. */
+        if((RULE_IS_ACTIVE(rule->flags))
+           && (TimeCompare(rule->eval_at, ctx->nowtime) <= 0))
+        {
+                vec_push(ctx->vec, rule);
     }
 }
 
@@ -255,42 +443,67 @@ void rda_scan_tbrs_cb(rh_elt_t *elt, void *tag)
 
 void rda_scan_sbrs_cb(rh_elt_t *elt, void *tag)
 {
-	rule_t *rule;
-	vector_t *vec = (vector_t *) tag;
-
-	if((elt == NULL) || (elt->value == NULL) || (tag == NULL))
-	{
-		return;
-	}
-
-	rule = (rule_t*) elt->value;
-
-	if(rule->id.type == AMP_TYPE_TBR)
-	{
-		return;
-	}
-
-	if(rule->ticks_left > 0)
-	{
-		rule->ticks_left--;
-	}
-
-	/* If rule is inactive or still waiting, skip it. */
-	if((rule->ticks_left <= 0) && (RULE_IS_ACTIVE(rule->flags)))
-	{
-		if(rule->def.as_sbr.max_eval > rule->num_eval)
-		{
-			vec_push(vec, rule);
-		}
-		else
-		{
-			/* Rule is SBR with no evals left. Disable and skip. */
-			RULE_CLEAR_ACTIVE(rule->flags);
-		}
+        rule_t *rule;
+    rda_scan_context_t *ctx = (rda_scan_context_t *) tag;
+
+        if((elt == NULL) || (elt->value == NULL) || (tag == NULL))
+        {
+                return;
+        }
+
+        rule = (rule_t*) elt->value;
+
+        if(rule->id.type == AMP_TYPE_TBR)
+        {
+                return;
+        }
+
+        /* If rule is inactive or still waiting, skip it. */
+        if((RULE_IS_ACTIVE(rule->flags))
+           && (TimeCompare(rule->eval_at, ctx->nowtime) <= 0))
+        {
+                if(rule->def.as_sbr.max_eval > rule->num_eval)
+                {
+                        vec_push(ctx->vec, rule);
+                }
+                else
+                {
+                        /* Rule is SBR with no evals left. Disable and skip. */
+                        RULE_CLEAR_ACTIVE(rule->flags);
+                }
     }
 }
 
 
+void rda_scan_earliest_rule(rh_elt_t *elt, void *tag)
+{
+  rule_t *rule;
+  OS_time_t *earliest = (OS_time_t *) tag;
+
+  if((elt == NULL) || (elt->value == NULL) || (tag == NULL))
+  {
+      return;
+  }
+
+  rule = (rule_t*) elt->value;
+
+  if(!RULE_IS_ACTIVE(rule->flags))
+  {
+      return;
+  }
+
+  *earliest = TimeMin(*earliest, rule->eval_at);
+}
+
+OS_time_t rda_earliest_rule()
+{
+  OS_time_t earliest = OS_TIME_MAX;
+
+  rhht_foreach(&(gVDB.rules), rda_scan_earliest_rule, &earliest);
+
+  return earliest;
+}
+
 
 /******************************************************************************
  *
@@ -311,75 +524,82 @@ void rda_scan_sbrs_cb(rh_elt_t *elt, void *tag)
  *  10/05/18  E. Birrane     Updated to AMP v0.5.
  *****************************************************************************/
 
-int rda_process_rules()
+int rda_process_rules(OS_time_t nowtime)
 {
     vecit_t it;
 
-	lockResource(&(gVDB.rules.lock));
-    vec_lock(&(gAgentDb.rpt_msgs));
+    rda_scan_context_t ctx;
+    ctx.nowtime = nowtime;
+
+    pthread_mutex_lock(&gVDB.rules.lock);
 
-    rhht_foreach(&(gVDB.rules), rda_scan_tbrs_cb, &(gAgentDb.tbrs));
-    rhht_foreach(&(gVDB.rules), rda_scan_sbrs_cb, &(gAgentDb.sbrs));
+    ctx.vec = &(gAgentDb.tbrs);
+    rhht_foreach(&(gVDB.rules), rda_scan_tbrs_cb, &ctx);
 
+    ctx.vec = &(gAgentDb.sbrs);
+    rhht_foreach(&(gVDB.rules), rda_scan_sbrs_cb, &ctx);
+
+    AMP_DEBUG_INFO("rda_process_rules","Checking %d TBRs.", vec_num_entries_ptr(&(gAgentDb.tbrs)));
     for(it = vecit_first(&(gAgentDb.tbrs)); vecit_valid(it); it = vecit_next(it))
     {
-    	rule_t *rule = vecit_data(it);
-
-		gAgentInstr.num_tbrs_run++;
-
-    	lcc_run_ac(&(rule->action), &(rule->id.as_reg.parms));
-
-		rule->num_eval++;
-		rule->num_fire++;
-
-		if(rule->num_fire >= rule->def.as_tbr.max_fire && rule->def.as_tbr.max_fire != 0)
-		{
-			/* Remove the rule. */
-			db_forget(&(rule->desc), gDB.rules);
-			RULE_CLEAR_ACTIVE(rule->flags);
-			VDB_DELKEY_RULE(&(rule->id));
-			gAgentInstr.num_tbrs--;
-		}
-		else
-		{
-			rule->ticks_left = rule->def.as_tbr.period;
-			if(db_persist_rule(rule) != AMP_OK)
-			{
-				AMP_DEBUG_ERR("rda_process_rules", "Unable to persist new TBR state.", NULL);
-			}
-		}
+        rule_t *rule = vecit_data(it);
+
+                gAgentInstr.num_tbrs_run++;
+
+        lcc_run_ac(&(rule->action), &(rule->id.as_reg.parms));
+
+                rule->num_eval++;
+                rule->num_fire++;
+
+                if(rule->num_fire >= rule->def.as_tbr.max_fire && rule->def.as_tbr.max_fire != 0)
+                {
+                        /* Remove the rule. */
+//                        db_forget(&(rule->desc), gDB.rules);
+                        RULE_CLEAR_ACTIVE(rule->flags);
+                        VDB_DELKEY_RULE(&(rule->id));
+                        gAgentInstr.num_tbrs--;
+                }
+                else
+                {
+                        rule->eval_at = OS_TimeAdd(ctx.nowtime, rule->def.as_tbr.period);
+                        if(db_persist_rule(rule) != AMP_OK)
+                        {
+                                AMP_DEBUG_ERR("rda_process_rules", "Unable to persist new TBR state.", NULL);
+                        }
+                }
     }
 
 
+    AMP_DEBUG_INFO("rda_process_rules","Checking %d SBRs.", vec_num_entries_ptr(&(gAgentDb.sbrs)));
     for(it = vecit_first(&(gAgentDb.sbrs)); vecit_valid(it); it = vecit_next(it))
     {
-    	rule_t *rule = (rule_t*) vecit_data(it);
-
-    	rule->num_eval++;
-    	if(sbr_should_fire(rule))
-    	{
-        	gAgentInstr.num_sbrs_run++;
-
-    		lcc_run_ac(&(rule->action), &(rule->id.as_reg.parms));
-
-        	rule->num_fire++;
-    	}
-
-    	if((rule->num_eval >= rule->def.as_sbr.max_eval && rule->def.as_sbr.max_eval != 0) ||
-    	   (rule->num_fire >= rule->def.as_sbr.max_fire && rule->def.as_sbr.max_fire != 0))
-    	{
-    		/* Remove the rule. */
-    		db_forget(&(rule->desc), gDB.rules);
-    		VDB_DELKEY_RULE(&(rule->id));
-    		gAgentInstr.num_sbrs--;
-    	}
+        rule_t *rule = (rule_t*) vecit_data(it);
+
+        rule->num_eval++;
+        rule->eval_at = OS_TimeAdd(rule->eval_at, OS_TimeAssembleFromMilliseconds(1, 0)); // check again in 1s
+        if(sbr_should_fire(rule))
+        {
+                gAgentInstr.num_sbrs_run++;
+
+                lcc_run_ac(&(rule->action), &(rule->id.as_reg.parms));
+
+                rule->num_fire++;
+        }
+
+        if((rule->num_eval >= rule->def.as_sbr.max_eval && rule->def.as_sbr.max_eval != 0) ||
+           (rule->num_fire >= rule->def.as_sbr.max_fire && rule->def.as_sbr.max_fire != 0))
+        {
+                /* Remove the rule. */
+//                db_forget(&(rule->desc), gDB.rules);
+                VDB_DELKEY_RULE(&(rule->id));
+                gAgentInstr.num_sbrs--;
+        }
     }
 
     vec_clear(&(gAgentDb.sbrs));
     vec_clear(&(gAgentDb.tbrs));
 
-    vec_unlock(&(gAgentDb.rpt_msgs));
-	unlockResource(&(gVDB.rules.lock));
+    pthread_mutex_unlock(&gVDB.rules.lock);
 
     AMP_DEBUG_EXIT("rda_eval_pending_rules","-> 0", NULL);
     return AMP_OK;
@@ -398,10 +618,10 @@ int rda_process_rules()
  *               -1 : Failure
  *
  * \par Notes:
- *		- When we construct the reports, we build one compound report
- *		  per recipient. By the time we get to this function, we should have
- *		  one report per recipient, so making one message per report should
- *		  not result in multiple messages to the same recipient.
+ *              - When we construct the reports, we build one compound report
+ *                per recipient. By the time we get to this function, we should have
+ *                one report per recipient, so making one message per report should
+ *                not result in multiple messages to the same recipient.
  *
  *
  * Modification History:
@@ -412,11 +632,14 @@ int rda_process_rules()
  *  10/05/18  E. Birrane     Update to latest AMP v0.5. (JHU/APL)
  *****************************************************************************/
 
-int rda_send_reports()
+int rda_send_reports(nmagent_t *agent)
 {
     vecit_t it1;
     vecit_t it2;
-    
+    OS_time_t nowtime;
+    OS_GetLocalTime(&nowtime);
+    unsigned long num_rpts = 0;
+
     AMP_DEBUG_ENTRY("rda_send_reports","()", NULL);
 
 
@@ -424,47 +647,105 @@ int rda_send_reports()
 
     for(it1 = vecit_first(&(gAgentDb.rpt_msgs)); vecit_valid(it1); it1 = vecit_next(it1))
     {
-    	msg_rpt_t *msg_rpt = (msg_rpt_t*)vecit_data(it1);
-
-    	if(msg_rpt == NULL)
-    	{
-    		continue;
-    	}
-
-    	for(it2 = vecit_first(&(msg_rpt->rx)); vecit_valid(it2); it2 = vecit_next(it2))
-    	{
-    		char *rx = vecit_data(it2);
-
-    		if(rx == NULL)
-    		{
-    			AMP_DEBUG_ERR("rda_send_reports", "NULL rx", NULL);
-    			continue;
-    		}
-    		if(iif_send_msg(&ion_ptr, MSG_TYPE_RPT_SET, msg_rpt, rx) == AMP_OK)
-    		{
-    			gAgentInstr.num_sent_rpts += vec_num_entries(msg_rpt->rpts);
-    		}
-    		else
-    		{
-    			AMP_DEBUG_ERR("rda_send_reports", "Error sending reports to %s", rx);
-    		}
-    	}
+        msg_rpt_t *msg_rpt = (msg_rpt_t*)vecit_data(it1);
+
+        if(msg_rpt == NULL)
+        {
+                continue;
+        }
+        if (vec_num_entries(msg_rpt->rpts) < 1)
+        {
+            AMP_DEBUG_WARN("rda_send_reports", "Vector has no reports");
+            continue;
+        }
+
+        for(it2 = vecit_first(&(msg_rpt->rx)); vecit_valid(it2); it2 = vecit_next(it2))
+        {
+                char *rx = vecit_data(it2);
+
+                if(rx == NULL)
+                {
+                        AMP_DEBUG_ERR("rda_send_reports", "NULL rx", NULL);
+                        continue;
+                }
+                eid_t destination;
+                strncpy(destination.name, rx, AMP_MAX_EID_LEN);
+                if(mif_send_msg(&agent->mif, MSG_TYPE_RPT_SET, msg_rpt, &destination, amp_tv_from_ctime(nowtime, NULL)) == AMP_OK)
+                {
+                        num_rpts += vec_num_entries(msg_rpt->rpts);
+                }
+                else
+                {
+                        AMP_DEBUG_ERR("rda_send_reports", "Error sending reports to %s", rx);
+                }
+        }
+        /* FIXME: cleanup belongs in the vector state
+        msg_rpt_release(msg_rpt, 1);
+        */
     }
+    AMP_DEBUG_INFO("rda_send_reports","Sent %u reports", num_rpts);
+    gAgentInstr.num_sent_rpts += num_rpts;
 
     /* Sent successfully or not, clear the reports. */
     vec_clear(&(gAgentDb.rpt_msgs));
 
     vec_unlock(&(gAgentDb.rpt_msgs));
 
+    AMP_DEBUG_EXIT("rda_send_reports","()", NULL);
     return AMP_OK;
 }
 
 
+void* rda_reports(void *arg)
+{
+    nmagent_t *agent = arg;
+    bool running = true;
+#ifndef mingw
+    AMP_DEBUG_ENTRY("rda_reports","(0x%"PRIxPTR")", pthread_self());
+#endif
+
+    AMP_DEBUG_INFO("rda_reports","Running Remote Data Aggregator Thread.", NULL);
+
+    /* While the DTNMP Agent is running...*/
+    while(running)
+    {
+      if (pthread_mutex_lock(&gAgentDb.rpt_msgs.lock))
+      {
+        AMP_DEBUG_ERR("rda_reports", "failed mutex %p lock", &gAgentDb.rpt_msgs.lock);
+        return NULL;
+      }
+      if (!daemon_run_get(&agent->running))
+      {
+        // exit thread after queued items are handled
+        AMP_DEBUG_INFO("rda_reports","Daemon shutdown", NULL);
+        running = false;
+      }
+      if (running && (vec_num_entries_ptr(&gAgentDb.rpt_msgs) == 0))
+      {
+        AMP_DEBUG_INFO("rda_reports","Waiting for reports", NULL);
+        pthread_cond_wait(&gAgentDb.rpt_msgs.cond_ins_mod, &(gAgentDb.rpt_msgs.lock));
+      }
+      if (pthread_mutex_unlock(&(gAgentDb.rpt_msgs.lock)))
+      {
+        AMP_DEBUG_ERR("rda_reports", "failed mutex %p unlock", &(gAgentDb.rpt_msgs.lock));
+        return NULL;
+      }
+
+      AMP_DEBUG_INFO("rda_reports", "processing reports...", NULL);
+      if(rda_send_reports(agent) != AMP_OK)
+      {
+        AMP_DEBUG_ERR("rda_reports","Problem processing reports.", NULL);
+      }
+    } // end while
+
+    AMP_DEBUG_ALWAYS("rda_reports","Shutting Down Remote Data Aggregator Thread.",NULL);
+    return NULL;
+}
 
 
 /******************************************************************************
  *
- * \par Function Name: rda_thread
+ * \par Function Name: rda_rules
  *
  * \par Purpose: "Main" function for the remote data aggregator.  This thread
  *               performs the following functions:
@@ -486,57 +767,60 @@ int rda_send_reports()
  *  10/21/11  E. Birrane     Code comments and functional updates.
  *****************************************************************************/
 
-void* rda_thread(int* running)
+void* rda_rules(void *arg)
 {
-    struct timeval start_time;
-    vast delta = 0;
+  nmagent_t *agent = arg;
 #ifndef mingw
-    AMP_DEBUG_ENTRY("rda_thread","(0x%X)", (unsigned long) pthread_self()); //threadId);
+    AMP_DEBUG_ENTRY("rda_rules","(0x%X)", (unsigned long) pthread_self()); //threadId);
 #endif
 
-
-    AMP_DEBUG_INFO("rda_thread","Running Remote Data Aggregator Thread.", NULL);
-
-    rda_init();
+    AMP_DEBUG_INFO("rda_rules","Running Remote Data Aggregator Thread.", NULL);
 
     /* While the DTNMP Agent is running...*/
-    while(*running)
+    while(true)
     {
-    	getCurrentTime(&start_time);
-
-
-    	/* Run, then forget, any controls that are due to execute. */
-    	if(rda_process_ctrls() != AMP_OK)
-    	{
-            AMP_DEBUG_ERR("rda_thread","Problem processing controls.", NULL);
-    	}
-
-    	/* Run any rules that are due and forget them if they are done. */
-    	else if(rda_process_rules() != AMP_OK)
-    	{
-    		AMP_DEBUG_ERR("rda_thread","Problem processing rules.", NULL);
-    	}
+        OS_time_t nowtime;
 
-    	else if(rda_send_reports() != AMP_OK)
-    	{
-    		AMP_DEBUG_ERR("rda_thread","Problem sending reports.", NULL);
-    	}
+        if (pthread_mutex_lock(&(gVDB.rules.lock)))
+        {
+          AMP_DEBUG_ERR("rda_rules", "failed mutex %p lock", &(gVDB.rules.lock));
+          return NULL;
+        }
+        if (!daemon_run_get(&agent->running))
+        {
+          pthread_mutex_unlock(&(gVDB.rules.lock));
+          break;
+        }
 
-        delta = utils_time_cur_delta(&start_time);
+        OS_GetLocalTime(&nowtime);
+        OS_time_t next_rule = rda_earliest_rule();
+        AMP_DEBUG_INFO("rda_rules", "next TBR at %lld from now %lld", next_rule.ticks, nowtime.ticks);
+        if (TimeCompare(next_rule, nowtime) > 0)
+        {
+          int ret;
+          OS_time_t delta;
+          delta = OS_TimeSubtract(next_rule, nowtime);
+          AMP_DEBUG_INFO("rda_rules", "sleeping up to %lld", delta.ticks);
+
+          const struct timespec abstime = TimeToTimespec(next_rule);
+          ret = pthread_cond_timedwait(&gVDB.rules.cond_ins_mod, &gVDB.rules.lock, &abstime);
+          // return may have been earlier than the timeout
+          OS_GetLocalTime(&nowtime);
+          AMP_DEBUG_INFO("rda_rules", "running at %lld from %d (%s)", nowtime.ticks, ret, strerror(ret));
+        }
+        if (pthread_mutex_unlock(&(gVDB.rules.lock)))
+        {
+          AMP_DEBUG_ERR("rda_rules", "failed mutex %p unlock", &(gVDB.rules.lock));
+          return NULL;
+        }
 
-        // Sleep for 1 second (10^6 microsec) subtracting the processing time.
-        if((delta < 1000000) && (delta > 0))
+        /* Run any rules that are due and forget them if they are done. */
+        if(rda_process_rules(nowtime) != AMP_OK)
         {
-        	microsnooze((unsigned int)(1000000 - delta));
+                AMP_DEBUG_ERR("rda_rules","Problem processing rules.", NULL);
         }
-        
     } // end while
-    
-    rda_cleanup();
-
-    AMP_DEBUG_ALWAYS("rda_thread","Shutting Down Agent Data Aggregator Thread.",NULL);
-
 
-    pthread_exit(NULL);
-    return NULL; /* Defensive */
+    AMP_DEBUG_ALWAYS("rda_rules","Shutting Down Remote Data Aggregator Thread.",NULL);
+    return NULL;
 }
diff --git a/nm/agent/rda.h b/nm/agent/rda.h
index 772f966f..3015e34a 100644
--- a/nm/agent/rda.h
+++ b/nm/agent/rda.h
@@ -1,9 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- **
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: rda.h
@@ -20,6 +31,7 @@
  **  --------  ------------   ---------------------------------------------
  **  01/10/13  E. Birrane     Initial Implementation (JHU/APL)
  **  10/04/18  E. Birrane     Update to AMP v0.5 (JHU/APL)
+ **  11/23/21  E. Birrane     Added table sets (JHU/APL)
  *****************************************************************************/
 
 #ifndef RDA_H_
@@ -28,9 +40,16 @@
 #include "../shared/primitives/rules.h"
 #include "../shared/primitives/report.h"
 #include "../shared/msg/msg.h"
+#include "nmagent.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 
 #define RDA_DEF_NUM_RPTS 8
+#define RDA_DEF_NUM_TBLS 8
 #define RDA_DEF_NUM_TBRS 8
 #define RDA_DEF_NUM_SBRS 8
 
@@ -41,6 +60,7 @@
 typedef struct
 {
 	vector_t rpt_msgs; /* of type (msg_rpt_t *)  */
+	vector_t tbl_msgs; /* of type (msg_tbl_t *)  */
 	vector_t tbrs;    /* of type (rule_t *) */
 	vector_t sbrs;    /* of type (rule_t *) */
 } agent_db_t;
@@ -49,19 +69,30 @@ extern agent_db_t gAgentDb;
 
 int rda_init();
 
+void rda_signal_shutdown();
 void         rda_cleanup();
+
 msg_rpt_t*   rda_get_msg_rpt(eid_t recipient);
+msg_tbl_t*   rda_get_msg_tbl(eid_t recipient);
 
-int          rda_process_ctrls();
+OS_time_t rda_earliest_ctrl();
+int rda_process_ctrls(OS_time_t nowtime);
+void * rda_ctrls(void *arg);
 
 void rda_scan_tbrs_cb(rh_elt_t *elt, void *tag);
 void rda_scan_sbrs_cb(rh_elt_t *elt, void *tag);
 
-int          rda_process_rules();
+OS_time_t rda_earliest_rule();
+int rda_process_rules (OS_time_t nowtime);
+void * rda_rules(void *arg);
 
 
-int          rda_send_reports();
+int          rda_send_reports(nmagent_t *agent);
+int          rda_send_tables(nmagent_t *agent);
+void * rda_reports(void *arg);
 
-void*        rda_thread(int* running);
+#ifdef __cplusplus
+}
+#endif
 
 #endif /* RDA_H_ */
diff --git a/nm/mgr/Makefile b/nm/mgr/Makefile
deleted file mode 100644
index 17608e43..00000000
--- a/nm/mgr/Makefile
+++ /dev/null
@@ -1,47 +0,0 @@
-SOURCES = ../shared/adm/*.c ../shared/msg/*.c ../shared/utils/*.c ../shared/primitives/*.c ./*.c 
-IONDIR = ../../
-OPTS = -Wno-write-strings -g 
-
-all:with-db
-
-without-db:
-	gcc ${OPTS} \
-	-I. -I.. \
-	-I${IONDIR}/ici/include \
-	-I${IONDIR}/ltp/include \
-	-I${IONDIR}/ltp/library \
-	-I${IONDIR}/bp/include \
-	-I${IONDIR}/bp/library \
-	-I${IONDIR}/ici/library \
-	-I/usr/local/include \
-	-L${IONDIR}/ \
-	-L/usr/local/lib \
-	-lbp -lici -lltp \
-	-DMAXPATHLEN=2048 \
-	-c ${SOURCES} 
-
-	gcc -o nm_mgr *.o -lltp -lbp -lici -lpthread
-
-with-db:
-	gcc ${OPTS} \
-	-I. -I.. \
-	-I${IONDIR}/ici/include \
-	-I${IONDIR}/ltp/include \
-	-I${IONDIR}/ltp/library \
-	-I${IONDIR}/bp/include \
-	-I${IONDIR}/bp/library \
-	-I${IONDIR}/ici/library \
-	-I/usr/local/include \
-	-I/usr/include/mysql \
-	-L${IONDIR}/ \
-	-L/usr/local/lib \
-	-L/usr/lib \
-	-lbp -lici -lltp -lmysqlclient \
-	-DMAXPATHLEN=2048 \
-	-DHAVE_MYSQL=1 \
-	-c ${SOURCES} 
-
-	gcc -o nm_mgr *.o -lltp -lbp -lici -lmysqlclient -lpthread
-
-
-
diff --git a/nm/mgr/adm_amp_agent_mgr.c b/nm/mgr/adm_amp_agent_mgr.c
deleted file mode 100644
index 6294e858..00000000
--- a/nm/mgr/adm_amp_agent_mgr.c
+++ /dev/null
@@ -1,789 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_amp_agent_mgr.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-16  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_amp_agent.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "metadata.h"
-#include "nm_mgr_ui.h"
-
-
-
-
-#define _HAVE_AMP_AGENT_ADM_
-#ifdef _HAVE_AMP_AGENT_ADM_
-//vec_idx_t g_amp_agent_idx[11];
-
-void amp_agent_init()
-{
-	adm_add_adm_info("amp_agent", ADM_ENUM_AMP_AGENT);
-
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_OPER_IDX), &(g_amp_agent_idx[ADM_OPER_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_RPTT_IDX), &(g_amp_agent_idx[ADM_RPTT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_CONST_IDX), &(g_amp_agent_idx[ADM_CONST_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_EDD_IDX), &(g_amp_agent_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_CTRL_IDX), &(g_amp_agent_idx[ADM_CTRL_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_META_IDX), &(g_amp_agent_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_TBLT_IDX), &(g_amp_agent_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_AMP_AGENT * 20) + ADM_VAR_IDX), &(g_amp_agent_idx[ADM_VAR_IDX]));
-
-
-	amp_agent_init_meta();
-	amp_agent_init_cnst();
-	amp_agent_init_edd();
-	amp_agent_init_op();
-	amp_agent_init_var();
-	amp_agent_init_ctrl();
-	amp_agent_init_mac();
-	amp_agent_init_rpttpl();
-	amp_agent_init_tblt();
-}
-
-void amp_agent_init_meta()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_NAME);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_AMP_AGENT, "name", "The human-readable name of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_NAMESPACE);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_AMP_AGENT, "namespace", "The namespace of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_VERSION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_AMP_AGENT, "version", "The version of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_ORGANIZATION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_AMP_AGENT, "organization", "The name of the issuing organization of the ADM.");
-
-}
-
-void amp_agent_init_cnst()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_CONST_IDX], AMP_AGENT_CNST_AMP_EPOCH);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_TS, id, ADM_ENUM_AMP_AGENT, "amp_epoch", "This constant is the time epoch for the Agent.");
-
-}
-
-void amp_agent_init_edd()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_RPT_TPLS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "num_rpt_tpls", "This is the number of report templates known to the Agent.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBL_TPLS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "num_tbl_tpls", "This is the number of table templates known to the Agent.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_SENT_REPORTS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "sent_reports", "This is the number of reports sent by the agent.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBR);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "num_tbr", "This is the number of time-based rules running on the agent.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_TBR);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "run_tbr", "This is the number of time-based rules run by the agent since the last reset.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_SBR);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "num_sbr", "This is the number of state-based rules running on the agent.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_SBR);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "run_sbr", "This is the number of state-based rules run by the agent since the last reset.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_CONST);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "num_const", "This is the number of constants known by the agent.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_VAR);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "num_var", "This is the number of variables known by the agent.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_MACROS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "num_macros", "This is the number of macros known by the agent.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_MACROS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "run_macros", "This is the number of macros run by the agent since the last reset.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_CONTROLS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "num_controls", "This is the number of controls known by the agent.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_CONTROLS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "run_controls", "This is the number of controls run by the agent since the last reset.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_CUR_TIME);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_TV, id, ADM_ENUM_AMP_AGENT, "cur_time", "This is the current system time.");
-
-}
-
-void amp_agent_init_op()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_INT, id, ADM_ENUM_AMP_AGENT, "plusINT", "Int32 addition");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_INT);
-	meta_add_parm(meta, "O2", AMP_TYPE_INT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "plusUINT", "Unsigned Int32 addition");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UINT);
-	meta_add_parm(meta, "O2", AMP_TYPE_UINT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_VAST, id, ADM_ENUM_AMP_AGENT, "plusVAST", "Int64 addition");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_VAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_VAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "plusUVAST", "Unsigned Int64 addition");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSREAL32);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL32, id, ADM_ENUM_AMP_AGENT, "plusREAL32", "Real32 addition");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL32);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL32);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSREAL64);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL64, id, ADM_ENUM_AMP_AGENT, "plusREAL64", "Real64 addition");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL64);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL64);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_INT, id, ADM_ENUM_AMP_AGENT, "minusINT", "Int32 subtraction");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_INT);
-	meta_add_parm(meta, "O2", AMP_TYPE_INT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSUINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "minusUINT", "Unsigned Int32 subtraction");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UINT);
-	meta_add_parm(meta, "O2", AMP_TYPE_UINT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_VAST, id, ADM_ENUM_AMP_AGENT, "minusVAST", "Int64 subtraction");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_VAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_VAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSUVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "minusUVAST", "Unsigned Int64 subtraction");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSREAL32);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL32, id, ADM_ENUM_AMP_AGENT, "minusREAL32", "Real32 subtraction");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL32);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL32);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MINUSREAL64);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL64, id, ADM_ENUM_AMP_AGENT, "minusREAL64", "Real64 subtraction");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL64);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL64);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_INT, id, ADM_ENUM_AMP_AGENT, "multINT", "Int32 multiplication");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_INT);
-	meta_add_parm(meta, "O2", AMP_TYPE_INT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTUINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "multUINT", "Unsigned Int32 multiplication");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UINT);
-	meta_add_parm(meta, "O2", AMP_TYPE_UINT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_VAST, id, ADM_ENUM_AMP_AGENT, "multVAST", "Int64 multiplication");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_VAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_VAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTUVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "multUVAST", "Unsigned Int64 multiplication");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTREAL32);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL32, id, ADM_ENUM_AMP_AGENT, "multREAL32", "Real32 multiplication");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL32);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL32);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MULTREAL64);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL64, id, ADM_ENUM_AMP_AGENT, "multREAL64", "Real64 multiplication");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL64);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL64);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_INT, id, ADM_ENUM_AMP_AGENT, "divINT", "Int32 division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_INT);
-	meta_add_parm(meta, "O2", AMP_TYPE_INT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVUINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "divUINT", "Unsigned Int32 division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UINT);
-	meta_add_parm(meta, "O2", AMP_TYPE_UINT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_VAST, id, ADM_ENUM_AMP_AGENT, "divVAST", "Int64 division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_VAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_VAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVUVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "divUVAST", "Unsigned Int64 division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVREAL32);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL32, id, ADM_ENUM_AMP_AGENT, "divREAL32", "Real32 division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL32);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL32);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_DIVREAL64);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL64, id, ADM_ENUM_AMP_AGENT, "divREAL64", "Real64 division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL64);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL64);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_INT, id, ADM_ENUM_AMP_AGENT, "modINT", "Int32 modulus division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_INT);
-	meta_add_parm(meta, "O2", AMP_TYPE_INT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODUINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "modUINT", "Unsigned Int32 modulus division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UINT);
-	meta_add_parm(meta, "O2", AMP_TYPE_UINT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_VAST, id, ADM_ENUM_AMP_AGENT, "modVAST", "Int64 modulus division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_VAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_VAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODUVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "modUVAST", "Unsigned Int64 modulus division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODREAL32);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL32, id, ADM_ENUM_AMP_AGENT, "modREAL32", "Real32 modulus division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL32);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL32);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_MODREAL64);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL64, id, ADM_ENUM_AMP_AGENT, "modREAL64", "Real64 modulus division");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL64);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL64);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_INT, id, ADM_ENUM_AMP_AGENT, "expINT", "Int32 exponentiation");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_INT);
-	meta_add_parm(meta, "O2", AMP_TYPE_INT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPUINT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "expUINT", "Unsigned int32 exponentiation");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UINT);
-	meta_add_parm(meta, "O2", AMP_TYPE_UINT);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_VAST, id, ADM_ENUM_AMP_AGENT, "expVAST", "Int64 exponentiation");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_VAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_VAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPUVAST);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "expUVAST", "Unsigned Int64 exponentiation");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPREAL32);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL32, id, ADM_ENUM_AMP_AGENT, "expREAL32", "Real32 exponentiation");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL32);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL32);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EXPREAL64);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_REAL64, id, ADM_ENUM_AMP_AGENT, "expREAL64", "Real64 exponentiation");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_REAL64);
-	meta_add_parm(meta, "O2", AMP_TYPE_REAL64);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITAND);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "bitAND", "Bitwise and");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITOR);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "bitOR", "Bitwise or");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITXOR);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "bitXOR", "Bitwise xor");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITNOT);
-	adm_add_op_ari(id, 1, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "bitNOT", "Bitwise not");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LOGAND);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_BOOL, id, ADM_ENUM_AMP_AGENT, "logAND", "Logical and");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_BOOL);
-	meta_add_parm(meta, "O2", AMP_TYPE_BOOL);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LOGOR);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_BOOL, id, ADM_ENUM_AMP_AGENT, "logOR", "Logical or");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_BOOL);
-	meta_add_parm(meta, "O2", AMP_TYPE_BOOL);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LOGNOT);
-	adm_add_op_ari(id, 1, NULL);
-	meta = meta_add_op(AMP_TYPE_BOOL, id, ADM_ENUM_AMP_AGENT, "logNOT", "Logical not");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_BOOL);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_ABS);
-	adm_add_op_ari(id, 1, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "abs", "absolute value");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_VAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LESSTHAN);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_BOOL, id, ADM_ENUM_AMP_AGENT, "lessThan", "<");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UNK);
-	meta_add_parm(meta, "O2", AMP_TYPE_UNK);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_GREATERTHAN);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_BOOL, id, ADM_ENUM_AMP_AGENT, "greaterThan", ">");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UNK);
-	meta_add_parm(meta, "O2", AMP_TYPE_UNK);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_LESSEQUAL);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_BOOL, id, ADM_ENUM_AMP_AGENT, "lessEqual", "<=");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UNK);
-	meta_add_parm(meta, "O2", AMP_TYPE_UNK);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_GREATEREQUAL);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_BOOL, id, ADM_ENUM_AMP_AGENT, "greaterEqual", ">=");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UNK);
-	meta_add_parm(meta, "O2", AMP_TYPE_UNK);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_NOTEQUAL);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_BOOL, id, ADM_ENUM_AMP_AGENT, "notEqual", "!=");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UNK);
-	meta_add_parm(meta, "O2", AMP_TYPE_UNK);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_EQUAL);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_BOOL, id, ADM_ENUM_AMP_AGENT, "Equal", "==");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UNK);
-	meta_add_parm(meta, "O2", AMP_TYPE_UNK);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITSHIFTLEFT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "bitShiftLeft", "<<");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_BITSHIFTRIGHT);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UVAST, id, ADM_ENUM_AMP_AGENT, "bitShiftRight", ">>");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "O2", AMP_TYPE_UVAST);
-
-	id = adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_STOR);
-	adm_add_op_ari(id, 2, NULL);
-	meta = meta_add_op(AMP_TYPE_UNK, id, ADM_ENUM_AMP_AGENT, "STOR", "Store value of parm 2 in parm 1");
-
-	meta_add_parm(meta, "O1", AMP_TYPE_UNK);
-	meta_add_parm(meta, "O2", AMP_TYPE_UNK);
-}
-
-void amp_agent_init_var()
-{
-
-	ari_t *id = NULL;
-
-	expr_t *expr = NULL;
-
-
-	/* NUM_RULES */
-
-	id = adm_build_ari(AMP_TYPE_VAR, 0, g_amp_agent_idx[ADM_VAR_IDX], AMP_AGENT_VAR_NUM_RULES);
-	expr = expr_create(AMP_TYPE_UINT);
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBR));
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_SBR));
-	expr_add_item(expr, adm_build_ari(AMP_TYPE_OPER, 1, g_amp_agent_idx[ADM_OPER_IDX], AMP_AGENT_OP_PLUSUINT));
-	adm_add_var_from_expr(id, AMP_TYPE_UINT, expr);
-	meta_add_var(AMP_TYPE_UINT, id, ADM_ENUM_AMP_AGENT, "num_rules", "This is the number of rules known to the Agent (#TBR + #SBR).");
-
-}
-
-void amp_agent_init_ctrl()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-
-	/* ADD_VAR */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_VAR);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "add_var", "This control configures a new variable definition on the Agent.");
-
-	meta_add_parm(meta, "id", AMP_TYPE_ARI);
-	meta_add_parm(meta, "def", AMP_TYPE_EXPR);
-	meta_add_parm(meta, "type", AMP_TYPE_BYTE);
-
-	/* DEL_VAR */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DEL_VAR);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "del_var", "This control removes one or more variable definitions from the Agent.");
-
-	meta_add_parm(meta, "ids", AMP_TYPE_AC);
-
-	/* ADD_RPTT */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_RPTT);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "add_rptt", "This control configures a new report template definition on the Agent.");
-
-	meta_add_parm(meta, "id", AMP_TYPE_ARI);
-	meta_add_parm(meta, "template", AMP_TYPE_AC);
-
-	/* DEL_RPTT */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DEL_RPTT);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "del_rptt", "This control removes one or more report template definitions from the Agent.");
-
-	meta_add_parm(meta, "ids", AMP_TYPE_AC);
-
-	/* DESC_RPTT */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DESC_RPTT);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "desc_rptt", "This control produces a detailed description of one or more report template  identifier(ARI) known to the Agent.");
-
-	meta_add_parm(meta, "ids", AMP_TYPE_AC);
-
-	/* GEN_RPTS */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_GEN_RPTS);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "gen_rpts", "This control causes the Agent to produce a report entry for each identified report templates and send them to one or more identified managers(ARIs).");
-
-	meta_add_parm(meta, "ids", AMP_TYPE_AC);
-	meta_add_parm(meta, "rxmgrs", AMP_TYPE_TNVC);
-
-	/* GEN_TBLS */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_GEN_TBLS);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "gen_tbls", "This control causes the Agent to produce a table for each identified table templates and send them to one or more identified managers(ARIs).");
-
-	meta_add_parm(meta, "ids", AMP_TYPE_AC);
-	meta_add_parm(meta, "rxmgrs", AMP_TYPE_TNVC);
-
-	/* ADD_MACRO */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_MACRO);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "add_macro", "This control configures a new macro definition on the Agent.");
-
-	meta_add_parm(meta, "name", AMP_TYPE_STR);
-	meta_add_parm(meta, "id", AMP_TYPE_ARI);
-	meta_add_parm(meta, "def", AMP_TYPE_AC);
-
-	/* DEL_MACRO */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DEL_MACRO);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "del_macro", "This control removes one or more macro definitions from the Agent.");
-
-	meta_add_parm(meta, "ids", AMP_TYPE_AC);
-
-	/* DESC_MACRO */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DESC_MACRO);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "desc_macro", "This control produces a detailed description of one or more macro identifier(ARI) known to the Agent.");
-
-	meta_add_parm(meta, "ids", AMP_TYPE_AC);
-
-	/* ADD_TBR */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_TBR);
-	adm_add_ctrldef_ari(id, 6, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "add_tbr", "This control configures a new time-based rule(TBR) definition on the Agent.");
-
-	meta_add_parm(meta, "id", AMP_TYPE_ARI);
-	meta_add_parm(meta, "start", AMP_TYPE_TV);
-	meta_add_parm(meta, "period", AMP_TYPE_TV);
-	meta_add_parm(meta, "count", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "action", AMP_TYPE_AC);
-	meta_add_parm(meta, "description", AMP_TYPE_STR);
-
-	/* ADD_SBR */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_ADD_SBR);
-	adm_add_ctrldef_ari(id, 7, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "add_sbr", "This control configures a new state-based rule(SBR) definition on the Agent.");
-
-	meta_add_parm(meta, "id", AMP_TYPE_ARI);
-	meta_add_parm(meta, "start", AMP_TYPE_TV);
-	meta_add_parm(meta, "state", AMP_TYPE_EXPR);
-	meta_add_parm(meta, "max_eval", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "count", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "action", AMP_TYPE_AC);
-	meta_add_parm(meta, "description", AMP_TYPE_STR);
-
-	/* DEL_RULE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DEL_RULE);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "del_rule", "This control removes one or more rule definitions from the Agent.");
-
-	meta_add_parm(meta, "ids", AMP_TYPE_AC);
-
-	/* DESC_RULE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_DESC_RULE);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "desc_rule", "This control produces a detailed description of one or more rules known to the Agent.");
-
-	meta_add_parm(meta, "ids", AMP_TYPE_AC);
-
-	/* STORE_VAR */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_STORE_VAR);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "store_var", "This control stores variables.");
-
-	meta_add_parm(meta, "id", AMP_TYPE_ARI);
-	meta_add_parm(meta, "value", AMP_TYPE_EXPR);
-
-	/* RESET_COUNTS */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 0, g_amp_agent_idx[ADM_CTRL_IDX], AMP_AGENT_CTRL_RESET_COUNTS);
-	adm_add_ctrldef_ari(id, 0, NULL);
-	meta_add_ctrl(id, ADM_ENUM_AMP_AGENT, "reset_counts", "This control resets all Agent ADM statistics reported in the Agent ADM report.");
-
-}
-
-void amp_agent_init_mac()
-{
-
-}
-
-void amp_agent_init_rpttpl()
-{
-
-	rpttpl_t *def = NULL;
-
-	/* FULL_REPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 0, g_amp_agent_idx[ADM_RPTT_IDX], AMP_AGENT_RPTTPL_FULL_REPORT));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_NAME));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_CNST, 0, g_amp_agent_idx[ADM_META_IDX], AMP_AGENT_META_VERSION));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_RPT_TPLS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBL_TPLS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_SENT_REPORTS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_TBR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_TBR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_SBR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_SBR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_CONST));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_VAR));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_MACROS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_MACROS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_NUM_CONTROLS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_EDD, 0, g_amp_agent_idx[ADM_EDD_IDX], AMP_AGENT_EDD_RUN_CONTROLS));
-	rpttpl_add_item(def, adm_build_ari(AMP_TYPE_VAR, 0, g_amp_agent_idx[ADM_VAR_IDX], AMP_AGENT_VAR_NUM_RULES));
-	adm_add_rpttpl(def);
-	meta_add_rpttpl(def->id, ADM_ENUM_AMP_AGENT, "full_report", "This is all known meta-data, EDD, and VAR values known by the agent.");
-}
-
-void amp_agent_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* ADMS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_ADMS), NULL);
-	tblt_add_col(def, AMP_TYPE_STR, "adm_name");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_AMP_AGENT, "adms", "This table lists all the adms that are supported by the agent.");
-
-	/* VARIABLES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_VARIABLES), NULL);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_AMP_AGENT, "variables", "This table lists the ARI for every variable that is known to the agent.");
-
-	/* RPTTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_RPTTS), NULL);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_AMP_AGENT, "rptts", "This table lists the ARI for every report template that is known to the agent.");
-
-	/* MACROS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_MACROS), NULL);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_AMP_AGENT, "macros", "This table lists the ARI for every macro that is known to the agent.");
-
-	/* RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_RULES), NULL);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_AMP_AGENT, "rules", "This table lists the ARI for every rule that is known to the agent.");
-
-	/* TBLTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_amp_agent_idx[ADM_TBLT_IDX], AMP_AGENT_TBLT_TBLTS), NULL);
-	tblt_add_col(def, AMP_TYPE_ARI, "ids");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_AMP_AGENT, "tblts", "This table lists the ARI for every table template that is known to the agent.");
-}
-
-#endif // _HAVE_AMP_AGENT_ADM_
diff --git a/nm/mgr/adm_ion_admin_mgr.c b/nm/mgr/adm_ion_admin_mgr.c
deleted file mode 100644
index 67a12f8c..00000000
--- a/nm/mgr/adm_ion_admin_mgr.c
+++ /dev/null
@@ -1,341 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_admin_mgr.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ion_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "metadata.h"
-#include "nm_mgr_ui.h"
-
-
-
-
-#define _HAVE_DTN_ION_IONADMIN_ADM_
-#ifdef _HAVE_DTN_ION_IONADMIN_ADM_
-static vec_idx_t g_dtn_ion_ionadmin_idx[11];
-
-void dtn_ion_ionadmin_init()
-{
-	adm_add_adm_info("dtn_ion_ionadmin", ADM_ENUM_DTN_ION_IONADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_ionadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_ionadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_ionadmin_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_ionadmin_init_meta();
-	dtn_ion_ionadmin_init_cnst();
-	dtn_ion_ionadmin_init_edd();
-	dtn_ion_ionadmin_init_op();
-	dtn_ion_ionadmin_init_var();
-	dtn_ion_ionadmin_init_ctrl();
-	dtn_ion_ionadmin_init_mac();
-	dtn_ion_ionadmin_init_rpttpl();
-	dtn_ion_ionadmin_init_tblt();
-}
-
-void dtn_ion_ionadmin_init_meta()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionadmin_idx[ADM_META_IDX], DTN_ION_IONADMIN_META_NAME);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IONADMIN, "name", "The human-readable name of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionadmin_idx[ADM_META_IDX], DTN_ION_IONADMIN_META_NAMESPACE);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IONADMIN, "namespace", "The namespace of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionadmin_idx[ADM_META_IDX], DTN_ION_IONADMIN_META_VERSION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IONADMIN, "version", "The version of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionadmin_idx[ADM_META_IDX], DTN_ION_IONADMIN_META_ORGANIZATION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IONADMIN, "organization", "The name of the issuing organization of the ADM.");
-
-}
-
-void dtn_ion_ionadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_ionadmin_init_edd()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CLOCK_ERROR);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "clock_error", "This is how accurate the ION Agent's clock is described as number of seconds, an absolute value.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CLOCK_SYNC);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "clock_sync", "This is whether or not the the computer on which the local ION node is running has a synchronized clock.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CONGESTION_ALARM_CONTROL);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "congestion_alarm_control", "This is whether or not the node has a control that will set off alarm if it will become congested at some future time.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CONGESTION_END_TIME_FORECASTS);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "congestion_end_time_forecasts", "This is the time horizon beyond which we don't attempt to forecast congestion");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_CONSUMPTION_RATE);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "consumption_rate", "This is the mean rate of continuous data delivery to local BP applications.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_INBOUND_FILE_SYSTEM_OCCUPANCY_LIMIT);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "inbound_file_system_occupancy_limit", "This is the maximum number of megabytes of storage space in ION's local file system that can be used for the storage of inbound zero-copy objects. The default heap limit is 1 Terabyte.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_INBOUND_HEAP_OCCUPANCY_LIMIT);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "inbound_heap_occupancy_limit", "This is the maximum number of megabytes of storage space in ION's SDR non-volatile heap that can be used for the storage of inbound zero-copy objects. The default heap limit is 20% of the SDR data space's total heap size.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_NUMBER);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "number", "This is a CBHE node number which uniquely identifies the node in the delay-tolerant network.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_OUTBOUND_FILE_SYSTEM_OCCUPANCY_LIMIT);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "outbound_file_system_occupancy_limit", "This is the maximum number of megabytes of storage space in ION's local file system that can be used for the storage of outbound zero-copy objects. The default heap limit is 1 Terabyte.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_OUTBOUND_HEAP_OCCUPANCY_LIMIT);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "outbound_heap_occupancy_limit", "This is the maximum number of megabytes of storage space in ION's SDR non-volatile heap that can be used for the storage of outbound zero-copy objects. The default heap limit is 20% of the SDR data space's total heap size.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_PRODUCTION_RATE);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "production_rate", "This is the rate of local data production.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_REF_TIME);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_TV, id, ADM_ENUM_DTN_ION_IONADMIN, "ref_time", "This is the reference time that will be used for interpreting relative time values from now until the next revision of reference time.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_TIME_DELTA);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_ION_IONADMIN, "time_delta", "The time delta is used to compensate for error (drift) in clocks, particularly spacecraft clocks. The hardware clock on a spacecraft might gain or lose a few seconds every month, to the point at which its understanding of the current time - as reported out by the operating system - might differ significantly from the actual value of Unix Epoch time as reported by authoritative clocks on Earth. To compensate for this difference without correcting the clock itself (which can be difficult and dangerous), ION simply adds the time delta to the Epoch time reported by the operating system.");
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ionadmin_idx[ADM_EDD_IDX], DTN_ION_IONADMIN_EDD_VERSION);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IONADMIN, "version", "This is the version of ION that is currently installed.");
-
-}
-
-void dtn_ion_ionadmin_init_op()
-{
-
-}
-
-void dtn_ion_ionadmin_init_var()
-{
-
-}
-
-void dtn_ion_ionadmin_init_ctrl()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-
-	/* NODE_INIT */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_INIT);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_init", "Until this control is executed, the local ION node does not exist and most ionadmin controls will fail. The control configures the local node to be identified by node_number, a CBHE node number which uniquely identifies the node in the delay-tolerant network.  It also configures ION's data space (SDR) and shared working-memory region.  For this purpose it uses a set of default settings if no argument follows node_number or if the argument following node_number is ''; otherwise it uses the configuration settings found in a configuration file.  If configuration file name is provided, then the configuration file's name is implicitly 'hostname.ionconfig'; otherwise, ion_config_filename is taken to be the explicit configuration file name.");
-
-	meta_add_parm(meta, "node_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "config_file", AMP_TYPE_STR);
-
-	/* NODE_CLOCK_ERROR_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CLOCK_ERROR_SET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_clock_error_set", "This management control sets ION's understanding of the accuracy of the scheduled start and stop times of planned contacts, in seconds.  The default value is 1.");
-
-	meta_add_parm(meta, "known_maximum_clock_error", AMP_TYPE_UINT);
-
-	/* NODE_CLOCK_SYNC_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CLOCK_SYNC_SET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_clock_sync_set", "This management control reports whether or not the computer on which the local ION node is running has a synchronized clock.");
-
-	meta_add_parm(meta, "new_state", AMP_TYPE_BOOL);
-
-	/* NODE_CONGESTION_ALARM_CONTROL_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONGESTION_ALARM_CONTROL_SET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_congestion_alarm_control_set", "This management control establishes a control which will automatically be executed whenever ionadmin predicts that the node will become congested at some future time.");
-
-	meta_add_parm(meta, "congestion_alarm_control", AMP_TYPE_STR);
-
-	/* NODE_CONGESTION_END_TIME_FORECASTS_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONGESTION_END_TIME_FORECASTS_SET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_congestion_end_time_forecasts_set", "This management control sets the end time for computed congestion forecasts. Setting congestion forecast horizon to zero sets the congestion forecast end time to infinite time in the future: if there is any predicted net growth in bundle storage space occupancy at all, following the end of the last scheduled contact, then eventual congestion will be predicted. The default value is zero, i.e., no end time.");
-
-	meta_add_parm(meta, "end_time_for_congestion_forcasts", AMP_TYPE_UINT);
-
-	/* NODE_CONSUMPTION_RATE_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONSUMPTION_RATE_SET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_consumption_rate_set", "This management control sets ION's expectation of the mean rate of continuous data delivery to local BP applications throughout the period of time over which congestion forecasts are computed. For nodes that function only as routers this variable will normally be zero. A value of -1, which is the default, indicates that the rate of local data consumption is unknown; in that case local data consumption is not considered in the computation of congestion forecasts.");
-
-	meta_add_parm(meta, "planned_data_consumption_rate", AMP_TYPE_UINT);
-
-	/* NODE_CONTACT_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONTACT_ADD);
-	adm_add_ctrldef_ari(id, 6, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_contact_add", "This control schedules a period of data transmission from source_node to dest_node. The period of transmission will begin at start_time and end at stop_time, and the rate of data transmission will be xmit_data_rate bytes/second. Our confidence in the contact defaults to 1.0, indicating that the contact is scheduled - not that non-occurrence of the contact is impossible, just that occurrence of the contact is planned and scheduled rather than merely imputed from past node behavior. In the latter case, confidence indicates our estimation of the likelihood of this potential contact.");
-
-	meta_add_parm(meta, "start", AMP_TYPE_TV);
-	meta_add_parm(meta, "stop", AMP_TYPE_TV);
-	meta_add_parm(meta, "from_node_id", AMP_TYPE_UINT);
-	meta_add_parm(meta, "to_node_id", AMP_TYPE_UINT);
-	meta_add_parm(meta, "data_rate", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "prob", AMP_TYPE_UVAST);
-
-	/* NODE_CONTACT_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_CONTACT_DEL);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_contact_del", "This control deletes the scheduled period of data transmission from source_node to dest_node starting at start_time. To delete all contacts between some pair of nodes, use '*' as start_time.");
-
-	meta_add_parm(meta, "start", AMP_TYPE_TV);
-	meta_add_parm(meta, "node_id", AMP_TYPE_UINT);
-	meta_add_parm(meta, "dest", AMP_TYPE_STR);
-
-	/* NODE_INBOUND_HEAP_OCCUPANCY_LIMIT_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_INBOUND_HEAP_OCCUPANCY_LIMIT_SET);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_inbound_heap_occupancy_limit_set", "This management control sets the maximum number of megabytes of storage space in ION's SDR non-volatile heap that can be used for the storage of inbound zero-copy objects. A value of -1 for either limit signifies 'leave unchanged'. The default heap limit is 30% of the SDR data space's total heap size.");
-
-	meta_add_parm(meta, "heap_occupancy_limit", AMP_TYPE_UINT);
-	meta_add_parm(meta, "file_system_occupancy_limit", AMP_TYPE_UINT);
-
-	/* NODE_OUTBOUND_HEAP_OCCUPANCY_LIMIT_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_OUTBOUND_HEAP_OCCUPANCY_LIMIT_SET);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_outbound_heap_occupancy_limit_set", "This management control sets the maximum number of megabytes of storage space in ION's SDR non-volatile heap that can be used for the storage of outbound zero-copy objects.  A value of  -1 for either limit signifies 'leave unchanged'. The default heap  limit is 30% of the SDR data space's total heap size.");
-
-	meta_add_parm(meta, "heap_occupancy_limit", AMP_TYPE_UINT);
-	meta_add_parm(meta, "file_system_occupancy_limit", AMP_TYPE_UINT);
-
-	/* NODE_PRODUCTION_RATE_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_PRODUCTION_RATE_SET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_production_rate_set", "This management control sets ION's expectation of the mean rate of continuous data origination by local BP applications throughout the period of time over which congestion forecasts are computed. For nodes that function only as routers this variable will normally be zero. A value of -1, which is the default, indicates that the rate of local data production is unknown; in that case local data production is not considered in the computation of congestion forecasts.");
-
-	meta_add_parm(meta, "planned_data_production_rate", AMP_TYPE_UINT);
-
-	/* NODE_RANGE_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_RANGE_ADD);
-	adm_add_ctrldef_ari(id, 5, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_range_add", "This control predicts a period of time during which the distance from node to other_node will be constant to within one light second. The period will begin at start_time and end at stop_time, and the distance between the nodes during that time will be distance light seconds.");
-
-	meta_add_parm(meta, "start", AMP_TYPE_TV);
-	meta_add_parm(meta, "stop", AMP_TYPE_TV);
-	meta_add_parm(meta, "node", AMP_TYPE_UINT);
-	meta_add_parm(meta, "other_node", AMP_TYPE_UINT);
-	meta_add_parm(meta, "distance", AMP_TYPE_UINT);
-
-	/* NODE_RANGE_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_RANGE_DEL);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_range_del", "This control deletes the predicted period of constant distance between node and other_node starting at start_time. To delete all ranges between some pair of nodes, use '*' as start_time.");
-
-	meta_add_parm(meta, "start", AMP_TYPE_TV);
-	meta_add_parm(meta, "node", AMP_TYPE_UINT);
-	meta_add_parm(meta, "other_node", AMP_TYPE_UINT);
-
-	/* NODE_REF_TIME_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_REF_TIME_SET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_ref_time_set", "This is used to set the reference time that will be used for interpreting relative time values from now until the next revision of reference time. Note that the new reference time can be a relative time, i.e., an offset beyond the current reference time.");
-
-	meta_add_parm(meta, "time", AMP_TYPE_TV);
-
-	/* NODE_TIME_DELTA_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionadmin_idx[ADM_CTRL_IDX], DTN_ION_IONADMIN_CTRL_NODE_TIME_DELTA_SET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONADMIN, "node_time_delta_set", "This management control sets ION's understanding of the current difference between correct time and the Unix Epoch time values reported by the clock for the local ION node's computer. This delta is automatically applied to locally obtained time values whenever ION needs to know the current time.");
-
-	meta_add_parm(meta, "local_time_sec_after_epoch", AMP_TYPE_UINT);
-}
-
-void dtn_ion_ionadmin_init_mac()
-{
-
-}
-
-void dtn_ion_ionadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_ionadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* CONTACTS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ionadmin_idx[ADM_TBLT_IDX], DTN_ION_IONADMIN_TBLT_CONTACTS), NULL);
-	tblt_add_col(def, AMP_TYPE_TV, "start_time");
-	tblt_add_col(def, AMP_TYPE_TV, "stop_time");
-	tblt_add_col(def, AMP_TYPE_UINT, "source_node");
-	tblt_add_col(def, AMP_TYPE_UINT, "dest_node");
-	tblt_add_col(def, AMP_TYPE_UVAST, "xmit_data");
-	tblt_add_col(def, AMP_TYPE_UVAST, "confidence");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_IONADMIN, "contacts", "This table shows all scheduled periods of data transmission.");
-
-	/* RANGES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ionadmin_idx[ADM_TBLT_IDX], DTN_ION_IONADMIN_TBLT_RANGES), NULL);
-	tblt_add_col(def, AMP_TYPE_TV, "start");
-	tblt_add_col(def, AMP_TYPE_TV, "stop");
-	tblt_add_col(def, AMP_TYPE_UINT, "node");
-	tblt_add_col(def, AMP_TYPE_UINT, "other_node");
-	tblt_add_col(def, AMP_TYPE_UINT, "distance");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_IONADMIN, "ranges", "This table shows all predicted periods of constant distance between nodes.");
-}
-
-#endif // _HAVE_DTN_ION_IONADMIN_ADM_
diff --git a/nm/mgr/adm_ion_ipn_admin_mgr.c b/nm/mgr/adm_ion_ipn_admin_mgr.c
deleted file mode 100644
index c913619a..00000000
--- a/nm/mgr/adm_ion_ipn_admin_mgr.c
+++ /dev/null
@@ -1,203 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ipn_admin_mgr.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ion_ipn_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "metadata.h"
-#include "nm_mgr_ui.h"
-
-
-
-
-#define _HAVE_DTN_ION_IPNADMIN_ADM_
-#ifdef _HAVE_DTN_ION_IPNADMIN_ADM_
-static vec_idx_t g_dtn_ion_ipnadmin_idx[11];
-
-void dtn_ion_ipnadmin_init()
-{
-	adm_add_adm_info("dtn_ion_ipnadmin", ADM_ENUM_DTN_ION_IPNADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IPNADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_ipnadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IPNADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_ipnadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IPNADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_ipnadmin_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IPNADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_ipnadmin_init_meta();
-	dtn_ion_ipnadmin_init_cnst();
-	dtn_ion_ipnadmin_init_edd();
-	dtn_ion_ipnadmin_init_op();
-	dtn_ion_ipnadmin_init_var();
-	dtn_ion_ipnadmin_init_ctrl();
-	dtn_ion_ipnadmin_init_mac();
-	dtn_ion_ipnadmin_init_rpttpl();
-	dtn_ion_ipnadmin_init_tblt();
-}
-
-void dtn_ion_ipnadmin_init_meta()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ipnadmin_idx[ADM_META_IDX], DTN_ION_IPNADMIN_META_NAME);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IPNADMIN, "name", "The human-readable name of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ipnadmin_idx[ADM_META_IDX], DTN_ION_IPNADMIN_META_NAMESPACE);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IPNADMIN, "namespace", "The namespace of the ADM");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ipnadmin_idx[ADM_META_IDX], DTN_ION_IPNADMIN_META_VERSION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IPNADMIN, "version", "The version of the ADM");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ipnadmin_idx[ADM_META_IDX], DTN_ION_IPNADMIN_META_ORGANIZATION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IPNADMIN, "organization", "The name of the issuing organization of the ADM");
-
-}
-
-void dtn_ion_ipnadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_edd()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ipnadmin_idx[ADM_EDD_IDX], DTN_ION_IPNADMIN_EDD_ION_VERSION);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IPNADMIN, "ion_version", "This is the version of ion is that currently installed.");
-
-}
-
-void dtn_ion_ipnadmin_init_op()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_var()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_ctrl()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-
-	/* EXIT_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_EXIT_ADD);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IPNADMIN, "exit_add", "This control establishes an exit for static default routing.");
-
-	meta_add_parm(meta, "first_node_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "last_node_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "gateway_endpoint_id", AMP_TYPE_STR);
-
-	/* EXIT_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_EXIT_CHANGE);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IPNADMIN, "exit_change", "This control changes the gateway node number for the exit identified by firstNodeNbr and lastNodeNbr.");
-
-	meta_add_parm(meta, "first_node_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "last_node_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "gatewayEndpointId", AMP_TYPE_STR);
-
-	/* EXIT_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_EXIT_DEL);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IPNADMIN, "exit_del", "This control deletes the exit identified by firstNodeNbr and lastNodeNbr.");
-
-	meta_add_parm(meta, "first_node_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "last_node_nbr", AMP_TYPE_UINT);
-
-	/* PLAN_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_PLAN_ADD);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IPNADMIN, "plan_add", "This control establishes an egress plan for the bundles that must be transmitted to the neighboring node that is identified by it's nodeNbr.");
-
-	meta_add_parm(meta, "node_nbr", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "xmit_rate", AMP_TYPE_UINT);
-
-	/* PLAN_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_PLAN_CHANGE);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IPNADMIN, "plan_change", "This control changes the duct expression for the indicated plan.");
-
-	meta_add_parm(meta, "node_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "default_duct_expression", AMP_TYPE_STR);
-
-	/* PLAN_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ipnadmin_idx[ADM_CTRL_IDX], DTN_ION_IPNADMIN_CTRL_PLAN_DEL);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IPNADMIN, "plan_del", "This control deletes the egress plan for the node that is identified by it's nodeNbr.");
-
-	meta_add_parm(meta, "node_nbr", AMP_TYPE_UINT);
-}
-
-void dtn_ion_ipnadmin_init_mac()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_ipnadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* EXITS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ipnadmin_idx[ADM_TBLT_IDX], DTN_ION_IPNADMIN_TBLT_EXITS), NULL);
-	tblt_add_col(def, AMP_TYPE_UVAST, "first_node_nbr");
-	tblt_add_col(def, AMP_TYPE_UVAST, "last_node_nbr");
-	tblt_add_col(def, AMP_TYPE_STR, "gateway_endpoint_id");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_IPNADMIN, "exits", "This table lists all of the exits that are defined in the IPN database for the local node.");
-
-	/* PLANS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ipnadmin_idx[ADM_TBLT_IDX], DTN_ION_IPNADMIN_TBLT_PLANS), NULL);
-	tblt_add_col(def, AMP_TYPE_UVAST, "node_nbr");
-	tblt_add_col(def, AMP_TYPE_STR, "action");
-	tblt_add_col(def, AMP_TYPE_STR, "spec");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_IPNADMIN, "plans", "This table lists all of the egress plans that are established in the IPN database for the local node.");
-}
-
-#endif // _HAVE_DTN_ION_IPNADMIN_ADM_
diff --git a/nm/mgr/adm_ion_ltp_admin_mgr.c b/nm/mgr/adm_ion_ltp_admin_mgr.c
deleted file mode 100644
index 405d0e13..00000000
--- a/nm/mgr/adm_ion_ltp_admin_mgr.c
+++ /dev/null
@@ -1,229 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ltp_admin_mgr.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ion_ltp_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "metadata.h"
-#include "nm_mgr_ui.h"
-
-
-
-
-#define _HAVE_DTN_ION_LTPADMIN_ADM_
-#ifdef _HAVE_DTN_ION_LTPADMIN_ADM_
-static vec_idx_t g_dtn_ion_ltpadmin_idx[11];
-
-void dtn_ion_ltpadmin_init()
-{
-	adm_add_adm_info("dtn_ion_ltpadmin", ADM_ENUM_DTN_ION_LTPADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_LTPADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_ltpadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_LTPADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_ltpadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_LTPADMIN * 20) + ADM_EDD_IDX), &(g_dtn_ion_ltpadmin_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_LTPADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_ltpadmin_init_meta();
-	dtn_ion_ltpadmin_init_cnst();
-	dtn_ion_ltpadmin_init_edd();
-	dtn_ion_ltpadmin_init_op();
-	dtn_ion_ltpadmin_init_var();
-	dtn_ion_ltpadmin_init_ctrl();
-	dtn_ion_ltpadmin_init_mac();
-	dtn_ion_ltpadmin_init_rpttpl();
-	dtn_ion_ltpadmin_init_tblt();
-}
-
-void dtn_ion_ltpadmin_init_meta()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ltpadmin_idx[ADM_META_IDX], DTN_ION_LTPADMIN_META_NAME);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_LTPADMIN, "name", "The human-readable name of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ltpadmin_idx[ADM_META_IDX], DTN_ION_LTPADMIN_META_NAMESPACE);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_LTPADMIN, "namespace", "The namespace of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ltpadmin_idx[ADM_META_IDX], DTN_ION_LTPADMIN_META_VERSION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_LTPADMIN, "version", "The version of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ltpadmin_idx[ADM_META_IDX], DTN_ION_LTPADMIN_META_ORGANIZATION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_LTPADMIN, "organization", "The name of the issuing organization of the ADM.");
-
-}
-
-void dtn_ion_ltpadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_edd()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_EDD, 0, g_dtn_ion_ltpadmin_idx[ADM_EDD_IDX], DTN_ION_LTPADMIN_EDD_ION_VERSION);
-	adm_add_edd(id, NULL);
-	meta_add_edd(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_LTPADMIN, "ion_version", "This is the version of ION that is currently installed.");
-
-}
-
-void dtn_ion_ltpadmin_init_op()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_var()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_ctrl()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-
-	/* MANAGE_HEAP */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_MANAGE_HEAP);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_LTPADMIN, "manage_heap", "This control declares the maximum number of bytes of SDR heap space that will be occupied by the acquisition of any single LTP block. All data acquired in excess of this limit will be written to a temporary file pending extraction and dispatching of the acquired block. Default is the minimum allowed value (560 bytes), which is the approximate size of a ZCO file reference object; this is the minimum SDR heap space occupancy in the event that all acquisition is into a file.");
-
-	meta_add_parm(meta, "max_database_heap_per_block", AMP_TYPE_UINT);
-
-	/* MANAGE_MAX_BER */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_MANAGE_MAX_BER);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_LTPADMIN, "manage_max_ber", "This control sets the expected maximum bit error rate(BER) that LTP should provide for in computing the maximum number of transmission efforts to initiate in the transmission of a given block.(Note that this computation is also sensitive to data segment size and to the size of the block that is to be transmitted.) The default value is .0001 (10^-4).");
-
-	meta_add_parm(meta, "max_expected_bit_error_rate", AMP_TYPE_REAL32);
-
-	/* MANAGE_OWN_QUEUE_TIME */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_MANAGE_OWN_QUEUE_TIME);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_LTPADMIN, "manage_own_queue_time", "This control sets the number of seconds of predicted additional latency attributable to processing delay within the local engine itself that should be included whenever LTP computes the nominal round-trip time for an exchange of data with any remote engine.The default value is 1.");
-
-	meta_add_parm(meta, "own_queing_latency", AMP_TYPE_UINT);
-
-	/* MANAGE_SCREENING */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_MANAGE_SCREENING);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_LTPADMIN, "manage_screening", "This control enables or disables the screening of received LTP segments per the periods of scheduled reception in the node's contact graph. By default, screening is disabled. When screening is enabled, such segments are silently discarded. Note that when screening is enabled the ranges declared in the contact graph must be accurate and clocks must be synchronized; otherwise, segments will be arriving at times other than the scheduled contact intervals and will be discarded.");
-
-	meta_add_parm(meta, "new_state", AMP_TYPE_UINT);
-
-	/* SPAN_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_SPAN_ADD);
-	adm_add_ctrldef_ari(id, 8, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_LTPADMIN, "span_add", "This control declares that a span of potential LTP data interchange exists between the local LTP engine and the indicated (neighboring) LTP engine.");
-
-	meta_add_parm(meta, "peer_engine_number", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "max_export_sessions", AMP_TYPE_UINT);
-	meta_add_parm(meta, "max_import_sessions", AMP_TYPE_UINT);
-	meta_add_parm(meta, "max_segment_size", AMP_TYPE_UINT);
-	meta_add_parm(meta, "aggregtion_size_limit", AMP_TYPE_UINT);
-	meta_add_parm(meta, "aggregation_time_limit", AMP_TYPE_UINT);
-	meta_add_parm(meta, "lso_control", AMP_TYPE_STR);
-	meta_add_parm(meta, "queuing_latency", AMP_TYPE_UINT);
-
-	/* SPAN_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_SPAN_CHANGE);
-	adm_add_ctrldef_ari(id, 8, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_LTPADMIN, "span_change", "This control sets the indicated span's configuration parameters to the values provided as arguments");
-
-	meta_add_parm(meta, "peer_engine_number", AMP_TYPE_UVAST);
-	meta_add_parm(meta, "max_export_sessions", AMP_TYPE_UINT);
-	meta_add_parm(meta, "max_import_sessions", AMP_TYPE_UINT);
-	meta_add_parm(meta, "max_segment_size", AMP_TYPE_UINT);
-	meta_add_parm(meta, "aggregtion_size_limit", AMP_TYPE_UINT);
-	meta_add_parm(meta, "aggregation_time_limit", AMP_TYPE_UINT);
-	meta_add_parm(meta, "lso_control", AMP_TYPE_STR);
-	meta_add_parm(meta, "queuing_latency", AMP_TYPE_UINT);
-
-	/* SPAN_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_SPAN_DEL);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_LTPADMIN, "span_del", "This control deletes the span identified by peerEngineNumber. The control will fail if any outbound segments for this span are pending transmission or any inbound blocks from the peer engine are incomplete.");
-
-	meta_add_parm(meta, "peer_engine_number", AMP_TYPE_UVAST);
-
-	/* STOP */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 0, g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_STOP);
-	adm_add_ctrldef_ari(id, 0, NULL);
-	meta_add_ctrl(id, ADM_ENUM_DTN_ION_LTPADMIN, "stop", "This control stops all link service input and output tasks for the local LTP engine.");
-
-
-	/* WATCH_SET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ltpadmin_idx[ADM_CTRL_IDX], DTN_ION_LTPADMIN_CTRL_WATCH_SET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_LTPADMIN, "watch_set", "This control enables and disables production of a continuous stream of user- selected LTP activity indication characters. Activity parameter of 1 selects all LTP activity indication characters; 0 de-selects all LTP activity indication characters; any other activitySpec such as df{] selects all activity indication characters in the string, de-selecting all others. LTP will print each selected activity indication character to stdout every time a processing event of the associated type occurs: d bundle appended to block for next session, e segment of block is queued for transmission, f block has been fully segmented for transmission, g segment popped from transmission queue, h positive ACK received for block and session ended, s segment received, t block has been fully received, @ negative ACK received for block and segments retransmitted, = unacknowledged checkpoint was retransmitted, + unacknowledged report segment was retransmitted, { export session canceled locally (by sender), } import session canceled by remote sender, [ import session canceled locally (by receiver), ] export session canceled by remote receiver");
-
-	meta_add_parm(meta, "activity", AMP_TYPE_STR);
-}
-
-void dtn_ion_ltpadmin_init_mac()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_ltpadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* SPANS */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ltpadmin_idx[ADM_TBLT_IDX], DTN_ION_LTPADMIN_TBLT_SPANS), NULL);
-	tblt_add_col(def, AMP_TYPE_UVAST, "peer_engine_nbr");
-	tblt_add_col(def, AMP_TYPE_UINT, "max_export_sessions");
-	tblt_add_col(def, AMP_TYPE_UINT, "max_import_sessions");
-	tblt_add_col(def, AMP_TYPE_UINT, "max_segment_size");
-	tblt_add_col(def, AMP_TYPE_UINT, "aggregation_size_limit");
-	tblt_add_col(def, AMP_TYPE_UINT, "aggregation_time_limit");
-	tblt_add_col(def, AMP_TYPE_STR, "lso_control");
-	tblt_add_col(def, AMP_TYPE_UINT, "queueing_latency");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_LTPADMIN, "spans", "This table lists all spans of potential LTP data interchange that exists between the local LTP engine and the indicated (neighboring) LTP engine.");
-}
-
-#endif // _HAVE_DTN_ION_LTPADMIN_ADM_
diff --git a/nm/mgr/adm_ionsec_admin_mgr.c b/nm/mgr/adm_ionsec_admin_mgr.c
deleted file mode 100644
index ba7a4291..00000000
--- a/nm/mgr/adm_ionsec_admin_mgr.c
+++ /dev/null
@@ -1,244 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ionsec_admin_mgr.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ionsec_admin.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "metadata.h"
-#include "nm_mgr_ui.h"
-
-
-
-
-#define _HAVE_DTN_ION_IONSECADMIN_ADM_
-#ifdef _HAVE_DTN_ION_IONSECADMIN_ADM_
-static vec_idx_t g_dtn_ion_ionsecadmin_idx[11];
-
-void dtn_ion_ionsecadmin_init()
-{
-	adm_add_adm_info("dtn_ion_ionsecadmin", ADM_ENUM_DTN_ION_IONSECADMIN);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONSECADMIN * 20) + ADM_META_IDX), &(g_dtn_ion_ionsecadmin_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONSECADMIN * 20) + ADM_TBLT_IDX), &(g_dtn_ion_ionsecadmin_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_ION_IONSECADMIN * 20) + ADM_CTRL_IDX), &(g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ion_ionsecadmin_init_meta();
-	dtn_ion_ionsecadmin_init_cnst();
-	dtn_ion_ionsecadmin_init_edd();
-	dtn_ion_ionsecadmin_init_op();
-	dtn_ion_ionsecadmin_init_var();
-	dtn_ion_ionsecadmin_init_ctrl();
-	dtn_ion_ionsecadmin_init_mac();
-	dtn_ion_ionsecadmin_init_rpttpl();
-	dtn_ion_ionsecadmin_init_tblt();
-}
-
-void dtn_ion_ionsecadmin_init_meta()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionsecadmin_idx[ADM_META_IDX], DTN_ION_IONSECADMIN_META_NAME);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IONSECADMIN, "name", "The human-readable name of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionsecadmin_idx[ADM_META_IDX], DTN_ION_IONSECADMIN_META_NAMESPACE);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IONSECADMIN, "namespace", "The namespace of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionsecadmin_idx[ADM_META_IDX], DTN_ION_IONSECADMIN_META_VERSION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IONSECADMIN, "version", "The version of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ion_ionsecadmin_idx[ADM_META_IDX], DTN_ION_IONSECADMIN_META_ORGANIZATION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_ION_IONSECADMIN, "organization", "The name of the issuing organization of the ADM.");
-
-}
-
-void dtn_ion_ionsecadmin_init_cnst()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_edd()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_op()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_var()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_ctrl()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-
-	/* KEY_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_KEY_ADD);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "key_add", "This control adds a named key value to the security policy database. The content of file_name is taken as the value of the key.Named keys can be referenced by other elements of thesecurity policy database.");
-
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "key_value", AMP_TYPE_BYTESTR);
-
-	/* KEY_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_KEY_CHANGE);
-	adm_add_ctrldef_ari(id, 2, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "key_change", "This control changes the value of the named key, obtaining the new key value from the content of file_name.");
-
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-	meta_add_parm(meta, "key_value", AMP_TYPE_BYTESTR);
-
-	/* KEY_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_KEY_DEL);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "key_del", "This control deletes the key identified by name.");
-
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-
-	/* LTP_RX_RULE_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_RX_RULE_ADD);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "ltp_rx_rule_add", "This control adds a rule specifying the manner in which LTP segment authentication will be applied to LTP segmentsrecieved from the indicated LTP engine. A segment from the indicated LTP engine will only be deemed authentic if it contains an authentication extension computed via the ciphersuite identified by ciphersuite_nbr using the applicable key value. If ciphersuite_nbr is 255 then the applicable key value is a hard-coded constant and key_name must be omitted; otherwise key_nameis required and the applicable key value is the current value of the key named key_name in the local security policy database. Valid values of ciphersuite_nbr are: 0: HMAC-SHA1-80 1: RSA-SHA256 255: NULL");
-
-	meta_add_parm(meta, "ltp_engine_id", AMP_TYPE_UINT);
-	meta_add_parm(meta, "ciphersuite_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-
-	/* LTP_RX_RULE_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_RX_RULE_CHANGE);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "ltp_rx_rule_change", "This control changes the parameters of the LTP segment authentication rule for the indicated LTP engine.");
-
-	meta_add_parm(meta, "ltp_engine_id", AMP_TYPE_UINT);
-	meta_add_parm(meta, "ciphersuite_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-
-	/* LTP_RX_RULE_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_RX_RULE_DEL);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "ltp_rx_rule_del", "This control deletes the LTP segment authentication rule for the indicated LTP engine.");
-
-	meta_add_parm(meta, "ltp_engine_id", AMP_TYPE_UINT);
-
-	/* LTP_TX_RULE_ADD */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_TX_RULE_ADD);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "ltp_tx_rule_add", "This control adds a rule specifying the manner in which LTP segments transmitted to the indicated LTP engine mustbe signed. Signing a segment destined for the indicated LTP engineentails computing an authentication extension via the ciphersuite identified by ciphersuite_nbr using the applicable key value. If ciphersuite_nbr is 255 then the applicable key value is a hard-coded constant and key_name must be omitted; otherwise key_nameis required and the applicable key value is the current value of the key named key_name in the local security policy database.Valid values of ciphersuite_nbr are: 0:HMAC_SHA1-80 1: RSA_SHA256 255: NULL");
-
-	meta_add_parm(meta, "ltp_engine_id", AMP_TYPE_UINT);
-	meta_add_parm(meta, "ciphersuite_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-
-	/* LTP_TX_RULE_CHANGE */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_TX_RULE_CHANGE);
-	adm_add_ctrldef_ari(id, 3, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "ltp_tx_rule_change", "This control changes the parameters of the LTP segment signing rule for the indicated LTP engine.");
-
-	meta_add_parm(meta, "ltp_engine_id", AMP_TYPE_UINT);
-	meta_add_parm(meta, "ciphersuite_nbr", AMP_TYPE_UINT);
-	meta_add_parm(meta, "key_name", AMP_TYPE_STR);
-
-	/* LTP_TX_RULE_DEL */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LTP_TX_RULE_DEL);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "ltp_tx_rule_del", "This control deletes the LTP segment signing rule forthe indicated LTP engine.");
-
-	meta_add_parm(meta, "ltp_engine_id", AMP_TYPE_UINT);
-
-	/* LIST_KEYS */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 0, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LIST_KEYS);
-	adm_add_ctrldef_ari(id, 0, NULL);
-	meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "list_keys", "This control lists the names of keys available in the key policy database.");
-
-
-	/* LIST_LTP_RX_RULES */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 0, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LIST_LTP_RX_RULES);
-	adm_add_ctrldef_ari(id, 0, NULL);
-	meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "list_ltp_rx_rules", "This control lists all LTP segment authentication rules in the security policy database.");
-
-
-	/* LIST_LTP_TX_RULES */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 0, g_dtn_ion_ionsecadmin_idx[ADM_CTRL_IDX], DTN_ION_IONSECADMIN_CTRL_LIST_LTP_TX_RULES);
-	adm_add_ctrldef_ari(id, 0, NULL);
-	meta_add_ctrl(id, ADM_ENUM_DTN_ION_IONSECADMIN, "list_ltp_tx_rules", "This control lists all LTP segment signing rules in the security policy database.");
-
-}
-
-void dtn_ion_ionsecadmin_init_mac()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_rpttpl()
-{
-
-}
-
-void dtn_ion_ionsecadmin_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* LTP_RX_RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ionsecadmin_idx[ADM_TBLT_IDX], DTN_ION_IONSECADMIN_TBLT_LTP_RX_RULES), NULL);
-	tblt_add_col(def, AMP_TYPE_UINT, "ltp_engine_id");
-	tblt_add_col(def, AMP_TYPE_UINT, "ciphersuite_nbr");
-	tblt_add_col(def, AMP_TYPE_STR, "key_name");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_IONSECADMIN, "ltp_rx_rules", "This table lists all LTP segment authentication rulesin the security policy database.");
-
-	/* LTP_TX_RULES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ion_ionsecadmin_idx[ADM_TBLT_IDX], DTN_ION_IONSECADMIN_TBLT_LTP_TX_RULES), NULL);
-	tblt_add_col(def, AMP_TYPE_UINT, "ltp_engine_id");
-	tblt_add_col(def, AMP_TYPE_UINT, "ciphersuite_nbr");
-	tblt_add_col(def, AMP_TYPE_STR, "key_name");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_ION_IONSECADMIN, "ltp_tx_rules", "This table lists all LTP segment signing rules in the security policy database.");
-}
-
-#endif // _HAVE_DTN_ION_IONSECADMIN_ADM_
diff --git a/nm/mgr/adm_ltp_agent_mgr.c b/nm/mgr/adm_ltp_agent_mgr.c
deleted file mode 100644
index dbb06fd3..00000000
--- a/nm/mgr/adm_ltp_agent_mgr.c
+++ /dev/null
@@ -1,405 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ltp_agent_mgr.c
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated c file 
- **
- ****************************************************************************/
-
-
-#include "ion.h"
-#include "platform.h"
-#include "adm_ltp_agent.h"
-#include "shared/utils/utils.h"
-#include "shared/primitives/report.h"
-#include "shared/primitives/blob.h"
-#include "metadata.h"
-#include "nm_mgr_ui.h"
-
-
-
-
-#define _HAVE_DTN_LTP_AGENT_ADM_
-#ifdef _HAVE_DTN_LTP_AGENT_ADM_
-static vec_idx_t g_dtn_ltp_agent_idx[11];
-
-void dtn_ltp_agent_init()
-{
-	adm_add_adm_info("dtn_ltp_agent", ADM_ENUM_DTN_LTP_AGENT);
-
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_META_IDX), &(g_dtn_ltp_agent_idx[ADM_META_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_TBLT_IDX), &(g_dtn_ltp_agent_idx[ADM_TBLT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_RPTT_IDX), &(g_dtn_ltp_agent_idx[ADM_RPTT_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_EDD_IDX), &(g_dtn_ltp_agent_idx[ADM_EDD_IDX]));
-	VDB_ADD_NN(((ADM_ENUM_DTN_LTP_AGENT * 20) + ADM_CTRL_IDX), &(g_dtn_ltp_agent_idx[ADM_CTRL_IDX]));
-
-
-	dtn_ltp_agent_init_meta();
-	dtn_ltp_agent_init_cnst();
-	dtn_ltp_agent_init_edd();
-	dtn_ltp_agent_init_op();
-	dtn_ltp_agent_init_var();
-	dtn_ltp_agent_init_ctrl();
-	dtn_ltp_agent_init_mac();
-	dtn_ltp_agent_init_rpttpl();
-	dtn_ltp_agent_init_tblt();
-}
-
-void dtn_ltp_agent_init_meta()
-{
-
-	ari_t *id = NULL;
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ltp_agent_idx[ADM_META_IDX], DTN_LTP_AGENT_META_NAME);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_LTP_AGENT, "name", "The human-readable name of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ltp_agent_idx[ADM_META_IDX], DTN_LTP_AGENT_META_NAMESPACE);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_LTP_AGENT, "namespace", "The namespace of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ltp_agent_idx[ADM_META_IDX], DTN_LTP_AGENT_META_VERSION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_LTP_AGENT, "version", "The version of the ADM.");
-
-	id = adm_build_ari(AMP_TYPE_CNST, 0, g_dtn_ltp_agent_idx[ADM_META_IDX], DTN_LTP_AGENT_META_ORGANIZATION);
-	adm_add_cnst(id, NULL);
-	meta_add_cnst(AMP_TYPE_STR, id, ADM_ENUM_DTN_LTP_AGENT, "organization", "The name of the issuing organization of the ADM.");
-
-}
-
-void dtn_ltp_agent_init_cnst()
-{
-
-}
-
-void dtn_ltp_agent_init_edd()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_REMOTE_ENGINE_NBR);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_remote_engine_nbr", "The remote engine number of this span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_EXPT_SESS);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_cur_expt_sess", "Expected sessions on this span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_OUT_SEG);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_cur_out_seg", "The current number of outbound segments for this span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_IMP_SESS);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_cur_imp_sess", "The current number of import segments for this span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_IN_SEG);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_cur_in_seg", "The current number of inbound segments for this span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_RESET_TIME);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UVAST, id, ADM_ENUM_DTN_LTP_AGENT, "span_reset_time", "The last time the span counters were reset.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_seg_q_cnt", "The output segment queued count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_seg_q_bytes", "The output segment queued bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_seg_pop_cnt", "The output segment popped count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_seg_pop_bytes", "The output segment popped bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_XMIT_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_ckpt_xmit_cnt", "The output checkpoint transmit count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_POS_ACK_RX_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_pos_ack_rx_cnt", "The output positive acknowledgement received count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_NEG_ACK_RX_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_neg_ack_rx_cnt", "The output negative acknowledgement received count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_RX_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_cancel_rx_cnt", "The output cancelled received count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_REXMIT_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_ckpt_rexmit_cnt", "The output checkpoint retransmit count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_XMIT_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_cancel_xmit_cnt", "The output cancel retransmit count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_COMPLETE_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_out_complete_cnt", "The output completed count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_red_cnt", "The input segment received red count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_red_bytes", "The input segment received red bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_green_cnt", "The input segment received green count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_green_bytes", "The input segment received green bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_redundant_cnt", "The input segment received redundant count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_redundant_bytes", "The input segment received redundant bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_mal_cnt", "The input segment malformed count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_mal_bytes", "The input segment malformed bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_unk_sender_cnt", "The input segment unknown sender count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_unk_sender_bytes", "The input segment unknown sender bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_unk_client_cnt", "The input segment unknown client count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_rx_unk_client_bytes", "The input segment unknown client bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_stray_cnt", "The input segment stray count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_stray_bytes", "The input segment stray bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_miscolor_cnt", "The input segment miscolored count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_miscolor_bytes", "The input segment miscolored bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_closed_cnt", "The input segment closed count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_BYTES);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_seg_closed_bytes", "The input segment closed bytes for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CKPT_RX_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_ckpt_rx_cnt", "The input checkpoint receive count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_POS_ACK_TX_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_pos_ack_tx_cnt", "The input positive acknolwedgement transmitted count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_NEG_ACK_TX_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_neg_ack_tx_cnt", "The input negative acknolwedgement transmitted count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_TX_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_cancel_tx_cnt", "The input cancel transmitted count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_ACK_RETX_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_ack_retx_cnt", "The input acknolwedgement retransmit count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_RX_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_cancel_rx_cnt", "The input cancel receive count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-	id = adm_build_ari(AMP_TYPE_EDD, 1, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_COMPLETE_CNT);
-	adm_add_edd(id, NULL);
-	meta = meta_add_edd(AMP_TYPE_UINT, id, ADM_ENUM_DTN_LTP_AGENT, "span_in_complete_cnt", "The input completed count for the span.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-}
-
-void dtn_ltp_agent_init_op()
-{
-
-}
-
-void dtn_ltp_agent_init_var()
-{
-
-}
-
-void dtn_ltp_agent_init_ctrl()
-{
-
-	ari_t *id = NULL;
-
-	metadata_t *meta = NULL;
-
-
-	/* RESET */
-
-	id = adm_build_ari(AMP_TYPE_CTRL, 1, g_dtn_ltp_agent_idx[ADM_CTRL_IDX], DTN_LTP_AGENT_CTRL_RESET);
-	adm_add_ctrldef_ari(id, 1, NULL);
-	meta = meta_add_ctrl(id, ADM_ENUM_DTN_LTP_AGENT, "reset", "Resets the counters associated with the engine and updates the last reset time for the span to be the time when this control was run.");
-
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-}
-
-void dtn_ltp_agent_init_mac()
-{
-
-}
-
-void dtn_ltp_agent_init_rpttpl()
-{
-
-	metadata_t *meta = NULL;
-
-	rpttpl_t *def = NULL;
-
-	/* ENDPOINTREPORT */
-	def = rpttpl_create_id(adm_build_ari(AMP_TYPE_RPTTPL, 1, g_dtn_ltp_agent_idx[ADM_RPTT_IDX], DTN_LTP_AGENT_RPTTPL_ENDPOINTREPORT));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_REMOTE_ENGINE_NBR, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_EXPT_SESS, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_OUT_SEG, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_IMP_SESS, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_CUR_IN_SEG, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_RESET_TIME, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_XMIT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_POS_ACK_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_NEG_ACK_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_REXMIT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_XMIT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_OUT_COMPLETE_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_BYTES, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CKPT_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_POS_ACK_TX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_NEG_ACK_TX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_TX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_ACK_RETX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_RX_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	rpttpl_add_item(def, ADM_BUILD_ARI_PARM_1(AMP_TYPE_EDD, g_dtn_ltp_agent_idx[ADM_EDD_IDX], DTN_LTP_AGENT_EDD_SPAN_IN_COMPLETE_CNT, tnv_from_map(AMP_TYPE_UINT, 0)));
-	adm_add_rpttpl(def);
-	meta = meta_add_rpttpl(def->id, ADM_ENUM_DTN_LTP_AGENT, "endpointReport", "This is all known endpoint information");
-	meta_add_parm(meta, "ltp_span", AMP_TYPE_UINT);
-}
-
-void dtn_ltp_agent_init_tblt()
-{
-
-	tblt_t *def = NULL;
-
-	/* ENGINES */
-
-	def = tblt_create(adm_build_ari(AMP_TYPE_TBLT, 0, g_dtn_ltp_agent_idx[ADM_TBLT_IDX], DTN_LTP_AGENT_TBLT_ENGINES), NULL);
-	tblt_add_col(def, AMP_TYPE_UVAST, "peer_engine_nbr");
-	adm_add_tblt(def);
-	meta_add_tblt(def->id, ADM_ENUM_DTN_LTP_AGENT, "engines", "This table lists all known remote engine ids.");
-}
-
-#endif // _HAVE_DTN_LTP_AGENT_ADM_
diff --git a/nm/mgr/agents.c b/nm/mgr/agents.c
index c16c5265..f537f35f 100644
--- a/nm/mgr/agents.c
+++ b/nm/mgr/agents.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -23,12 +35,13 @@
  **  10/06/18  E. Birrane      Initial Implementation (JHU/APL)
  *****************************************************************************/
 
+#include <sys/stat.h>
 // Application headers.
 #include "agents.h"
 
 
 #include "../shared/utils/debug.h"
-#include "nm_mgr.h"
+#include "nmmgr.h"
 
 agent_autologging_cfg_t agent_log_cfg = {
  // Defaults (nominal, disabled on startup)
@@ -150,7 +163,7 @@ void agent_rotate_log(agent_t *agent, int force)
 			agent->log_fd_cnt = 0;
 			agent->log_file_num++;
 		} else {
-			AMP_DEBUG_ERR("Failed to open report log file (%s) for agent %s", fn, agent->eid.name);
+		  AMP_DEBUG_ERR("agent_rotate_log", "Failed to open report log file (%s) for agent %s", fn, agent->eid.name);
 		}
 	}
 	else if (agent->log_fd != NULL)
diff --git a/nm/mgr/agents.h b/nm/mgr/agents.h
index 2fe90356..e981ba0b 100644
--- a/nm/mgr/agents.h
+++ b/nm/mgr/agents.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: agents.h
@@ -28,13 +40,17 @@
 // Standard includes
 
 // ION includes
-#include "platform.h"
-#include "sdr.h"
+#include "shared/platform.h"
 #include "../shared/utils/nm_types.h"
 #include "../shared/utils/utils.h"
 
 #include "../shared/utils/vector.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 #define AGENT_DEF_NUM_AGTS (4)
 #define AGENT_DEF_NUM_RPTS (8)
 #define AGENT_DEF_NUM_TBLS (8)
@@ -85,4 +101,8 @@ void     agent_release(agent_t *agent, int destroy);
 void     agent_rotate_log(agent_t *agent, int force);
 
 
-#endif // AGENTS_H
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _AGENTS_H */
diff --git a/nm/mgr/metadata.c b/nm/mgr/metadata.c
index 9d81f488..f3784c90 100644
--- a/nm/mgr/metadata.c
+++ b/nm/mgr/metadata.c
@@ -1,3 +1,21 @@
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 /*****************************************************************************
  **
  ** \file nm_mgr_names.c
diff --git a/nm/mgr/metadata.h b/nm/mgr/metadata.h
index 04a3f2c4..16247c29 100644
--- a/nm/mgr/metadata.h
+++ b/nm/mgr/metadata.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -28,11 +40,16 @@
 #ifndef METADATA_H_
 #define METADATA_H_
 
-#include "nm_mgr.h"
-
 #include "../shared/utils/nm_types.h"
 #include "../shared/adm/adm.h"
 #include "../shared/primitives/ari.h"
+#include "nmmgr.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 
 /*
  * +--------------------------------------------------------------------------+
@@ -166,4 +183,8 @@ meta_col_t* metacol_create();
 void        metacol_release(meta_col_t*col, int destroy);
 
 
-#endif // METADATA_H_
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _METADATA_H_ */
diff --git a/nm/mgr/nm_mgr.c b/nm/mgr/nm_mgr.c
deleted file mode 100644
index 949eefb0..00000000
--- a/nm/mgr/nm_mgr.c
+++ /dev/null
@@ -1,455 +0,0 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
-
-/*****************************************************************************
- ** \file nm_mgr.c
- **
- ** File Name: nm_mgr.c
- **
- ** Subsystem:
- **          Network Manager Application
- **
- ** Description: This file implements the DTNMP Manager user interface
- **
- ** Notes:
- **
- ** Assumptions:
- **
- ** Modification History:
- **  MM/DD/YY  AUTHOR          DESCRIPTION
- **  --------  ------------    ---------------------------------------------
- **  09/01/11  V. Ramachandran Initial Implementation (JHU/APL)
- **  08/19/13  E. Birrane      Documentation clean up and code review comments. (JHU/APL)
- **  08/21/16  E. Birrane      Update to AMP v02 (Secure DTN - NASA: NNX14CS58P)
- **  10/06/18  E. Birrane     Update to AMP v0.5 (JHU/APL)
- *****************************************************************************/
-
-// Application headers.
-#include <getopt.h>
-#include "nm_mgr.h"
-#include "nm_mgr_ui.h"
-#include "metadata.h"
-
-#ifdef USE_CIVETWEB
-#include "nm_rest.h"
-#endif
-
-#include "agents.h"
-
-#include "../shared/primitives/rules.h"
-
-
-
-mgr_db_t gMgrDB;
-iif_t ion_ptr;
-int  gRunning;
-
-char* mgr_parse_args(int argc, char* argv[]);
-void mgr_print_usage(void);
-
-/******************************************************************************
- *
- * \par Function Name: main
- *
- * \par Main agent processing function.
- *
- * \param[in]  argc    # command line arguments.
- * \param[in]  argv[]  Command-line arguments.
- *
- * \par Notes:
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- **  09/01/11  V. Ramachandran Initial Implementation
- **  08/20/13  E. Birrane      Code Review Updates
- **  10/06/18  E. Birrane      Update to AMP v0.5 (JHU/APL)
- *****************************************************************************/
-
-int main(int argc, char *argv[])
-{
-    pthread_t rx_thr;
-    pthread_t ui_thr;
-
-#ifdef HAVE_MYSQL
-    pthread_t db_thr;
-    char db_thr_name[] = "db_thread";
-#endif
-
-    char rx_thr_name[]     = "rx_thread";
-    char ui_thr_name[]     = "ui_thread";
-    char daemon_thr_name[] = "run_daemon";
-    char *mgr_eid;
-
-    errno = 0;
-
-    /* Initialize the non-volatile database.
-     *   Note: Initializing the structure here allows some attributes to be pre-defined by
-     *   command line parsing if not re-initialized later.
-     */
-    memset((char*) &(gMgrDB), 0, sizeof(gMgrDB));
-
-    if (argc > 2)
-    {
-        // Assume argv[1] is required manager_eid
-        mgr_eid = mgr_parse_args(argc, argv);
-        if (mgr_eid == NULL)
-        {
-            mgr_print_usage();
-            return 1;
-        }
-
-    }
-    else if(argc != 2)
-    {
-        fprintf(stderr,"Invalid number of arguments for nm_mgr\n");
-        mgr_print_usage();
-        return 1;
-    }
-    else
-    {
-        mgr_eid = argv[1];
-    }
-
-    /* Indicate that the threads should run once started. */
-    gRunning = 1;
-
-    /* Initialize the AMP Manager. */
-    if(mgr_init(mgr_eid) != AMP_OK)
-    {
-    	AMP_DEBUG_ERR("main","Can't init Manager.", NULL);
-    	exit(EXIT_FAILURE);
-    }
-
-    AMP_DEBUG_INFO("main","Manager EID: %s", argv[1]);
-
-
-    /* Spawn threads for receiving msgs, user interface, and db connection. */
-    if(pthread_begin(&rx_thr, NULL, (void *)mgr_rx_thread, (void *)&gRunning, "nm_mgr_rx"))
-    {
-        AMP_DEBUG_ERR("main","Can't create pthread %s, errnor = %s",
-        		        rx_thr_name, strerror(errno));
-        exit(EXIT_FAILURE);
-    }
-
-
-    if(pthread_begin(&ui_thr, NULL, (void *)ui_thread, (void *)&gRunning, "nm_mgr_ui"))
-    {
-        AMP_DEBUG_ERR("main","Can't create pthread %s, errnor = %s",
-        		        ui_thr_name, strerror(errno));
-        exit(EXIT_FAILURE);
-    }
-
-#ifdef HAVE_MYSQL
-
-    if(pthread_begin(&db_thr, NULL, (void *)db_mgt_daemon, (void *)&gRunning ,"nm_mgr_db"))
-    {
-    	AMP_DEBUG_ERR("main","Can't create pthread %s, errnor = %s",
-    			db_thr_name, strerror(errno));
-    	exit(EXIT_FAILURE);
-    }
-#endif
-
-#ifdef USE_CIVETWEB
-    nm_rest_start();
-#endif
-
-    if (pthread_join(rx_thr, NULL))
-    {
-        AMP_DEBUG_ERR("main","Can't join pthread %s. Errnor = %s",
-        		        rx_thr_name, strerror(errno));
-        exit(EXIT_FAILURE);
-    }
-    if (pthread_join(ui_thr, NULL))
-    {
-        AMP_DEBUG_ERR("main","Can't join pthread %s. Errnor = %s",
-        		         ui_thr_name, strerror(errno));
-        exit(EXIT_FAILURE);
-    }
-
-#ifdef USE_CIVETWEB
-    nm_rest_stop();
-#endif
-    
-#ifdef HAVE_MYSQL
-    if (pthread_join(db_thr, NULL))
-    {
-    	AMP_DEBUG_ERR("main","Can't join pthread %s. Errnor = %s",
-    			        db_thr_name, strerror(errno));
-    	exit(EXIT_FAILURE);
-    }
-#endif
-
-    AMP_DEBUG_ALWAYS("main","Shutting down manager.", NULL);
-    mgr_cleanup();
-
-    AMP_DEBUG_INFO("main","Exiting Manager after cleanup.", NULL);
-    exit(0);
-}
-
-
-
-
-/******************************************************************************
- *
- * \par Function Name: mgr_cleanup
- *
- * \par Cleans resources before exiting the manager.
- *
- * \par Notes:
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- **  09/01/11  V. Ramachandran Initial Implementation
- **  08/20/13  E. Birrane      Code Review Updates
- **  10/06/18  E. Birrane      Updated to AMP v0.5 (JHU/APL)
- *****************************************************************************/
-
-int mgr_cleanup()
-{
-
-#ifdef HAVE_MYSQL
-	db_mgt_close();
-#endif
-
-	vec_release(&(gMgrDB.agents), 0);
-	rhht_release(&(gMgrDB.metadata), 0);
-
-	db_destroy();
-
-	utils_mem_teardown();
-
-	return AMP_OK;
-}
-
-
-
-/******************************************************************************
- *
- * \par Function Name: mgr_init
- *
- * \par Initialize the manager...
- *
- * \par Notes:
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- **  09/01/11  V. Ramachandran Initial Implementation
- **  08/20/13  E. Birrane      Code Review Updates
- **  10/06/18  E. Birrane      Update to AMP v0.5 (JHU/APL)
- *****************************************************************************/
-int mgr_init(char *arg_eid)
-{
-	int success;
-
-	AMP_DEBUG_ENTRY("mgr_init","("ADDR_FIELDSPEC")",(uaddr) arg_eid);
-
-    /* Step 2: Make sure that ION is running and we can attach. */
-	if (ionAttach() < 0)
-	{
-		AMP_DEBUG_ERR("mgr_init", "Manager can't attach to ION.", NULL);
-		return -1;
-	}
-
-
-	/* Step 1: Initialize MGR-specific data.*/
-	gMgrDB.agents = vec_create(AGENT_DEF_NUM_AGTS, agent_cb_del,agent_cb_comp, NULL, 0, &success);
-	if(success != VEC_OK)
-	{
-		AMP_DEBUG_ERR("mgr_init", "Can't make agents vec.", NULL);
-		return AMP_FAIL;
-	}
-
-	gMgrDB.metadata = rhht_create(NM_MGR_MAX_META, ari_cb_comp_no_parm_fn, ari_cb_hash, meta_cb_del, &success);
-	if(success != RH_OK)
-	{
-		AMP_DEBUG_ERR("mgr_init", "Can't make parmspec ht.", NULL);
-		return AMP_FAIL;
-	}
-
-
-	gMgrDB.tot_rpts = 0;
-    gMgrDB.tot_tbls = 0;
-    istrcpy((char *) gMgrDB.mgr_eid.name, arg_eid, AMP_MAX_EID_LEN);
-
-
-	/* Step 2:  Attach to ION. */
-    if(iif_register_node(&ion_ptr, gMgrDB.mgr_eid) == 0)
-    {
-        AMP_DEBUG_ERR("mgr_init","Unable to register BP Node. Exiting.", NULL);
-        return AMP_FAIL;
-    }
-
-    if (iif_is_registered(&ion_ptr))
-    {
-        AMP_DEBUG_INFO("mgr_init", "Mgr registered with ION, EID: %s",
-        		         iif_get_local_eid(&ion_ptr).name);
-    }
-    else
-    {
-        AMP_DEBUG_ERR("mgr_init","Failed to register mgr with ION, EID %s",
-        				 iif_get_local_eid(&ion_ptr).name);
-        AMP_DEBUG_EXIT("mgr_init","->-1.",NULL);
-        return AMP_FAIL;
-    }
-
-
-    if((utils_mem_int()       != AMP_OK) ||
-       (db_init("nmmgr_db", &adm_init) != AMP_OK))
-    {
-    	db_destroy();
-    	AMP_DEBUG_ERR("mgr_init","Unable to initialize DB.", NULL);
-    	return AMP_FAIL;
-    }
-
-#ifdef HAVE_MYSQL
-	db_mgr_sql_init();
-	success = db_mgt_init(gMgrDB.sql_info, 0, 1);
-#endif
-
-    success = AMP_OK;
-
-    return success;
-}
-
-/**
- * Parse optional command line arguments
- */
-char* mgr_parse_args(int argc, char* argv[])
-{
-    int i;
-    int c;
-    int option_index = 0;
-    static struct option long_options[] =
-        {
-            {"log", no_argument, 0,'l'},
-            {"log-to-dirs", no_argument, 0,'d'},
-            {"log-rx-rpt", no_argument, 0,'r'},
-            {"log-rx-tbl", no_argument, 0,'t'},
-            {"log-tx-cbor", no_argument, 0,'T'},
-            {"log-rx-cbor", no_argument, 0,'R'},
-            {"log-tx-cbor", no_argument, 0,'j'},
-            {"log-rx-cbor", no_argument, 0,'J'},
-            
-            {"sql-user", required_argument, 0,'u'},
-            {"sql-pass", required_argument, 0,'p'},
-            {"sql-db", required_argument,0, 'S'},
-            {"sql-host", required_argument,0, 's'},
-            
-            {"log-dir", required_argument, 0,'D'},
-            {"log-limit", required_argument, 0,'L'},
-            {"automator", required_argument, 0,'a'},
-            {"help", required_argument, 0,'h'},
-        };
-    while ((c = getopt_long(argc, argv, "ldL:D:rtTRaAjJs:u:p:S:", long_options, &option_index)) != -1)
-    {
-        switch(c)
-        {
-        case 'l':
-            agent_log_cfg.enabled = 1;
-            break;
-        case 'd':
-            agent_log_cfg.agent_dirs = 1;
-            break;
-        case 'r':
-            agent_log_cfg.rx_rpt = 1;
-            break;
-        case 't':
-            agent_log_cfg.rx_tbl = 1;
-            break;
-        case 'T':
-            agent_log_cfg.tx_cbor = 1;
-            break;
-        case 'R':
-            agent_log_cfg.rx_cbor = 1;
-            break;
-#ifdef USE_JSON
-        case 'j':
-            agent_log_cfg.rx_json_rpt = 1;
-            break;
-        case 'J':
-            agent_log_cfg.rx_json_tbl = 1;
-            break;
-#endif
-#ifdef HAVE_MYSQL
-        case 's': // MySQL Server
-            strncpy(gMgrDB.sql_info.server, optarg, UI_SQL_SERVERLEN-1);
-            break;
-        case 'u': // MySQL Username
-            strncpy(gMgrDB.sql_info.username, optarg, UI_SQL_ACCTLEN-1);
-            break;
-        case 'p': // MySQL Password
-            strncpy(gMgrDB.sql_info.password, optarg, UI_SQL_ACCTLEN-1);
-            break;
-        case 'S': // MySQL Database Name
-            strncpy(gMgrDB.sql_info.database, optarg, UI_SQL_DBLEN-1);
-            break;
-
-#endif
-        case 'D':
-            strncpy(agent_log_cfg.dir, optarg, sizeof(agent_log_cfg.dir)-1);
-            break;
-        case 'L':
-            agent_log_cfg.limit = atoi(optarg);
-            break;
-        case 'a':
-        case 'A':
-            mgr_ui_mode = MGR_UI_AUTOMATOR;
-            break;
-        case 'h':
-            return NULL;
-        default:
-            fprintf(stderr, "Error parsing arguments\n");
-            return NULL;
-        }
-    }
-
-    // Check for any remaining unrecognized arguments
-    if ((argc-optind) != 1)
-    {
-        fprintf(stderr,"%d unrecognized arguments:\n", (argc-optind));
-        for(i = optind; i < argc; i++)
-        {
-            printf("\t%s\n", argv[i]);
-        }
-        return NULL;
-    }
-    else
-    {
-        return argv[optind];
-    }
-}
-
-void mgr_print_usage(void)
-{
-
-    printf("AMP Protocol Version %d - %s/%02d, built on %s %s\n",
-           AMP_VERSION,
-           AMP_PROTOCOL_URL,
-           AMP_VERSION,
-           __DATE__, __TIME__);
-
-    printf("Usage: nm_mgr [options] <manager eid>\n");
-    printf("Supported Options:\n");
-    printf("-A       Startup directly in the alternative Automator UI mode\n");
-    printf("-l       If specified, enable file-based logging of Manager Activity.\n");
-    printf("           If logging is not enabled, the following have no affect until enabled in UI\n");
-    printf("-d       Log each agent to a different directory\n");
-    printf("-L #      Specify maximum number of entries (reports+tables) per file before rotating\n");
-    printf("-D DIR   NM logs will be placed in this directory\n");
-    printf("-r       Log all received reports to file in text format (as shown in UI)\n");
-    printf("-t       Log all received tables to file in text format (as shown in UI)\n");
-    printf("-T       Log all transmitted message as ASCII-encoded CBOR HEX strings\n");
-    printf("-R       Log all received messages as ASCII-encoded CBOR HEX strings\n");
-#ifdef HAVE_MYSQL
-    printf("--sql-user MySQL Username\n");
-    printf("--sql-pass MySQL Password\n");
-    printf("--sql-db MySQL Datbase Name\n");
-    printf("--sql-host MySQL Host\n");
-#endif
-}
diff --git a/nm/mgr/nm_mgr.h b/nm/mgr/nm_mgr.h
deleted file mode 100644
index 3b8cf6ac..00000000
--- a/nm/mgr/nm_mgr.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
-/*****************************************************************************
- ** \file nm_mgr.h
- **
- ** File Name: nm_mgr.h
- **
- ** Subsystem:
- **          Network Manager Application
- **
- ** Description: This file implements the DTNMP Manager user interface
- **
- ** Notes:
- **
- ** Assumptions:
- **
- ** Modification History:
- **  MM/DD/YY  AUTHOR          DESCRIPTION
- **  --------  ------------    ---------------------------------------------
- **  09/01/11  V. Ramachandran Initial Implementation (JHU/APL)
- **  08/19/13  E. Birrane      Documentation clean up and code review comments. (JHU/APL)
- **  08/21/16  E. Birrane      Update to AMP v02 (Secure DTN - NASA: NNX14CS58P)
- **  10/06/18   E. Birrane     Update to AMP v0.5 (JHU/APL)
- *****************************************************************************/
-
-#ifndef NM_MGR_H
-#define NM_MGR_H
-
-// ION includes
-#include "platform.h"
-#include "sdr.h"
-
-// Standard includes
-#include "stdint.h"
-#include "pthread.h"
-#include "unistd.h"
-
-
-// Application includes
-#include "../shared/nm.h"
-#include "../shared/utils/nm_types.h"
-#include "../shared/msg/ion_if.h"
-
-#include "../shared/adm/adm.h"
-
-#include "../shared/primitives/report.h"
-
-#include "../shared/msg/msg.h"
-
-
-
-#ifdef HAVE_MYSQL
-#include "nm_mgr_sql.h"
-#endif
-
-
-/* Constants */
-#define NM_RECEIVE_TIMEOUT_SEC (2)
-#define NM_MGR_MAX_META (1024)
-
-
-typedef struct
-{
-	vector_t agents;  /* (agent_t *) */
-	rhht_t metadata; /* (metadata_t*) */
-	uvast tot_rpts;
-	uvast tot_tbls;
-	eid_t mgr_eid;
-
-#ifdef HAVE_MYSQL
-	sql_db_t sql_info;
-#endif
-} mgr_db_t;
-
-extern mgr_db_t gMgrDB;
-extern iif_t ion_ptr;
-
-// ============================= Global Data ===============================
-/**
- * Indicates if the thread loops should continue to run. This
- * value is updated by the main() and read by the subordinate
- * threads.
- **/
- extern int g_running;
-
-/* Function Prototypes */
-int      main(int argc, char *argv[]);
-
-int      mgr_cleanup();
-int      mgr_init(char *eid);
-void*    mgr_rx_thread(int *running);
-
-
-
-#endif // NM_MGR_H
diff --git a/nm/mgr/nm_mgr_print.c b/nm/mgr/nm_mgr_print.c
index d2cf1d67..7d51a5ca 100644
--- a/nm/mgr/nm_mgr_print.c
+++ b/nm/mgr/nm_mgr_print.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file nm_mgr_print.h
@@ -22,13 +34,13 @@
  **  11/01/18  E. Birrane     Update to latest AMP. (JHU/APL)
  *****************************************************************************/
 
+#include <inttypes.h>
 #include "nm_mgr_ui.h"
 #include "nm_mgr_print.h"
 #include "agents.h"
 #include "ui_input.h"
 
 #ifdef USE_JSON
-#include "cJSON.h"
 
 // JSON Prototypes (TODO: Move to header and/or discrete file)
 cJSON* ui_json_from_tnvc(tnvc_t *tnvc);
@@ -119,7 +131,7 @@ static int ui_print_agents_cb_parse(int idx, int keypress, void* data, char* sta
    agent_t *agent = (agent_t*)data;
    char *subtitle = "";
    char *tmp;
-   
+  
    switch(keypress)
    {
    case 'e':
@@ -289,6 +301,12 @@ cJSON* ui_json_table(tbl_t *tbl)
    CHKNULL(tblt);
 
    out_tbl = cJSON_CreateObject();
+
+   /* Add the table name to the JSON table */
+   char *tbl_name = ui_str_from_ari(tbl->id, NULL, 0);
+   cJSON_AddStringToObject(out_tbl, "table name", (tbl_name == NULL) ? "Unknown" : tbl_name);
+   SRELEASE(tbl_name);
+      
    cJSON *cols = cJSON_AddArrayToObject(out_tbl, "cols");
    cJSON *rows = cJSON_AddArrayToObject(out_tbl, "rows");
 
@@ -333,7 +351,15 @@ cJSON* ui_json_table(tbl_t *tbl)
 
 void ui_fprint_json_table(ui_print_cfg_t *fd, tbl_t *table)
 {
-   cJSON *json = ui_json_table(table);
+
+  /* Step 1: Print the table name */
+  char *tbl_name = ui_str_from_ari(table->id, NULL, 0);
+  ui_fprintf(fd, "\nTable Name: %s \n", (tbl_name == NULL) ? "Unknown" : tbl_name);
+  SRELEASE(tbl_name);
+
+  /* Step 2: Print table contents */
+
+  cJSON *json = ui_json_table(table);
    if (json == NULL)
    {
       return;
@@ -351,7 +377,14 @@ void ui_fprint_json_table(ui_print_cfg_t *fd, tbl_t *table)
 
 void ui_fprint_table(ui_print_cfg_t *fd, tbl_t *tbl)
 {
-   char *tmp = ui_str_from_tbl(tbl);
+
+  /* Step 1: Print the table name */
+  char *tbl_name = ui_str_from_ari(tbl->id, NULL, 0);
+  ui_fprintf(fd, "\nTable Name: %s \n", (tbl_name == NULL) ? "Unknown" : tbl_name);
+  SRELEASE(tbl_name);
+
+  /* Step 2: Print table contents */
+  char *tmp = ui_str_from_tbl(tbl);
    if (tmp != NULL) {
       ui_fprintf(fd,"%s\n", tmp);
       SRELEASE(tmp);
@@ -405,7 +438,8 @@ void ui_fprint_report(ui_print_cfg_t *fd, rpt_t *rpt)
     		ui_fprintf(fd,"\nRpt Name  : %s", rpt_info->name);
     	}
     }
-    ui_fprintf(fd,"\nTimestamp : %s", ctime(&(rpt->time)));
+    time_t secs = OS_TimeGetTotalSeconds(rpt->time);
+    ui_fprintf(fd,"\nTimestamp : %s", ctime(&secs));
     ui_fprintf(fd,"\n# Entries : %d", num_entries);
     ui_fprintf(fd,"\n----------------------------------------\n");
 
@@ -553,7 +587,8 @@ cJSON* ui_json_report(rpt_t *rpt)
           }
        }
     }
-    cJSON_AddStringToObject(rtv, "timestamp", ctime(&(rpt->time)));
+    time_t secs = OS_TimeGetTotalSeconds(rpt->time);
+    cJSON_AddStringToObject(rtv, "timestamp", ctime(&secs));
 
     /* Step 2: Print individual entries, based on type. */
 	if(rpt->id->type == AMP_TYPE_RPTTPL)
@@ -656,6 +691,7 @@ cJSON* ui_json_report(rpt_t *rpt)
 	/* Step 3: Add report to object */
     return rtv;
 }
+
 void ui_fprint_json_report(ui_print_cfg_t *fd, rpt_t *rpt)
 {
    cJSON *json = ui_json_report(rpt);
@@ -1033,12 +1069,12 @@ char *ui_str_from_sbr(rule_t *sbr)
 
 		snprintf(str,
 				1023,
-				"SBR: ID=%s, S=0x"ADDR_FIELDSPEC", E=%s, M=0x"ADDR_FIELDSPEC", C=0x"ADDR_FIELDSPEC", A=%s\n",
+				"SBR: ID=%s, S=%"PRId64", E=%s, M=%"PRId64", C=%"PRId64", A=%s\n",
 				(id_str == NULL) ? "null" :id_str,
-				(uaddr)sbr->start,
+				OS_TimeGetTotalSeconds(sbr->start),
 				(expr_str == NULL) ? "null" : expr_str,
-				(uaddr)sbr->def.as_sbr.max_eval,
-				(uaddr)sbr->def.as_sbr.max_fire,
+				sbr->def.as_sbr.max_eval,
+				sbr->def.as_sbr.max_fire,
 				(ac_str == NULL) ? "null" : ac_str);
 
 		SRELEASE(id_str);
@@ -1050,7 +1086,7 @@ char *ui_str_from_sbr(rule_t *sbr)
 
 char *ui_str_from_tbl(tbl_t *tbl)
 {
-	char *result = STAKE(4096); // todo dynamically size this.
+	char *result = STAKE(8192); // todo dynamically size this.
 	char fmt[100];
 	vecit_t it;
 	int i, j;
@@ -1067,9 +1103,10 @@ char *ui_str_from_tbl(tbl_t *tbl)
 		SRELEASE(result);
 		return NULL;
 	}
+
 	strcat(result, tmp);
 	SRELEASE(tmp);
-
+	
 	num_rows = tbl_num_rows(tbl);
 
 	strcat(result, "----------------------------------------------------------------------\n");
@@ -1078,10 +1115,10 @@ char *ui_str_from_tbl(tbl_t *tbl)
 	for(i = 0; i < num_rows; i++)
 	{
 		cur_row = tbl_get_row(tbl, i);
-
+		
 		for(j = 0; j < tnvc_get_count(cur_row); j++)
 		{
-			tnv_t *val = tnvc_get(cur_row, j);
+		  tnv_t *val = tnvc_get(cur_row, j);
 			if(j == 0)
 			{
 				strcat(result, "|");
@@ -1113,7 +1150,7 @@ void ui_json_from_tbl(cJSON *obj, tbl_t *tbl)
 	char *tmp = NULL;
 
 	CHKVOID(obj);
-    CHKVOID(tbl);
+	CHKVOID(tbl);
 
 	/* Print table headers, if we have a table template. */
 	if((tmp = ui_str_from_tblt(tblt)) == NULL)
@@ -1196,9 +1233,9 @@ char *ui_str_from_tbr(rule_t *tbr)
 		snprintf(str,
 				1024,
 				"TBR: ID=%s, S=" \
-				UVAST_FIELDSPEC ", P=" \
-				UVAST_FIELDSPEC ", C=" \
-				UVAST_FIELDSPEC ", A=%s\n",
+				PRId64 ", P=" \
+				PRId64 ", C=" \
+				PRId64 ", A=%s\n",
 				(id_str == NULL) ? "null" :id_str,
 				tbr->start,
 			    tbr->def.as_tbr.period,
@@ -1287,10 +1324,10 @@ char *ui_str_from_tnv(tnv_t *tnv)
 		case AMP_TYPE_STR:   snprintf(str, 1023, "%s", (char*) tnv->value.as_ptr); break;
 		case AMP_TYPE_INT:   sprintf(str,"%d", tnv->value.as_int);     break;
 		case AMP_TYPE_UINT:  sprintf(str,"%d", tnv->value.as_uint);    break;
-		case AMP_TYPE_VAST:  sprintf(str, VAST_FIELDSPEC , tnv->value.as_vast);   break;
+		case AMP_TYPE_VAST:  sprintf(str, PRId64, tnv->value.as_vast);   break;
 		case AMP_TYPE_TV:
 		case AMP_TYPE_TS:
-		case AMP_TYPE_UVAST: sprintf(str, UVAST_FIELDSPEC , tnv->value.as_uvast);  break;
+		case AMP_TYPE_UVAST: sprintf(str, PRIu64, tnv->value.as_uvast);  break;
 		case AMP_TYPE_REAL32:sprintf(str,"%f", tnv->value.as_real32);  break;
 		case AMP_TYPE_REAL64:sprintf(str,"%lf", tnv->value.as_real64); break;
 
diff --git a/nm/mgr/nm_mgr_print.h b/nm/mgr/nm_mgr_print.h
index 0cfed65f..33db38fa 100644
--- a/nm/mgr/nm_mgr_print.h
+++ b/nm/mgr/nm_mgr_print.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file nm_mgr_print.h
@@ -36,11 +48,15 @@
 #include "../shared/primitives/expr.h"
 #include "../shared/adm/adm.h"
 #include "nm_mgr_ui.h"
-#include "nm_mgr.h"
 #include "metadata.h"
+#include "nmmgr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #ifdef USE_JSON
-#include "cJSON.h"
+#include <cjson/cJSON.h>
 #endif
 
 // ASCII Color Codes & Macros for formatting stdout
@@ -74,6 +90,7 @@ void  ui_print_report_set(agent_t* agent);
 
 #ifdef USE_JSON
 cJSON* ui_json_report(rpt_t *rpt);
+cJSON* ui_json_table(tbl_t *tbl);
 void ui_fprint_json_report(ui_print_cfg_t *fd, rpt_t *rpt);
 void ui_fprint_json_table(ui_print_cfg_t *fd, tbl_t *rpt);
 #endif
@@ -103,4 +120,8 @@ char* ui_str_from_tnvc(tnvc_t *tnvc);
 char* ui_str_from_var(var_t *var);
 
 
+#ifdef __cplusplus
+}
 #endif
+
+#endif  /* _NM_MGR_PRINT_H_ */
diff --git a/nm/mgr/nm_mgr_rx.c b/nm/mgr/nm_mgr_rx.c
index d6f14116..d3091133 100644
--- a/nm/mgr/nm_mgr_rx.c
+++ b/nm/mgr/nm_mgr_rx.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2011-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  ** \file nm_mgr_rx.c
@@ -29,13 +41,12 @@
  **  10/07/18  E. Birrane      Update to AMP v0.5 (JHU/APL)
  *****************************************************************************/
 
-#include "nm_mgr.h"
-#include "platform.h"
+#include "shared/platform.h"
 #include "agents.h"
 
+#include <inttypes.h>
 #include <pthread.h>
 
-#include "../shared/msg/ion_if.h"
 #include "../shared/utils/nm_types.h"
 #include "../shared/utils/utils.h"
 #include "../shared/utils/debug.h"
@@ -84,11 +95,11 @@ void rx_data_rpt(msg_metadata_t *meta, msg_rpt_t *msg)
     // TODO: Check to see if we are listed as a recipient for this report.
 
 	/* Step 1: Retrieve stored information about this agent. */
-	if((agent = agent_get(&(meta->senderEid))) == NULL)
+	if((agent = agent_get(&(meta->source))) == NULL)
 	{
 		AMP_DEBUG_WARN("msg_rx_data_rpt",
 				        "Received group is from an unknown sender (%s); ignoring it.",
-						meta->senderEid.name);
+						meta->source.name);
         agent_t *agent = (agent_t*) vec_at(&gMgrDB.agents, 0);
 	}
 	else
@@ -178,11 +189,11 @@ void rx_data_tbl(msg_metadata_t *meta, msg_tbl_t *msg)
     // TODO: Check to see if we are listed as a recipient for this report.
 
 	/* Step 1: Retrieve stored information about this agent. */
-	if((agent = agent_get(&(meta->senderEid))) == NULL)
+	if((agent = agent_get(&(meta->source))) == NULL)
 	{
 		AMP_DEBUG_WARN("msg_rx_data_tbl",
 				        "Received group is from an unknown sender (%s); ignoring it.",
-						meta->senderEid);
+						meta->source);
 	}
 	else
 	{
@@ -266,10 +277,10 @@ void rx_agent_reg(msg_metadata_t *meta, msg_agent_t *msg)
  *  08/20/13  E. Birrane     Code cleanup and documentation.
  *****************************************************************************/
 
-void *mgr_rx_thread(int *running)
+void *mgr_rx_thread(void *arg)
 {
-
-    AMP_DEBUG_ENTRY("mgr_rx_thread","(0x%x)", (size_t) running);
+  nmmgr_t *mgr = arg;
+  AMP_DEBUG_ENTRY("mgr_rx_thread","mgr (%p)", mgr);
     
     AMP_DEBUG_INFO("mgr_rx_thread","Receiver thread running...", NULL);
     
@@ -286,18 +297,18 @@ void *mgr_rx_thread(int *running)
      * g_running controls the overall execution of threads in the
      * NM Agent.
      */
-    while(*running) {
+    while(daemon_run_get(&mgr->running)) {
 
         /* Step 1: Receive a message from the Bundle Protocol Agent. */
-        buf = iif_receive(&ion_ptr, &meta, NM_RECEIVE_TIMEOUT_SEC, &success);
+        buf = mif_receive(&mgr->mif, &meta, &mgr->running, &success);
         if(success != AMP_OK)
         {
-        	*running = 0;
+          daemon_run_stop(&mgr->running);
         }
         else if(buf != NULL)
         {
             if (agent_log_cfg.rx_cbor == 1) {
-                agent_t *agent = agent_get(&(meta.senderEid));
+                agent_t *agent = agent_get(&(meta.source));
                 if (agent && agent->log_fd) {
                     char *tmp = utils_hex_to_string(buf->value, buf->length);
                     fprintf(agent->log_fd, "RX: msgs:%s\n", tmp);
@@ -308,7 +319,7 @@ void *mgr_rx_thread(int *running)
 
             // Convert to HEX for logging (DB & Shell)
             char *tmp = utils_hex_to_string(buf->value, buf->length);
-            printf("RX from %s: msgs:%s\n", meta.senderEid.name, tmp);
+            printf("RX from %s: msgs:%s\n", meta.source.name, tmp);
 
         	grp = msg_grp_deserialize(buf, &success);
         	blob_release(buf, 1);
@@ -317,7 +328,7 @@ void *mgr_rx_thread(int *running)
     		{
 #ifdef HAVE_MYSQL
                 // Log discarded message in DB
-                db_incoming_finalize(0, AMP_FAIL, meta.senderEid.name, tmp);
+                db_incoming_finalize(0, AMP_FAIL, meta.source.name, tmp);
 #endif
                 SRELEASE(tmp);
     			AMP_DEBUG_ERR("mgr_rx_thread","Discarding invalid message.", NULL);
@@ -325,11 +336,11 @@ void *mgr_rx_thread(int *running)
     		}
 
     		AMP_DEBUG_INFO("mgr_rx_thread","Group had %d msgs", vec_num_entries(grp->msgs));
-    		AMP_DEBUG_INFO("mgr_rx_thread","Group timestamp %lu", grp->time);
+//FIXME:	AMP_DEBUG_INFO("mgr_rx_thread","Group timestamp %lu", grp->timestamp);
 
 #ifdef HAVE_MYSQL
             /* Copy the message group to the database tables */
-            uint32_t incoming_idx = db_incoming_initialize(grp->time, meta.senderEid);
+            uint32_t incoming_idx = db_incoming_initialize(grp->timestamp, meta.source);
             int32_t db_status = AMP_OK;
 #endif
 
@@ -384,7 +395,7 @@ void *mgr_rx_thread(int *running)
 
 #ifdef HAVE_MYSQL
             // Commit transaction and log as applicable
-            db_incoming_finalize(incoming_idx, db_status, meta.senderEid.name, tmp);
+            db_incoming_finalize(incoming_idx, db_status, meta.source.name, tmp);
 #endif
             msg_grp_release(grp, 1);
             SRELEASE(tmp);
diff --git a/nm/mgr/nm_mgr_sql.c b/nm/mgr/nm_mgr_sql.c
index dbd9dc94..424a814d 100644
--- a/nm/mgr/nm_mgr_sql.c
+++ b/nm/mgr/nm_mgr_sql.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  ** \file nm_mgr_sql.c
  **
@@ -36,10 +48,9 @@
 #ifdef HAVE_MYSQL
 
 #include <string.h>
+#include <osapi-task.h>
 
-#include "ion.h"
-
-#include "nm_mgr.h"
+#include "nmmgr.h"
 #include "nm_mgr_sql.h"
 
 /* Number of threads interacting with the database.
@@ -61,7 +72,7 @@ int db_log_always = 1; // If set, always log raw CBOR of incoming messages for d
 
 // Private functions
 static MYSQL_STMT* db_mgr_sql_prepare(size_t idx, const char* query);
-void db_process_outgoing(void);
+void db_process_outgoing(nmmgr_t *mgr);
 ac_t* db_query_ac(size_t dbidx, int ac_id);
 int db_query_tnvc(size_t dbidx, int tnvc_id, tnvc_t *parms);
 uint32_t db_insert_tnvc(db_con_t dbidx, tnvc_t *tnvc, int *status);
@@ -152,6 +163,11 @@ static MYSQL_STMT* queries[MGR_NUM_SQL_CONNECTIONS][MGR_NUM_QUERIES];
 #define dbprep_bind_param_float(idx,var) dbprep_bind_param_cmn(idx,var,MYSQL_TYPE_FLOAT);
 #define dbprep_bind_param_double(idx,var) dbprep_bind_param_cmn(idx,var,MYSQL_TYPE_DOUBLE);
 
+//skywalker adds from anms patch
+#define dbprep_bind_param_bigint(idx,var) dbprep_bind_param_cmn(idx,var,MYSQL_TYPE_LONGLONG);
+
+
+
 #define dbprep_bind_param_str(idx,var) \
 	size_t len_##var = (var==NULL) ? 0 : strlen(var);					\
 	bind_param[idx].buffer_length = len_##var;							\
@@ -183,8 +199,8 @@ static MYSQL_STMT* queries[MGR_NUM_SQL_CONNECTIONS][MGR_NUM_QUERIES];
 	MYSQL_STMT* stmt = queries[dbidx][idx];					\
 	MYSQL_BIND bind_res[cols];								\
 	MYSQL_BIND bind_param[params];							\
-	my_bool is_null[cols];								\
-	my_bool is_err[cols];									\
+	bool is_null[cols];										\
+	bool is_err[cols];										\
 	unsigned long lengths[params];							\
 	memset(bind_res,0,sizeof(bind_res));					\
 	memset(bind_param,0,sizeof(bind_param));
@@ -194,7 +210,7 @@ static MYSQL_STMT* queries[MGR_NUM_SQL_CONNECTIONS][MGR_NUM_QUERIES];
 #define DB_CHKNULL(status) if(status!=0) { query_log_err(status); return NULL; }
 #define DB_CHKUSR(status,usr) if(status!=0) { query_log_err(status); usr; }
 
-#define query_log_err(status) AMP_DBG_ERR("ERROR at %s %i: %s (errno: %d)\n", __FILE__,__LINE__, mysql_stmt_error(stmt), mysql_stmt_errno(stmt));
+#define query_log_err(status) AMP_DEBUG_ERR("ERROR at %s %i: %s (errno: %d)\n", __FILE__,__LINE__, mysql_stmt_error(stmt), mysql_stmt_errno(stmt));
 
 /** Utility function to insert debug or error informational messages into the database.
  * NOTE: If operating within a transaction, caller is responsible for committing transaction.
@@ -212,10 +228,10 @@ void db_logf_msg(size_t dbidx, const char* msg, const char* details, int level,
 }
 void db_log_msg(size_t dbidx, const char* msg, const char* details, int level, const char *fun, const char* file, size_t line)
 {
-	AMP_DEBUG(level, 'd', fun, "%s \t %s",
-			  msg,
-			  ( (details == NULL) ? "" : details )
-		);
+  amp_log(level, 'd', file, line, fun, "%s \t %s",
+          msg,
+          ( (details == NULL) ? "" : details )
+  );
 	if (dbidx >= MGR_NUM_SQL_CONNECTIONS || gConn[dbidx] == NULL) {
 		// DB Not connected or invalid idx
 		return;
@@ -278,7 +294,7 @@ static inline void db_mgt_txn_commit(int dbidx)
  *  08/29/15  E. Birrane     Added sender EID.
  *  01/25/17  E. Birrane     Update to AMP 3.5.0 (JHU/APL)
  *****************************************************************************/
-uint32_t db_incoming_initialize(time_t timestamp, eid_t sender_eid)
+uint32_t db_incoming_initialize(amp_tv_t timestamp, eid_t sender_eid)
 {
 	uint32_t rtv = 0; // Note: An ID of 0 is reserved as an error condition. MySQL will never create a new entry for this table with a value of 0.
 	char *name = sender_eid.name;
@@ -362,30 +378,35 @@ int32_t db_incoming_finalize(uint32_t id, uint32_t grp_status, char* src_eid, ch
  *  01/26/17  E. Birrane     Update to AMP 3.5.0 (JHU/APL)
  *****************************************************************************/
 
-void *db_mgt_daemon(int *running)
+void *db_mgt_daemon(void *arg)
 {
-	struct timeval start_time;
-	vast delta = 0;
+  nmmgr_t *mgr = arg;
+	OS_time_t start_time, now_time;
+	OS_time_t delta, remain;
 
 
 	AMP_DEBUG_ALWAYS("db_mgt_daemon","Starting Manager Database Daemon",NULL);
 
-	while (*running)
+	while (daemon_run_get(&mgr->running))
 	{
-    	getCurrentTime(&start_time);
+	  OS_GetLocalTime(&start_time);
 
-    	if(db_mgt_connected(DB_CTRL_CON) == 0)
-    	{
-			db_process_outgoing();
-    	}
+	  if(db_mgt_connected(DB_CTRL_CON) == 0)
+	  {
+	    db_process_outgoing(mgr);
+	  }
 
-        delta = utils_time_cur_delta(&start_time);
+	  OS_GetLocalTime(&now_time);
 
-        // Sleep for 1 second (10^6 microsec) subtracting the processing time.
-        if((delta < 2000000) && (delta > 0))
-        {
-        	microsnooze((unsigned int)(2000000 - delta));
-        }
+	  delta = OS_TimeSubtract(now_time, start_time);
+	  remain = OS_TimeSubtract(OS_TimeFromTotalSeconds(2), remain);
+
+	  // Sleep for 1 second (10^6 microsec) subtracting the processing time.
+	  if((TimeCompare(remain, OS_TimeFromTotalSeconds(0)) > 0)
+	      && (TimeCompare(delta, OS_TimeFromTotalSeconds(0)) > 0))
+	  {
+	    OS_TaskDelay(OS_TimeGetTotalMilliseconds(remain));
+	  }
 	}
 
 	AMP_DEBUG_ALWAYS("db_mgt_daemon","Cleaning up Manager Database Daemon", NULL);
@@ -458,10 +479,8 @@ uint32_t db_mgt_init_con(size_t idx, sql_db_t parms)
 				mysql_close(gConn[idx]);
 			}
 			gConn[idx] = NULL;
-			if(log > 0)
-            {
-				AMP_DEBUG_WARN("db_mgt_init", "SQL Error: %s", mysql_error(gConn[idx]));
-            }
+			AMP_DEBUG_WARN("db_mgt_init", "SQL Error: %s", mysql_error(gConn[idx]));
+
 			AMP_DEBUG_EXIT("db_mgt_init", "-->0", NULL);
 			return 0;
 		}
@@ -523,13 +542,23 @@ uint32_t db_mgt_init_con(size_t idx, sql_db_t parms)
 		queries[idx][MSGS_UPDATE_GROUP_STATE] = db_mgr_sql_prepare(idx,"UPDATE message_group mg SET state_id=? WHERE group_id=?");
 		queries[idx][MSGS_OUTGOING_GET]    = db_mgr_sql_prepare(idx,"SELECT group_id, ts FROM vw_ready_outgoing_message_groups");
 		queries[idx][MSGS_OUTGOING_CREATE] = db_mgr_sql_prepare(idx,"INSERT INTO message_group (state_id, is_outgoing) VALUES(1, TRUE)");
-		queries[idx][MSGS_INCOMING_GET]    = db_mgr_sql_prepare(idx,"SELECT * FROM vw_ready_INCOMING_message_groups");
-		queries[idx][MSGS_INCOMING_CREATE] = db_mgr_sql_prepare(idx,"SELECT create_incoming_message_group(FROM_UNIXTIME(?), ? )"); // Received timestamp, From Agent name (ie: ipn:2.1)
 		
+		//skywalker uses anms patch to fix these reported issues
+		//queries[idx][MSGS_INCOMING_GET]    = db_mgr_sql_prepare(idx,"SELECT * FROM vw_ready_INCOMING_message_groups");
+		//queries[idx][MSGS_INCOMING_CREATE] = db_mgr_sql_prepare(idx,"SELECT create_incoming_message_group(FROM_UNIXTIME(?), ? )"); // Received timestamp, From Agent name (ie: ipn:2.1)
+		queries[idx][MSGS_INCOMING_GET]    = db_mgr_sql_prepare(idx,"SELECT * FROM vw_ready_incoming_message_groups");
+		queries[idx][MSGS_INCOMING_CREATE] = db_mgr_sql_prepare(idx,"SELECT create_incoming_message_group(?, ? )"); // Received timestamp, From Agent name (ie: ipn:2.1)
+
+
+
 		queries[idx][MSGS_AGENT_GROUP_ADD_NAME] = db_mgr_sql_prepare(idx,"SELECT insert_message_group_agent_name(?, ?)"); // group_id, agent_name
 //		queries[idx][MSGS_AGENT_GROUP_ADD_ID] = db_mgr_sql_prepare(idx,"SELECT insert_message_group_agent_id(?, ?)"); // group_id, agent_id
 		queries[idx][MSGS_AGENT_MSG_ADD] = db_mgr_sql_prepare(idx,"CALL SP__insert_message_entry_agent(?, ?)"); // message_id, agent_name
-		queries[idx][MSGS_ADD_REPORT_SET_ENTRY] = db_mgr_sql_prepare(idx,"SELECT insert_message_report_entry(?, NULL, ?, ?, FROM_UNIXTIME(?))"); // message_id, order_num, ari_id, tnvc_id, ts
+
+		//skywalker uses anms patch to fix these reported issues
+		//queries[idx][MSGS_ADD_REPORT_SET_ENTRY] = db_mgr_sql_prepare(idx,"SELECT insert_message_report_entry(?, NULL, ?, ?, FROM_UNIXTIME(?))"); // message_id, order_num, ari_id, tnvc_id, ts
+		queries[idx][MSGS_ADD_REPORT_SET_ENTRY] = db_mgr_sql_prepare(idx,"SELECT insert_message_report_entry(?, NULL, ?, ?, ?)"); // message_id, order_num, ari_id, tnvc_id, ts
+
 
 		queries[idx][MSGS_REGISTER_AGENT_INSERT] = db_mgr_sql_prepare(idx,"SELECT add_message_register_entry(?,?,?,?,NULL,?)"); // group_id, ack, nak, acl, idx, agent_name
 		queries[idx][MSGS_REGISTER_AGENT_GET] = db_mgr_sql_prepare(idx,"SELECT * FROM message_agents WHERE message_id = ?");
@@ -744,7 +773,7 @@ int   db_mgt_connected(size_t idx)
 				return 0;
 			}
 
-			microsnooze(SQL_RECONN_TIME_MSEC);
+			OS_TaskDelay(SQL_RECONN_TIME_MSEC);
 			num_tries++;
 		}
 	}
@@ -755,13 +784,13 @@ int   db_mgt_connected(size_t idx)
 static MYSQL_STMT* db_mgr_sql_prepare(size_t idx, const char* query) {
 	MYSQL_STMT* rtv = mysql_stmt_init(gConn[idx]);
 	if (rtv == NULL) {
-		AMP_DBG_ERR("Failed to allocate statement", NULL);
+		AMP_DEBUG_ERR("Failed to allocate statement", NULL);
 		return rtv;
 	}
 
 	if (mysql_stmt_prepare(rtv, query, strlen(query) ) != 0)
 	{
-		AMP_DBG_ERR("Failed to prepare %s: errno %d, error= %s", query, mysql_stmt_errno(rtv),mysql_stmt_error(rtv));
+		AMP_DEBUG_ERR("Failed to prepare %s: errno %d, error= %s", query, mysql_stmt_errno(rtv),mysql_stmt_error(rtv));
 		mysql_stmt_close(rtv);
 		return NULL;
 	}
@@ -772,6 +801,8 @@ static MYSQL_STMT* db_mgr_sql_prepare(size_t idx, const char* query) {
 int  db_mgr_sql_persist()
 {
 	int success = AMP_OK;
+#if 0
+	//FIXME: persistance
 	Sdr sdr = getIonsdr();
 
 	if(gMgrDB.sql_info.desc.descObj == 0)
@@ -797,6 +828,7 @@ int  db_mgr_sql_persist()
 	sdr_end_xn(sdr);
 
 	blob_release(data, 1);
+#endif
 	return success;
 }
 
@@ -865,16 +897,23 @@ blob_t*	  db_mgr_sql_info_serialize(sql_db_t *item)
 
 int  db_mgr_sql_init()
 {
-
+#if 0
+  //FIXME persistance
 	Sdr sdr = getIonsdr();
 	char *name = "mgr_sql";
+#endif
 
 	// * Initialize the non-volatile database. * /
 	// Note: Moved to main() to allow connection parameters to be specified on the command-line.
 	//memset((char*) &(gMgrDB.sql_info), 0, sizeof(gMgrDB.sql_info));
 
-	initResourceLock(&(gMgrDB.sql_info.lock));
+        pthread_mutexattr_t attr;
+        pthread_mutexattr_init(&attr);
+        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
+	pthread_mutex_init(&(gMgrDB.sql_info.lock), &attr);
 
+#if 0
+  //FIXME persistance
 	/* Recover the Agent database, creating it if necessary. */
 	CHKERR(sdr_begin_xn(sdr));
 
@@ -926,8 +965,9 @@ int  db_mgr_sql_init()
 		AMP_DEBUG_ERR("db_mgr_sql_init", "Can't create Agent database.", NULL);
 		return -1;
 	}
+#endif
 
-	return 1;
+	return AMP_OK;
 }
 
 
@@ -964,8 +1004,8 @@ int32_t db_mgt_query_fetch(MYSQL_RES **res, char *format, ...)
 	char query[1024];
 	size_t idx = DB_RPT_CON; // TODO
 
-	AMP_DEBUG_ENTRY("db_mgt_query_fetch","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-			        (uaddr)res, (uaddr)format);
+	AMP_DEBUG_ENTRY("db_mgt_query_fetch","(%p,%p)",
+			        res, format);
 
 	/* Step 0: Sanity check. */
 	if(format == NULL)
@@ -1044,7 +1084,7 @@ int32_t db_mgt_query_insert(uint32_t *idx, char *format, ...)
 	char query[SQL_MAX_QUERY];
 	size_t db_idx = DB_RPT_CON; // TODO
 
-	AMP_DEBUG_ENTRY("db_mgt_query_insert","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",(uaddr)idx, (uaddr)format);
+	AMP_DEBUG_ENTRY("db_mgt_query_insert","(%p,%p)",idx, format);
 /*EJB
 	if(idx == NULL)
 	{
@@ -1180,15 +1220,15 @@ void db_mgt_txn_rollback()
  *  08/27/15  E. Birrane      Update to new data model, schema
  *  01/26/17  E. Birrane      Update to AMP 3.5.0 (JHU/APL)
  *****************************************************************************/
-int32_t db_tx_msg_group_agents(int group_id, msg_grp_t *msg_group)
+static int32_t db_tx_msg_group_agents(nmmgr_t *mgr, int group_id, msg_grp_t *msg_group)
 {
 	int rtv = AMP_OK;
 	dbprep_declare(DB_CTRL_CON, MSGS_GET_AGENTS, 1, 1);
 	dbprep_bind_param_int(0,group_id);
 	mysql_stmt_bind_param(stmt, bind_param);
 
-	char agent_name[AMP_MAX_EID_LEN];
-	dbprep_bind_res_str(0, agent_name,AMP_MAX_EID_LEN);
+        eid_t destination;
+	dbprep_bind_res_str(0, destination.name, AMP_MAX_EID_LEN);
 	
 	// Execute Get Number of results
 	mysql_stmt_execute(stmt);
@@ -1197,9 +1237,9 @@ int32_t db_tx_msg_group_agents(int group_id, msg_grp_t *msg_group)
 
 	while(!mysql_stmt_fetch(stmt) )
 	{
-		if (iif_send_grp(&ion_ptr, msg_group, agent_name) != AMP_OK) {
+		if (mif_send_grp(&mgr->mif, msg_group, &destination) != AMP_OK) {
 			rtv = AMP_FAIL;
-			DB_LOG_MSG(DB_CTRL_CON, "Failed to send group to agent", agent_name, AMP_FAIL); 
+			DB_LOG_MSG(DB_CTRL_CON, "Failed to send group to agent", destination.name, AMP_FAIL);
 		}
 	}
 	mysql_stmt_free_result(stmt);
@@ -1234,8 +1274,8 @@ int db_query_tnvc(size_t dbidx, int tnvc_id, tnvc_t *parms)
 	mysql_stmt_bind_param(stmt, bind_param);
 
 	// Bind results
-	uvast uvast_val;
-	vast vast_val;
+	amp_uvast uvast_val;
+	amp_vast vast_val;
 	dbprep_dec_res_int(C_DATA_TYPE_ID, tnv_type);
 	dbprep_bind_res_int(C_INT_VALUE, vast_val);
 	dbprep_bind_res_int(C_UINT_VALUE, uvast_val);
@@ -1309,7 +1349,7 @@ int db_query_tnvc(size_t dbidx, int tnvc_id, tnvc_t *parms)
 ari_t* db_query_ari(size_t dbidx, int ari_id)
 {
 	ari_t *ari;
-	uvast temp;
+	amp_uvast temp;
 
 	// Query ARI
 	enum cols { C_ARI_TYPE=0, // data_type_id
@@ -1348,13 +1388,13 @@ ari_t* db_query_ari(size_t dbidx, int ari_id)
 	DB_CHKNULL(mysql_stmt_store_result(stmt)); // Results must be buffered to allow execution of nested queries
 
 	if (mysql_stmt_num_rows(stmt) != 1) {
-		AMP_DBG_ERR("Unable to retrieve ARI ID %i", ari_id);
+		AMP_DEBUG_ERR(__FUNCTION__, "Unable to retrieve ARI ID %i", ari_id);
 		return NULL;
 	}
 
 	// Retrieve single row, or abort with error
 	if (mysql_stmt_fetch(stmt) != 0) {
-		AMP_DBG_ERR("Unable to retrieve ARI row for %i", ari_id);
+		AMP_DEBUG_ERR(__FUNCTION__, "Unable to retrieve ARI row for %i", ari_id);
 		return NULL;
 	}
 
@@ -1365,7 +1405,7 @@ ari_t* db_query_ari(size_t dbidx, int ari_id)
 	
 	if (ari_type == AMP_TYPE_LIT) // TODO
 	{
-		AMP_DBG_ERR("TODO: ARI LIT", NULL);
+		AMP_DEBUG_ERR(__FUNCTION__, "TODO: ARI LIT", NULL);
 		return NULL;
 	}
 
@@ -1565,8 +1605,8 @@ int32_t db_tx_build_group(int32_t grp_idx, msg_grp_t *msg_group)
 
 	
 	AMP_DEBUG_ENTRY("db_tx_build_group",
-					  "(%d, "ADDR_FIELDSPEC")",
-			          grp_idx, (uaddr) msg_group);
+					  "(%d, %p)",
+			          grp_idx, msg_group);
 
 	/* Step 0: Sanity check. */
 	if(msg_group == NULL)
@@ -1752,7 +1792,7 @@ agent_t *db_fetch_agent(int32_t id)
 
 	mysql_free_result(res);
 
-	AMP_DEBUG_EXIT("db_fetch_agent", "-->"ADDR_FIELDSPEC, (uaddr) result);
+	AMP_DEBUG_EXIT("db_fetch_agent", "-->%p", result);
 	return result;
 }
 
@@ -1782,7 +1822,7 @@ int32_t db_fetch_agent_idx(eid_t *eid)
 	MYSQL_RES *res = NULL;
 	MYSQL_ROW row;
 
-	AMP_DEBUG_ENTRY("db_fetch_agent_idx","("ADDR_FIELDSPEC")", (uaddr) eid);
+	AMP_DEBUG_ENTRY("db_fetch_agent_idx","(%p)", eid);
 
 	/* Step 0: Sanity Check.*/
 	if(eid == NULL)
@@ -1869,8 +1909,8 @@ int32_t db_add_adm(char *name, char *version, char *oid_root)
 	uint32_t oid_idx = 0;
 	uint32_t row_idx = 0;
 
-	AMP_DEBUG_ENTRY("db_add_adm,"ADDR_FIELDSPEC","ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-			        (uaddr)name, (uaddr)version, (uaddr)oid_root);
+	AMP_DEBUG_ENTRY("db_add_adm,%p,%p,%p)",
+			        name, version, oid_root);
 
 	/* Step 0: Sanity check. */
 	if((name == NULL) || (version == NULL) || (oid_root == NULL))
@@ -2106,7 +2146,7 @@ int32_t db_add_mid(mid_t *mid)
 	int32_t num_parms = 0;
 	uint32_t mid_idx = 0;
 
-	AMP_DEBUG_ENTRY("db_add_mid", "("ADDR_FIELDSPEC",%d)", (uaddr)mid);
+	AMP_DEBUG_ENTRY("db_add_mid", "(%p)", mid);
 
 	/* Step 0: Sanity check arguments. */
 	if(mid == NULL)
@@ -2260,7 +2300,7 @@ int32_t db_add_mc(Lyst mc)
 	uint32_t i = 0;
 	int32_t mid_idx = 0;
 
-	AMP_DEBUG_ENTRY("db_add_mc", "("ADDR_FIELDSPEC")", (uaddr)mc);
+	AMP_DEBUG_ENTRY("db_add_mc", "(%p)", mc);
 
 	/* Step 0 - Sanity check arguments. */
 	if(mc == NULL)
@@ -2374,7 +2414,7 @@ int32_t db_add_nn(oid_nn_t *nn)
 	int32_t oid_idx = 0;
 	int32_t adm_idx = 0;
 
-	AMP_DEBUG_ENTRY("db_add_nn", "("ADDR_FIELDSPEC")", (uaddr)nn);
+	AMP_DEBUG_ENTRY("db_add_nn", "(%p)", nn);
 
 	/* Step 0 - Sanity check arguments. */
 	if(nn == NULL)
@@ -2466,7 +2506,7 @@ int32_t db_add_oid_str(char *oid_str)
 	int32_t result = 0;
 	oid_t oid;
 
-	AMP_DEBUG_ENTRY("db_add_oid_str", "("ADDR_FIELDSPEC")", (uaddr)oid_str);
+	AMP_DEBUG_ENTRY("db_add_oid_str", "(%p)", oid_str);
 
 	/* Step 1: Sanity checks. */
 	if(oid_str == NULL)
@@ -2702,8 +2742,8 @@ int32_t db_add_protomid(mid_t *mid, ui_parm_spec_t *spec, amp_type_e type)
 	uint32_t parm_idx = 0;
 	uint32_t num_parms = 0;
 
-	AMP_DEBUG_ENTRY("db_add_protomid", "("ADDR_FIELDSPEC","ADDR_FIELDSPEC",%d)",
-			       (uaddr)mid, (uaddr)spec, type);
+	AMP_DEBUG_ENTRY("db_add_protomid", "(%p,%p,%d)",
+			       mid, spec, type);
 
 	/* Step 0: Sanity check arguments. */
 	if((mid == NULL) || (spec==NULL))
@@ -2834,8 +2874,8 @@ int32_t db_add_protoparms(ui_parm_spec_t *spec)
 	uint32_t result = 0;
 	uint32_t parm_idx = 0;
 
-	AMP_DEBUG_ENTRY("db_add_protoparms", "("ADDR_FIELDSPEC")",
-					  (uaddr) spec);
+	AMP_DEBUG_ENTRY("db_add_protoparms", "(%p)",
+					  spec);
 
 	/* Step 0: Sanity check arguments. */
 	if(spec == NULL)
@@ -2921,8 +2961,8 @@ int32_t db_fetch_adm_idx(char *name, char *version)
 	MYSQL_RES *res = NULL;
 	MYSQL_ROW row;
 
-	AMP_DEBUG_ENTRY("db_fetch_adm_idx","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-					  (uaddr)name, (uaddr) version);
+	AMP_DEBUG_ENTRY("db_fetch_adm_idx","(%s,%s)",
+					  name, version);
 
 	if((name == NULL) || (version == NULL))
 	{
@@ -3052,8 +3092,8 @@ blob_t* db_fetch_tdc_entry_from_row(MYSQL_ROW row, amp_type_e *type)
 	uint8_t *value = NULL;
 	uint32_t length = 0;
 
-	AMP_DEBUG_ENTRY("db_fetch_tdc_entry_from_row","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-					  (uaddr)row, (uaddr)type);
+	AMP_DEBUG_ENTRY("db_fetch_tdc_entry_from_row","(%p,%p)",
+					  row, type);
 
 	/* Step 1: grab data from the row. */
 	value = utils_string_to_hex(row[3], &length);
@@ -3076,7 +3116,7 @@ blob_t* db_fetch_tdc_entry_from_row(MYSQL_ROW row, amp_type_e *type)
 	/* Step 3: Store the type. */
 	*type = atoi(row[2]);
 
-	AMP_DEBUG_EXIT("db_fetch_tdc_entry_from_row", "-->"ADDR_FIELDSPEC, (uaddr) result);
+	AMP_DEBUG_EXIT("db_fetch_tdc_entry_from_row", "-->%p", result);
 	return result;
 }
 
@@ -3140,7 +3180,7 @@ mid_t *db_fetch_mid(int32_t idx)
 
 	mysql_free_result(res);
 
-	AMP_DEBUG_EXIT("db_fetch_mid", "-->"ADDR_FIELDSPEC, (uaddr) result);
+	AMP_DEBUG_EXIT("db_fetch_mid", "-->%p", result);
 	return result;
 }
 
@@ -3209,7 +3249,7 @@ Lyst db_fetch_mid_col(int idx)
 	/* Step 3: Free database resources. */
 	mysql_free_result(res);
 
-	AMP_DEBUG_EXIT("db_fetch_mid_col", "-->"ADDR_FIELDSPEC, (uaddr) result);
+	AMP_DEBUG_EXIT("db_fetch_mid_col", "-->%p", result);
 	return result;
 }
 
@@ -3236,7 +3276,7 @@ mid_t* db_fetch_mid_from_row(MYSQL_ROW row)
 	oid_t oid;
 	mid_t *result = NULL;
 
-	AMP_DEBUG_ENTRY("db_fetch_mid_from_row", "("ADDR_FIELDSPEC")", (uaddr)row);
+	AMP_DEBUG_ENTRY("db_fetch_mid_from_row", "(%p)", row);
 
 	/* Step 0: Sanity check. */
 	if(row == NULL)
@@ -3255,8 +3295,8 @@ mid_t* db_fetch_mid_from_row(MYSQL_ROW row)
 	uint8_t issFlag   = (row[6] == NULL) ? 0 : atoi(row[6]);
 	uint8_t tagFlag   = (row[7] == NULL) ? 0 : atoi(row[7]);
 	uint8_t oidType   = (row[8] == NULL) ? 0 : atoi(row[8]);
-	uvast issuer      = (uvast) (row[9] == NULL) ? 0 : atoll(row[9]);
-	uvast tag         = (uvast) (row[10] == NULL) ? 0 : atoll(row[10]);
+	amp_uvast issuer      = (amp_uvast) (row[9] == NULL) ? 0 : atoll(row[9]);
+	amp_uvast tag         = (amp_uvast) (row[10] == NULL) ? 0 : atoll(row[10]);
 	uint32_t dtype    = (row[11] == NULL) ? 0 : atoi(row[11]);
  	uint32_t mid_type = 0;
 
@@ -3308,7 +3348,7 @@ mid_t* db_fetch_mid_from_row(MYSQL_ROW row)
 		result = NULL;
 	}
 
-	AMP_DEBUG_EXIT("db_fetch_mid_from_row","-->"ADDR_FIELDSPEC, (uaddr)result);
+	AMP_DEBUG_EXIT("db_fetch_mid_from_row","-->%p", result);
 	return result;
 }
 
@@ -3341,7 +3381,7 @@ int32_t db_fetch_mid_idx(mid_t *mid)
 	MYSQL_RES *res = NULL;
 	MYSQL_ROW row;
 
-	AMP_DEBUG_ENTRY("db_fetch_mid_idx","("ADDR_FIELDSPEC")", (uaddr)mid);
+	AMP_DEBUG_ENTRY("db_fetch_mid_idx","(%p)", mid);
 
 	/* Step 0: Sanity check arguments. */
 	if(mid == NULL)
@@ -3540,8 +3580,8 @@ uint8_t* db_fetch_oid_val(uint32_t idx, uint32_t *size)
 	MYSQL_RES *res = NULL;
 	MYSQL_ROW row;
 
-	AMP_DEBUG_ENTRY("db_fetch_oid_val","(%d,"ADDR_FIELDSPEC")",
-			          idx, (uaddr)size);
+	AMP_DEBUG_ENTRY("db_fetch_oid_val","(%d,%p)",
+			          idx, size);
 
 	/* Step 0: Sanity check. */
 	if((idx == 0) || (size == NULL))
@@ -3823,7 +3863,7 @@ Lyst db_fetch_parms(uint32_t idx)
 	/* Step 4: Free results. */
 	mysql_free_result(res);
 
-	AMP_DEBUG_EXIT("db_fetch_parms", "-->"ADDR_FIELDSPEC, (uaddr)result);
+	AMP_DEBUG_EXIT("db_fetch_parms", "-->%p", result);
 	return result;
 }
 
@@ -3855,7 +3895,7 @@ int32_t db_fetch_protomid_idx(mid_t *mid)
 	MYSQL_RES *res = NULL;
 	MYSQL_ROW row;
 
-	AMP_DEBUG_ENTRY("db_fetch_protomid_idx","("ADDR_FIELDSPEC")", (uaddr)mid);
+	AMP_DEBUG_ENTRY("db_fetch_protomid_idx","(%p)", mid);
 
 	/* Step 0: Sanity check arguments. */
 	if(mid == NULL)
@@ -3921,7 +3961,7 @@ void query_update_msg_group_state(size_t dbidx, int group_id, int is_error) {
    return;
 }
 
-void db_process_outgoing(void) {
+void db_process_outgoing(nmmgr_t *mgr) {
 	msg_grp_t *msg_group = NULL;
 	int group_id;
 	int ts; // TODO: UVAST? TODO: change this to an output (update record) instead of input from record
@@ -3945,7 +3985,7 @@ void db_process_outgoing(void) {
 		}
 
 		// Set timestamp
-		msg_group->time = ts;
+		msg_group->timestamp = amp_tv_from_ctime(OS_TimeFromTotalSeconds(ts), NULL);
 				
 		// Query Group Contents & Build
 		if((db_tx_build_group(group_id, msg_group)) != AMP_OK)
@@ -3958,7 +3998,7 @@ void db_process_outgoing(void) {
 		}
 
 		// Send Group
-		int status = db_tx_msg_group_agents(group_id, msg_group);
+		int status = db_tx_msg_group_agents(mgr, group_id, msg_group);
 		
 		// Update Status (note: outgoing thread does not use transactions)
 		query_update_msg_group_state(DB_CTRL_CON, group_id, status);
@@ -3985,14 +4025,14 @@ int db_query_ari_metadata(db_con_t dbidx, ari_t *ari, uint32_t *metadata_id, uin
 
 	/** Decode values **/
 
-	// Convert name from blob_t to uvast
-	uvast name_idx;
+	// Convert name from blob_t to amp_uvast
+	amp_uvast name_idx;
 
 	// VERIFY: Is this correct? optimal? Do we need to handle cases where name is not numeric?
 	cut_get_cbor_numeric_raw(&(ari->as_reg.name), AMP_TYPE_UVAST, &name_idx);
 
 	//vec_idx_t nn = ari->as_reg.nn_idx;
-	uvast *nn = (uvast *) VDB_FINDIDX_NN(ari->as_reg.nn_idx);
+	amp_uvast *nn = (amp_uvast *) VDB_FINDIDX_NN(ari->as_reg.nn_idx);
 	CHKZERO(nn);
 	int namespace = *nn/20;
 	int adm_type = *nn % 20;
@@ -4112,7 +4152,7 @@ void db_insert_ac_entry(db_con_t dbidx, uint32_t ac_id, size_t idx, uint32_t ari
 	// In the case of an error, it will remain at the default error value of 0
 	if (mysql_stmt_fetch(stmt) != 0)
 	{
-		AMP_DBG_ERR("Failed to Insert AC Entry: %s", mysql_stmt_error(stmt));
+		AMP_DEBUG_ERR("Failed to Insert AC Entry: %s", mysql_stmt_error(stmt));
 		CHKVOID(status);
 		*status = AMP_FAIL;
 		return;
@@ -4143,7 +4183,7 @@ uint32_t db_insert_ac(db_con_t dbidx, ac_t *ac, int *status)
 	// In the case of an error, it will remain at the default error value of 0
 	if (mysql_stmt_fetch(stmt) != 0)
 	{
-		AMP_DBG_ERR("Failed to Create AC: %s", mysql_stmt_error(stmt));
+		AMP_DEBUG_ERR("Failed to Create AC: %s", mysql_stmt_error(stmt));
 		CHKZERO(status);
 		*status = AMP_FAIL;
 		return 0;
@@ -4217,19 +4257,27 @@ void db_insert_tnv(db_con_t dbidx, uint32_t tnvc_id, tnv_t *tnv, int *status)
 		break;
 	case AMP_TYPE_VAST:
 		stmt = queries[dbidx][TNVC_INSERT_VAST];
-		dbprep_bind_param_int(C_VAL, tnv->value.as_vast);
+		//skywalker
+		//dbprep_bind_param_int(C_VAL, tnv->value.as_vast);
+		dbprep_bind_param_bigint(C_VAL, tnv->value.as_vast);
 		break;
 	case AMP_TYPE_TV:
 		stmt = queries[dbidx][TNVC_INSERT_TV];
-		dbprep_bind_param_int(C_VAL, tnv->value.as_uvast);
+		//skywalker
+		//dbprep_bind_param_int(C_VAL, tnv->value.as_uvast);
+		dbprep_bind_param_bigint(C_VAL, tnv->value.as_uvast);
 		break;
 	case AMP_TYPE_TS:
 		stmt = queries[dbidx][TNVC_INSERT_TS];
-		dbprep_bind_param_int(C_VAL, tnv->value.as_uvast);
+		//skywalker
+		//dbprep_bind_param_int(C_VAL, tnv->value.as_uvast);
+		dbprep_bind_param_bigint(C_VAL, tnv->value.as_uvast);
 		break;
 	case AMP_TYPE_UVAST:
 		stmt = queries[dbidx][TNVC_INSERT_UVAST];
-		dbprep_bind_param_int(C_VAL, tnv->value.as_uvast);
+		//skywalker
+		//dbprep_bind_param_int(C_VAL, tnv->value.as_uvast);
+		dbprep_bind_param_bigint(C_VAL, tnv->value.as_uvast);
 		break;
 	case AMP_TYPE_REAL32:
 		stmt = queries[dbidx][TNVC_INSERT_REAL32];
@@ -4283,7 +4331,7 @@ void db_insert_tnv(db_con_t dbidx, uint32_t tnvc_id, tnv_t *tnv, int *status)
 	// In the case of an error, it will remain at the default error value of 0
 	if (mysql_stmt_fetch(stmt) != 0)
 	{
-		AMP_DBG_ERR("Failed to Create TNV: %s", mysql_stmt_error(stmt));
+		AMP_DEBUG_ERR("Failed to Create TNV: %s", mysql_stmt_error(stmt));
 		CHKVOID(status);
 		*status = AMP_FAIL;
 		return;
@@ -4345,7 +4393,7 @@ uint32_t db_insert_tnvc(db_con_t dbidx, tnvc_t *tnvc, int *status)
 	// In the case of an error, it will remain at the default error value of 0
 	if (mysql_stmt_fetch(stmt) != 0)
 	{
-		AMP_DBG_ERR("Failed to Create TNVC: %s", mysql_stmt_error(stmt));
+		AMP_DEBUG_ERR("Failed to Create TNVC: %s", mysql_stmt_error(stmt));
 		CHKZERO(status);
 		*status = AMP_FAIL;
 		return 0;
@@ -4408,7 +4456,7 @@ void db_insert_msg_rpt_set_rpt(db_con_t dbidx, uint32_t entry_id, rpt_t* rpt, in
 	// In the case of an error, it will remain at the default error value of 0
 	if (mysql_stmt_fetch(stmt) != 0)
 	{
-		AMP_DBG_ERR("Failed to Create Entry: %s", mysql_stmt_error(stmt));
+		AMP_DEBUG_ERR("Failed to Create Entry: %s", mysql_stmt_error(stmt));
 		CHKVOID(status);
 		*status = AMP_FAIL;
 		return;
@@ -4473,7 +4521,7 @@ uint32_t db_insert_msg_reg_agent(uint32_t grp_id, msg_agent_t *msg, int *status)
 	// In the case of an error, it will remain at the default error value of 0
 	if (mysql_stmt_fetch(stmt) != 0)
 	{
-		AMP_DBG_ERR("Failed to Create Entry: %s", mysql_stmt_error(stmt));
+		AMP_DEBUG_ERR("Failed to Create Entry: %s", mysql_stmt_error(stmt));
 		CHKZERO(status);
 		*status = AMP_FAIL;
 		return 0;
diff --git a/nm/mgr/nm_mgr_sql.h b/nm/mgr/nm_mgr_sql.h
index 9fba2ac2..2c2a494f 100644
--- a/nm/mgr/nm_mgr_sql.h
+++ b/nm/mgr/nm_mgr_sql.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  ** \file nm_mgr_db.h
  **
@@ -29,32 +41,37 @@
  *****************************************************************************/
 #ifdef HAVE_MYSQL
 
-#ifndef NM_MGR_DB_H
-#define NM_MGR_DB_H
+#ifndef NM_MGR_SQL_H
+#define NM_MGR_SQL_H
 
 /* System Headers */
-#include "stdio.h"
-#include "unistd.h"
+#include <stdio.h>
+#include <unistd.h>
 #include <mysql.h>
 
-/* ION headers. */
-#include "platform.h"
+#include "shared/platform.h"
 
 /* Application headers. */
-#include "../shared/adm/adm.h"
-#include "../shared/msg/ion_if.h"
-#include "../shared/msg/msg.h"
-#include "../shared/primitives/report.h"
-#include "../shared/primitives/rules.h"
-#include "../shared/primitives/ctrl.h"
-
-#include "../shared/utils/db.h"
-#include "../shared/utils/utils.h"
-#include "../shared/utils/vector.h"
-
-#include "nm_mgr_ui.h"
+#include "shared/adm/adm.h"
+#include "shared/msg/msg_if.h"
+#include "shared/msg/msg.h"
+#include "shared/primitives/report.h"
+#include "shared/primitives/rules.h"
+#include "shared/primitives/ctrl.h"
+
+#include "shared/utils/db.h"
+#include "shared/utils/utils.h"
+#include "shared/utils/vector.h"
+
+//#include "nm_mgr_ui.h"
 #include "agents.h"
 
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
@@ -125,7 +142,7 @@
  */
 typedef struct
 {
-    ResourceLock lock;
+    pthread_mutex_t lock;
 
 	char server[UI_SQL_SERVERLEN];
 	char username[UI_SQL_ACCTLEN];
@@ -145,7 +162,7 @@ typedef struct
 int32_t db_add_agent(eid_t agent_eid);
 
 /* Database Management Functions. */
-void    *db_mgt_daemon(int *running);
+void    *db_mgt_daemon(void *arg);
 uint32_t db_mgt_init(sql_db_t parms, uint32_t clear, uint32_t log);
 uint32_t db_mgt_init_con(size_t idx, sql_db_t parms);
 
@@ -174,7 +191,7 @@ int      db_tx_collect_agents(int32_t grp_idx, vector_t *vec);
 
 
 /* Functions to process incoming messages. */
-uint32_t db_incoming_initialize(time_t timestamp, eid_t sender_eid);
+uint32_t db_incoming_initialize(amp_tv_t timestamp, eid_t sender_eid);
 int32_t db_incoming_finalize(uint32_t incomingID, uint32_t grp_status, char* src_eid, char* raw_input);
 uint32_t db_insert_msg_reg_agent(uint32_t grp_id, msg_agent_t *msg, int *status);
 uint32_t db_insert_msg_rpt_set(uint32_t grp_id, msg_rpt_t *rpt, int *status);
@@ -240,8 +257,15 @@ void db_logf_msg(size_t dbidx, const char* msg, const char* details, int level,
 #define DB_LOGF_WARN(dbidx,msg,details,...) DB_LOGF_MSG(dbidx,msg,details,AMP_DEBUG_LVL_WARN, __VA_ARGS__)
 #define DB_LOGF_ERR(dbidx,msg,details,...) DB_LOGF_MSG(dbidx,msg,details,AMP_DEBUG_LVL_ERR, __VA_ARGS__)
 
-	
-#endif // HDR
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* NM_MGR_SQL_H */
+
 #endif // HAVE_MYSQL
 
 
+
diff --git a/nm/mgr/nm_mgr_ui.c b/nm/mgr/nm_mgr_ui.c
index 0f877909..98e83a1e 100644
--- a/nm/mgr/nm_mgr_ui.c
+++ b/nm/mgr/nm_mgr_ui.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file nm_mgr_ui.c
@@ -30,8 +42,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
+#include <inttypes.h>
 
-#include "platform.h"
+#include "shared/platform.h"
 #include "../shared/nm.h"
 #include "../shared/utils/utils.h"
 #include "../shared/adm/adm.h"
@@ -40,6 +53,7 @@
 #include "../shared/msg/msg.h"
 
 #include "nm_mgr_ui.h"
+#include "nmmgr.h"
 #include "ui_input.h"
 #include "nm_mgr_print.h"
 #include "metadata.h"
@@ -134,31 +148,24 @@ char *db_menu_choices[] = {
    "Read DB Info from file"
 };
 form_fields_t db_conn_form_fields[] = {
-   {"Database Server", gMgrDB.sql_info.server, UI_SQL_SERVERLEN-1, 0, 0},
-   {"Database Name", gMgrDB.sql_info.database, UI_SQL_DBLEN-1, 0, 0},
-   {"Database Username", gMgrDB.sql_info.username, UI_SQL_ACCTLEN-1, 0, 0},
-   {"Database Password", gMgrDB.sql_info.password, UI_SQL_ACCTLEN-1, 0, 0}
+   {"Database Server", gMgrDB.sql_info.server, UI_SQL_SERVERLEN-1, 0, 0, NULL},
+   {"Database Name", gMgrDB.sql_info.database, UI_SQL_DBLEN-1, 0, 0, NULL},
+   {"Database Username", gMgrDB.sql_info.username, UI_SQL_ACCTLEN-1, 0, 0, NULL},
+   {"Database Password", gMgrDB.sql_info.password, UI_SQL_ACCTLEN-1, 0, 0, NULL}
 };
 
 #endif
 
-#ifdef USE_NCURSES
-#define MGR_UI_DEFAULT MGR_UI_NCURSES
-#else
-#define MGR_UI_DEFAULT MGR_UI_STANDARD
-#endif
-
-int gContext;
-int *global_nm_running = NULL;
-mgr_ui_mode_enum mgr_ui_mode = MGR_UI_DEFAULT;
+//FIXME clean this up
+nmmgr_t *global_mgr = NULL;
 
 /* Prototypes */
-void ui_eventLoop(int *running);
-void ui_ctrl_list_menu(int *running);
+static void ui_eventLoop(nmmgr_t *mgr);
+static void ui_ctrl_list_menu(nmmgr_t *mgr);
 
 #ifdef HAVE_MYSQL
-void ui_db_menu(int *running);
-void ui_db_parms(int do_edit);
+static void ui_db_menu(nmmgr_t *mgr);
+static void ui_db_parms(int do_edit);
 #endif
 
 #ifdef USE_NCURSES
@@ -192,11 +199,11 @@ void ui_log_transmit_msg(agent_t* agent, msg_ctrl_t *msg) {
 int ui_build_control(agent_t* agent)
 {
 	ari_t *id = NULL;
-	uvast ts;
+	amp_uvast ts;
 	msg_ctrl_t *msg;
     int rtv;
 
-	AMP_DEBUG_ENTRY("ui_build_control","("ADDR_FIELDSPEC")", (uaddr)agent);
+	AMP_DEBUG_ENTRY("ui_build_control","(%p)", agent);
 
     if (agent == NULL)
     {
@@ -241,9 +248,10 @@ int ui_build_control(agent_t* agent)
 
 	if((msg = msg_ctrl_create_ari(id)) != NULL)
 	{
-		msg->start = ts;
+	  OS_time_t timestamp = OS_TimeFromTotalSeconds(ts);
+		msg->start = amp_tv_from_ctime(timestamp, NULL);
         ui_log_transmit_msg(agent, msg);
-		rtv = iif_send_msg(&ion_ptr, MSG_TYPE_PERF_CTRL, msg, agent->eid.name);
+		rtv = mif_send_msg(&global_mgr->mif, MSG_TYPE_PERF_CTRL, msg, &agent->eid, AMP_TV_ZERO);
 		msg_ctrl_release(msg, 1);
         return rtv;
 	}
@@ -390,8 +398,8 @@ rule_t *ui_create_tbr_from_parms(tnvc_t parms)
 	int success;
 
 	ari_t *id = adm_get_parm_obj(&parms, 0, AMP_TYPE_ARI);
-	uvast start = adm_get_parm_uvast(&parms, 1, &success);
-	def.period = adm_get_parm_uvast(&parms, 2, &success);
+	OS_time_t start = amp_tv_to_ctime(adm_get_parm_tv(&parms, 1, &success), NULL);
+	def.period = amp_tv_to_ctime(adm_get_parm_tv(&parms, 2, &success), NULL);
 	def.max_fire = adm_get_parm_uvast(&parms, 3, &success);
 	ac_t action = ac_copy(adm_get_parm_obj(&parms, 4, AMP_TYPE_AC));
 
@@ -411,7 +419,7 @@ rule_t *ui_create_sbr_from_parms(tnvc_t parms)
 	int success;
 
 	ari_t *id = adm_get_parm_obj(&parms, 0, AMP_TYPE_ARI);
-	uvast start = adm_get_parm_uvast(&parms, 1, &success);
+        OS_time_t start = amp_tv_to_ctime(adm_get_parm_tv(&parms, 1, &success), NULL);
 	expr_t *state = adm_get_parm_obj(&parms, 2, AMP_TYPE_EXPR);
 	def.expr = *state;
 	SRELEASE(state);
@@ -598,13 +606,13 @@ int ui_automator_parse_input(char *str)
       if (strncmp(token, "EXIT_UI", 8) == 0)
       {
          // To minimize errors in automation, the full string must match to exit to standard UI
-         mgr_ui_mode = MGR_UI_DEFAULT;
+         global_mgr->mgr_ui_mode = MGR_UI_DEFAULT;
          return 1;
       }
       else if (strncmp(token, "EXIT_SHUTDOWN", 16) == 0)
       {
          printf("Signaling Manager Shutdown . . . \n");
-         *global_nm_running = 0;
+         daemon_run_stop(&global_mgr->running);
          return 1;
       }
       break;
@@ -642,9 +650,9 @@ int ui_automator_parse_input(char *str)
          ari_release(id, 1);
          return 0;
       }
-      msg->start = ts;
+      msg->start = amp_tv_from_ctime(OS_TimeFromTotalSeconds(ts), NULL);
       ui_log_transmit_msg(agent, msg);
-      iif_send_msg(&ion_ptr, MSG_TYPE_PERF_CTRL, msg, agent->eid.name);
+      mif_send_msg(&global_mgr->mif, MSG_TYPE_PERF_CTRL, msg, &agent->eid, AMP_TV_ZERO);
       msg_ctrl_release(msg, 1);
       break;
    case 'L': // List Agents
@@ -692,25 +700,27 @@ int ui_automator_parse_input(char *str)
    
    return 1;
 }
-void ui_automator_run(int *running)
+
+static void ui_automator_run(nmmgr_t *mgr)
 {
    char line[MAX_INPUT_BYTES];
-   int len;
+   size_t len;
 
-   while(mgr_ui_mode == MGR_UI_AUTOMATOR && *running)
+   while((mgr->mgr_ui_mode == MGR_UI_AUTOMATOR) && daemon_run_get(&mgr->running))
    {
       // Print prompt
       printf("\n#-NM->");
       fflush(stdout); // Show the prompt without a newline
 
       // Read Input Line
-      if(igets(fileno(stdin), line, MAX_INPUT_BYTES, &len) == NULL)
+      if(fgets(line, MAX_INPUT_BYTES, stdin) == NULL)
       {
-         AMP_DEBUG_ERR("ui_automator_run", "igets failed.", NULL);
+         AMP_DEBUG_ERR("ui_automator_run", "fgets failed.", NULL);
          return;
       }
 
       // Parse & Execute Line
+      len = strlen(line);
       if (len > 0)
       {
          if (ui_automator_parse_input(line) != 1)
@@ -734,7 +744,7 @@ void ui_automator_run(int *running)
  *  --------  ------------   ---------------------------------------------
  *  10/15/18  D.Edell        Initial NCURSES implementation based on original UI
  *****************************************************************************/
-void ui_eventLoop(int *running)
+void ui_eventLoop(nmmgr_t *mgr)
 {
    int choice; // Last user menu selection
    char msg[128] = ""; // User (error) message to append to menu
@@ -743,11 +753,11 @@ void ui_eventLoop(int *running)
    
    ui_init();
    
-   while(*running)
+   while(daemon_run_get(&mgr->running))
    {
-      if (mgr_ui_mode == MGR_UI_AUTOMATOR)
+      if (mgr->mgr_ui_mode == MGR_UI_AUTOMATOR)
       {
-         ui_automator_run(running);
+         ui_automator_run(mgr);
       }
       else
       {
@@ -756,7 +766,7 @@ void ui_eventLoop(int *running)
       
          if (choice == MAIN_MENU_EXIT)
          {
-            *running = 0;
+            daemon_run_stop(&mgr->running);
             break;
          } else {
             switch(choice)
@@ -778,11 +788,11 @@ void ui_eventLoop(int *running)
                }
                break;
             case MAIN_MENU_LIST_AMM: // List Object Information (old Control Menu merged with Admmin Menu's List Agents)
-               ui_ctrl_list_menu(running);
+               ui_ctrl_list_menu(mgr);
                break;
 #ifdef HAVE_MYSQL
             case MAIN_MENU_DB: // DB
-               ui_db_menu(running);
+               ui_db_menu(mgr);
                break;
 #endif
 #ifdef USE_NCURSES // Log file is currently written to only when NCURSES is enabled
@@ -795,7 +805,7 @@ void ui_eventLoop(int *running)
                ui_log_cfg_menu();
                break;
             case MAIN_MENU_AUTOMATOR_UI:
-               mgr_ui_mode = MGR_UI_AUTOMATOR;
+              global_mgr->mgr_ui_mode = MGR_UI_AUTOMATOR;
                printf("Switching to alternate AUTOMATOR interface. Type 'EXIT_UI' to return to this menu, '?' for usage.");
                break;
             default:
@@ -810,7 +820,7 @@ void ui_eventLoop(int *running)
 }
 
 // this is a mess. clean it up.
-void ui_list_objs(uint8_t adm_id, uvast mask, ari_t **result)
+void ui_list_objs(uint8_t adm_id, amp_uvast mask, ari_t **result)
 {
    char title[100];
    ui_menu_list_t *list;
@@ -970,7 +980,7 @@ void ui_postprocess_ctrl(ari_t *id)
 
 			if(var != NULL)
 			{
-				db_forget(&(var->desc), gDB.vars);
+//FIXME:			db_forget(&(var->desc), gDB.vars);
 				VDB_DELKEY_VAR(id);
 			}
 			else
@@ -1006,7 +1016,7 @@ void ui_postprocess_ctrl(ari_t *id)
 
 			if(def != NULL)
 			{
-				db_forget(&(def->desc), gDB.rpttpls);
+//FIXME				db_forget(&(def->desc), gDB.rpttpls);
 				VDB_DELKEY_RPTT(id);
 			}
 			else
@@ -1041,7 +1051,7 @@ void ui_postprocess_ctrl(ari_t *id)
 
 			if(def != NULL)
 			{
-				db_forget(&(def->desc), gDB.macdefs);
+//FIXME				db_forget(&(def->desc), gDB.macdefs);
 				VDB_DELKEY_MACDEF(mac_id);
 			}
 			else
@@ -1095,7 +1105,7 @@ void ui_postprocess_ctrl(ari_t *id)
 
 			if(def != NULL)
 			{
-				db_forget(&(def->desc), gDB.rules);
+//FIXME				db_forget(&(def->desc), gDB.rules);
 				VDB_DELKEY_RULE(rule_id);
 			}
 			else
@@ -1142,7 +1152,7 @@ void ui_register_agent(char* msg)
 #else
     memset(line,0, AMP_MAX_EID_LEN);
 	/* Grab the new agent's EID. */
-	if(ui_input_get_line("Enter EID of new agent:", (char **)&line, AMP_MAX_EID_LEN-1) == 0)
+	if(ui_input_get_line("Enter EID of new agent:", line, AMP_MAX_EID_LEN-1) == 0)
 	{
 #endif
 		AMP_DEBUG_ERR("register_agent","Unable to read user input.", NULL);
@@ -1335,9 +1345,9 @@ void ui_send_file(agent_t* agent, uint8_t enter_ts)
            return;
 		}
 
-		msg->start = ts;
+		msg->start = amp_tv_from_ctime(OS_TimeFromTotalSeconds(ts), NULL);
         ui_log_transmit_msg(agent, msg);
-		iif_send_msg(&ion_ptr, MSG_TYPE_PERF_CTRL, msg, agent->eid.name);
+        mif_send_msg(&global_mgr->mif, MSG_TYPE_PERF_CTRL, msg, &agent->eid, AMP_TV_ZERO);
 
 		msg_ctrl_release(msg, 1);
 		cursor = strtok_r(NULL, "\n", &saveptr);
@@ -1376,22 +1386,23 @@ void ui_send_raw(agent_t* agent, uint8_t enter_ts)
 		ari_release(id, 1);
 		return;
 	}
-	msg->start = ts;
+	msg->start = amp_tv_from_ctime(OS_TimeFromTotalSeconds(ts), NULL);
     ui_log_transmit_msg(agent, msg);
-	iif_send_msg(&ion_ptr, MSG_TYPE_PERF_CTRL, msg, agent->eid.name);
+    mif_send_msg(&global_mgr->mif, MSG_TYPE_PERF_CTRL, msg, &agent->eid, AMP_TV_ZERO);
 
 	msg_ctrl_release(msg, 1);
 }
 
 
-void *ui_thread(int *running)
+void *ui_thread(void *arg)
 {
-	AMP_DEBUG_ENTRY("ui_thread","(0x%x)", (size_t) running);
+  nmmgr_t *mgr = arg;
+  AMP_DEBUG_ENTRY("ui_thread","mgr (%p)", mgr);
 
     // Cache running as an NM UI Global for simplicity. This is always the entrypoint to ui
-    global_nm_running = running;
+    global_mgr = mgr;
 
-	ui_eventLoop(running);
+	ui_eventLoop(mgr);
 
 	AMP_DEBUG_ALWAYS("ui_thread","Exiting.", NULL);
 
@@ -1410,14 +1421,14 @@ void *ui_thread(int *running)
 
 #ifdef HAVE_MYSQL
 
-void ui_db_menu(int *running)
+void ui_db_menu(nmmgr_t *mgr)
 {
    int n_choices = ARRAY_SIZE(db_menu_choices);
    int choice;
    int new_msg = 0;
    char msg[128] = "";
    
-   while(*running)
+   while(daemon_run_get(&mgr->running))
    {
       choice = ui_menu("Database Menu", db_menu_choices, NULL, n_choices,
                        ((new_msg==0) ? NULL : msg)
@@ -1489,11 +1500,11 @@ int ui_db_conn()
 
 	memset(&parms, 0, sizeof(sql_db_t));
 
-	lockResource(&(gMgrDB.sql_info.lock));
+	pthread_mutex_lock(&(gMgrDB.sql_info.lock));
 
 	memcpy(&parms, &(gMgrDB.sql_info), sizeof(sql_db_t));
 
-	unlockResource(&(gMgrDB.sql_info.lock));
+	pthread_mutex_unlock(&(gMgrDB.sql_info.lock));
 
 	return db_mgt_init(parms, 0, 1);
 }
@@ -1519,14 +1530,14 @@ void ui_db_write()
   }
 
 
- lockResource(&(gMgrDB.sql_info.lock));
+ pthread_mutex_lock(&(gMgrDB.sql_info.lock));
 
  fwrite(&(gMgrDB.sql_info.server), UI_SQL_SERVERLEN-1, 1, fp);
  fwrite(&(gMgrDB.sql_info.database), UI_SQL_DBLEN-1, 1, fp);
  fwrite(&(gMgrDB.sql_info.username), UI_SQL_ACCTLEN-1,1, fp);
  fwrite(&(gMgrDB.sql_info.password), UI_SQL_ACCTLEN-1,1, fp);
 
- unlockResource(&(gMgrDB.sql_info.lock));
+ pthread_mutex_unlock(&(gMgrDB.sql_info.lock));
 
 fclose(fp);
   printf("Database infor written to %s.\n", tmp);
@@ -1553,7 +1564,7 @@ void ui_db_read()
     return;
   }
 
-  lockResource(&(gMgrDB.sql_info.lock));
+  pthread_mutex_lock(&(gMgrDB.sql_info.lock));
 
   if(fread(&(gMgrDB.sql_info.server), UI_SQL_SERVERLEN-1, 1, fp) <= 0)
     printf("Error reading server.\n");
@@ -1569,7 +1580,7 @@ void ui_db_read()
  
   db_mgr_sql_persist();
 
-  unlockResource(&(gMgrDB.sql_info.lock));
+  pthread_mutex_unlock(&(gMgrDB.sql_info.lock));
   fclose(fp);
 
   printf("Read from %s.\n", tmp);
@@ -1583,7 +1594,7 @@ void ui_db_parms(int do_edit)
    int n_choices = ARRAY_SIZE(db_conn_form_fields);
    if (do_edit)
    {
-      lockResource(&(gMgrDB.sql_info.lock));
+      pthread_mutex_lock(&(gMgrDB.sql_info.lock));
    }
 
    for(i = 0; i < n_choices; i++)
@@ -1609,7 +1620,7 @@ void ui_db_parms(int do_edit)
    if (do_edit)
    {
       db_mgr_sql_persist();
-      unlockResource(&(gMgrDB.sql_info.lock));
+      pthread_mutex_unlock(&(gMgrDB.sql_info.lock));
    }
 
 }
@@ -1631,14 +1642,14 @@ int ui_db_clear_rpt()
 
 #endif
 
-void ui_ctrl_list_menu(int *running)
+void ui_ctrl_list_menu(nmmgr_t *mgr)
 {
    int choice;
    int n_choices = ARRAY_SIZE(ctrl_menu_list_choices);
    char msg[128] = "";
    int new_msg = 0, i;
    char *ctrl_menu_list_descriptions[10];
-   uvast mask = 0;
+   amp_uvast mask = 0;
 
    ctrl_menu_list_descriptions[0] = NULL;
    for(i = 1; i < 10; i++)
@@ -1656,7 +1667,7 @@ void ui_ctrl_list_menu(int *running)
    sprintf(ctrl_menu_list_descriptions[9], "(%d known)",  gVDB.vars.num_elts);
    
 
-   while(*running)
+   while(daemon_run_get(&mgr->running))
    {
       choice = ui_menu("ADM Object Information Lists", ctrl_menu_list_choices, ctrl_menu_list_descriptions, n_choices, 
                        ((new_msg==0) ? NULL : msg)
@@ -1760,7 +1771,7 @@ void ui_fprintf(ui_print_cfg_t *fd, const char* format, ...)
       {
          vfprintf(fd->fd, format, args);
       }
-#ifdef USE_CIVETWEB
+#if defined(USE_CIVETWEB) && 0
       else if (fd->conn != NULL)
       {
          mg_vprintf(fd->conn, format, args);
@@ -2487,7 +2498,7 @@ int ui_menu(char* title, char** choices, char** descriptions, int n_choices, cha
 	post_menu(my_menu);
 	wrefresh(my_menu_win);
 
-	while(*global_nm_running && running && (c = wgetch(my_menu_win)) != KEY_F(1))
+	while(daemon_run_get(&global_mgr->running) && running && (c = wgetch(my_menu_win)) != KEY_F(1))
 	{
        show_panel(my_pan);
        update_panels();
@@ -2636,7 +2647,7 @@ int ui_menu_listing(
        set_current_item(my_menu, my_items[i]);
     }
 
-	while(running && *global_nm_running)
+	while(running && daemon_run_get(&global_mgr->running))
 	{
        i = item_index(current_item(my_menu));
 
@@ -2903,7 +2914,7 @@ int ui_menu(char* title, char** choices, char** descriptions, int n_choices, cha
    int i;
    ui_display_init(title);
 
-   while(*global_nm_running) {
+   while(daemon_run_get(&global_mgr->running)) {
 
       for(i = 0; i < n_choices; i++)
       {
@@ -2945,7 +2956,7 @@ int ui_menu_listing(
    int running = 1;
    char line[20];
 
-   while(running && *global_nm_running)
+   while(running && daemon_run_get(&global_mgr->running))
    {
       ui_display_init(title);
 
@@ -3299,7 +3310,7 @@ static int do_ui_form(char* title, char* msg, form_fields_t *fields, int num_fie
 
       // Prompt User for input
       while(1) {
-         int len;
+         size_t len;
          
          switch(field->type) {
             case TYPE_CHECK_INT:
@@ -3313,7 +3324,7 @@ static int do_ui_form(char* title, char* msg, form_fields_t *fields, int num_fie
             printf(":->");
          }
          fflush(stdout);
-         if (igets(STDIN_FILENO, in, UI_FORM_LEN, &len) == NULL || len == 0)
+         if (fgets(in, UI_FORM_LEN, stdin) == NULL || (len = strlen(in)) == 0)
          {          
             if (field->parsed_value != NULL || (field->value != NULL && strlen(field->value) > 0) )
             {
diff --git a/nm/mgr/nm_mgr_ui.h b/nm/mgr/nm_mgr_ui.h
index 1599d980..492ae73e 100644
--- a/nm/mgr/nm_mgr_ui.h
+++ b/nm/mgr/nm_mgr_ui.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file nm_mgr_ui.h
@@ -32,13 +44,19 @@
 #ifndef _NM_MGR_UI_H
 #define _NM_MGR_UI_H
 
-#include "nm_mgr.h"
 #include "agents.h"
 
 #include "../shared/utils/nm_types.h"
 #include "../shared/adm/adm.h"
 #include "../shared/primitives/report.h"
 #include "../shared/primitives/rules.h"
+#include "nmmgr.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 
 #define NM_LOG_FILE "nm_mgr.log"
 
@@ -63,15 +81,6 @@
 #define UI_DB_MENU	  3
 
 
-typedef enum mgr_ui_mode_enum {
-   MGR_UI_STANDARD, // Standard Shell-Based UI
-   MGR_UI_NCURSES, // NCURSES-Based UI (currently a compile-time flag mutually exclusive with MGR_UI_STANDARD)
-   MGR_UI_AUTOMATOR, // Special Altenrative UI Optimized for Automation
-} mgr_ui_mode_enum;
-extern mgr_ui_mode_enum mgr_ui_mode;
-
-extern int gContext;
-
 int ui_build_control(agent_t* agent);
 void ui_clear_reports(agent_t* agent);
 void ui_clear_tables(agent_t* agent);
@@ -86,7 +95,7 @@ rule_t *ui_create_tbr_from_parms(tnvc_t parms);
 void ui_deregister_agent();
 void ui_event_loop();
 
-void ui_list_objs(uint8_t adm_id, uvast mask, ari_t **result);
+void ui_list_objs(uint8_t adm_id, amp_uvast mask, ari_t **result);
 
 void ui_postprocess_ctrl(ari_t *id);
 
@@ -105,7 +114,7 @@ int ui_menu_ctrl_do(uint8_t choice);
 void ui_menu_ctrl_show();
 
 void ui_print_nop();
-void *ui_thread(int *running);
+void *ui_thread(void *arg);
 
 #ifdef HAVE_MYSQL
 int ui_menu_sql_do(uint8_t choice);
@@ -334,4 +343,8 @@ void ui_display_init(char* title);
 /** Log information on transmitted messages (dependent on logging settings) */
 void ui_log_transmit_msg(agent_t* agent, msg_ctrl_t *msg);
 
-#endif // _NM_MGR_UI_H
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _NM_MGR_UI_H */
diff --git a/nm/mgr/nm_rest.c b/nm/mgr/nm_rest.c
index 72b63294..7b12ef38 100644
--- a/nm/mgr/nm_rest.c
+++ b/nm/mgr/nm_rest.c
@@ -1,3 +1,21 @@
+/*
+ * Copyright (c) 2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 
 // System includes
 #ifdef _WIN32
@@ -11,18 +29,18 @@
 #include <time.h>
 
 // CivetWeb includes
-#include "cJSON.h"
-#include "civetweb.h"
+#include <cjson/cJSON.h>
+#include <civetweb.h>
 #include "nm_rest.h"
 
 // NM Includes
-#include "../shared/nm.h"
+#include "shared/nm.h"
+#include "shared/utils/debug.h"
 #include "agents.h"
-#include "nm_mgr.h"
+#include "nmmgr.h"
 #include "nm_mgr_ui.h"
 #include "nm_mgr_print.h"
 
-#include "ion.h" // Used only to retrieve IONVERSIONNUMBER for reference
 
 struct mg_context *ctx;
 
@@ -59,27 +77,24 @@ SendJSON(struct mg_connection *conn, cJSON *json_obj)
 	return (int)json_str_len;
 }
 
-static void start_text_page(struct mg_connection *conn, char* msg, ...)
+static void start_text_page(struct mg_connection *conn)
 {
-   va_list args;
-   va_start(args, msg);
    mg_printf(conn,
-             "HTTP/1.1 200 OK\r\nContent-Type: "
-             "text/plain\r\nConnection: close\r\n\r\n");
-   mg_vprintf(conn, msg, args);
-   va_end(args);
+             "HTTP/1.1 200 OK\r\n"
+             "Content-Type: text/plain\r\n"
+             "Connection: close\r\n"
+             "\r\n");
 }
 
 
 int
 log_message(const struct mg_connection *conn, const char *message)
 {
-   // TODO: Wrap with AMP macro for logging
-	puts(message);
-	return 1;
+  AMP_DEBUG_INFO("nm_rest", message);
+  return 1;
 }
 
-int nm_rest_start()
+int nm_rest_start(nmmgr_t *mgr)
 {
 	const char *options[] = {"listening_ports",
 	                         PORT,
@@ -129,7 +144,7 @@ int nm_rest_start()
 	callbacks.log_message = log_message;
 
 	/* Start CivetWeb web server */
-	ctx = mg_start(&callbacks, 0, options);
+	ctx = mg_start(&callbacks, mgr, options);
 
 	/* Check return value: */
 	if (ctx == NULL) {
@@ -165,17 +180,17 @@ static int versionHandler(struct mg_connection *conn, void *cbdata)
 
    if (0 != strcmp(ri->request_method, "GET")) {
       	mg_send_http_error(conn,
-                           405,
+                           HTTP_METHOD_NOT_ALLOWED,
                            "Only GET method supported for this page");
-        return 405;
+        return HTTP_METHOD_NOT_ALLOWED;
    }
    
    obj = cJSON_CreateObject();
 
 	if (!obj) {
 		/* insufficient memory? */
-		mg_send_http_error(conn, 500, "Server error");
-		return 500;
+		mg_send_http_error(conn, HTTP_INTERNAL_ERROR, "Server error");
+		return HTTP_INTERNAL_ERROR;
 	}
 
 
@@ -199,7 +214,7 @@ static int versionHandler(struct mg_connection *conn, void *cbdata)
 	SendJSON(conn, obj);
 	cJSON_Delete(obj);
 
-	return 200;
+	return HTTP_OK;
 }
 
 static int agentsGETHandler(struct mg_connection *conn)
@@ -212,16 +227,16 @@ static int agentsGETHandler(struct mg_connection *conn)
    
    if (!obj) {
       /* insufficient memory? */
-      mg_send_http_error(conn, 500, "Server error");
-      return 500;
+      mg_send_http_error(conn, HTTP_INTERNAL_ERROR, "Server error");
+      return HTTP_INTERNAL_ERROR;
    }
 
    agentList = cJSON_AddArrayToObject(obj, "agents");
    if (agentList == NULL)
    {
       cJSON_Delete(obj);
-      mg_send_http_error(conn, 500, "Server error (can't allocate array for agents)");
-      return 500;
+      mg_send_http_error(conn, HTTP_INTERNAL_ERROR, "Server error (can't allocate array for agents)");
+      return HTTP_INTERNAL_ERROR;
    }
 
 
@@ -249,24 +264,29 @@ static int agentsCreateHandler(struct mg_connection *conn, char *name)
    eid_t agent_eid;
 
    // Sanity-check string length
-   if (name == NULL || strlen(name) > AMP_MAX_EID_LEN-2)
+   if (name == NULL || (strlen(name) > AMP_MAX_EID_LEN-2))
    {
-      mg_send_http_error(conn, 400, "Invalid EID length");
-      return 400;
+      mg_send_http_error(conn, HTTP_BAD_REQUEST, "Invalid EID length");
+      return HTTP_BAD_REQUEST;
    }
    else
    {
-      strcpy(agent_eid.name, name);
-      if (agent_add(agent_eid) == AMP_OK)
-      {
-         mg_send_http_error(conn, 400, "Unable to register agent");
-         return 400;
-      }
-      else
-      {
-         return HTTP_NO_CONTENT;
-      }
+     strcpy(agent_eid.name, name);
+
+     if (agent_add(agent_eid) == AMP_OK)
+     {
+       mg_send_http_ok(conn, NULL, 0);
+       return HTTP_OK;
+     }
+     else
+     {	
+       mg_send_http_error(conn, HTTP_BAD_REQUEST, "Unable to register agent");
+       return HTTP_BAD_REQUEST;
+     }
    }
+
+   mg_send_http_error(conn, HTTP_INTERNAL_ERROR, "Server error");
+   return HTTP_INTERNAL_ERROR;
 }
 
 static int agentsHandler(struct mg_connection *conn, void *cbdata)
@@ -278,61 +298,93 @@ static int agentsHandler(struct mg_connection *conn, void *cbdata)
       return agentsGETHandler(conn);
    } else if (0 == strcmp(ri->request_method, "POST")) {
       char buffer[AMP_MAX_EID_LEN+1];
-      int dlen = mg_read(conn, buffer, sizeof(buffer));
+      int dlen = mg_read(conn, buffer, sizeof(buffer) - 1);
       if ( dlen < 1 ) {
-         mg_send_http_error(conn, 400, "Invalid request body data (expect EID name) %d", dlen);
-         return 400;
+         mg_send_http_error(conn, HTTP_BAD_REQUEST, "Invalid request body data (expect EID name) %d", dlen);
+         return HTTP_BAD_REQUEST;
       } else {
+         buffer[dlen] = '\0';
          return agentsCreateHandler(conn, buffer);
       }
    } else {
       	mg_send_http_error(conn,
-                           405,
+                           HTTP_METHOD_NOT_ALLOWED,
                            "Only GET and PUT methods supported for this page");
-        return 405;
+        return HTTP_METHOD_NOT_ALLOWED;
    }
 
 }
 
-static int agentSendRaw(struct mg_connection *conn, time_t ts, agent_t *agent, char *hex)
+static int agentSendRaw(struct mg_connection *conn, time_t ts, agent_t *agent, char *hex_sep)
 {
    ari_t *id = NULL;
    msg_ctrl_t *msg = NULL;
    int success;
 
-   blob_t *data = utils_string_to_hex(hex);
-   if (data == NULL) {
+   if((msg = msg_ctrl_create()) == NULL)
+   {
       mg_send_http_error(conn,
-                         500,
-                         "Error creating blob from input");
-      return 500;
+                         HTTP_INTERNAL_ERROR,
+                         "Error creating message");
+      return HTTP_INTERNAL_ERROR;
    }
-   id = ari_deserialize_raw(data, &success);
-   blob_release(data, 1);
-   if (id == NULL) {
+   if((msg->ac = ac_create()) == NULL)
+   {
+      msg_ctrl_release(msg, 1);
       mg_send_http_error(conn,
-                         500,
-                         "Error creating blob from input");
-      return 500;
+                         HTTP_INTERNAL_ERROR,
+                         "Error creating AC");
+      return HTTP_INTERNAL_ERROR;
    }
 
-   
-   ui_postprocess_ctrl(id);
+   msg->start = amp_tv_from_ctime(OS_TimeFromTotalSeconds(ts), NULL);
 
-   if((msg = msg_ctrl_create_ari(id)) == NULL)
-   {
-      ari_release(id, 1);
-      mg_send_http_error(conn,
-                         500,
-                         "Error creating ARI from input");
-      return HTTP_INTERNAL_ERROR;
+   char *part = NULL;
+   const char *ctrlsep = " \f\n\r\t\v"; // Identical to isspace()
+   char *saveptr = NULL;
+   part = strtok_r(hex_sep, ctrlsep, &saveptr);
+   while(part != NULL) {
+      fprintf(stderr, "Handling message part %s\n", part);
+
+      blob_t *data = utils_string_to_hex(part);
+      if (data == NULL) {
+         mg_send_http_error(conn,
+                            HTTP_INTERNAL_ERROR,
+                            "Error creating blob from input");
+         msg_ctrl_release(msg, 1);
+         return HTTP_INTERNAL_ERROR;
+      }
+      id = ari_deserialize_raw(data, &success);
+      blob_release(data, 1);
+      if (id == NULL) {
+         mg_send_http_error(conn,
+                            HTTP_INTERNAL_ERROR,
+                            "Error decoding CTRL");
+         msg_ctrl_release(msg, 1);
+         return HTTP_INTERNAL_ERROR;
+      }
+
+      ui_postprocess_ctrl(id);
+      if(vec_push(&(msg->ac->values), id) != VEC_OK) {
+         mg_send_http_error(conn,
+                            HTTP_INTERNAL_ERROR,
+                            "Error adding CTRL to message");
+         ari_release(id, 1);
+         msg_ctrl_release(msg, 1);
+         return HTTP_INTERNAL_ERROR;
+      }
+
+      part = strtok_r(NULL, ctrlsep, &saveptr);
    }
-   msg->start = ts;
-   iif_send_msg(&ion_ptr, MSG_TYPE_PERF_CTRL, msg, agent->eid.name);
+
+   fprintf(stderr, "Sending message with %d controls\n", ac_get_count(msg->ac));
+   nmmgr_t *mgr = mg_get_user_data(mg_get_context(conn));
+   mif_send_msg(&mgr->mif, MSG_TYPE_PERF_CTRL, msg, &agent->eid, AMP_TV_ZERO);
    ui_log_transmit_msg(agent, msg);
    msg_ctrl_release(msg, 1);
 
-   start_text_page(conn, "Successfully sent Raw ARI Control");
+   start_text_page(conn);
+   mg_printf(conn, "Successfully sent Raw ARI Control");
    return HTTP_OK;
 }
 
@@ -346,8 +398,8 @@ static int agentShowTextReports(struct mg_connection *conn, agent_t *agent)
       return HTTP_INTERNAL_ERROR;
    }
 
-   start_text_page(conn,
-                   "Showing %d reports for agent %s",
+   start_text_page(conn);
+   mg_printf(conn, "Showing %d reports for agent %s",
                    vec_num_entries_ptr(&(agent->rpts)),
                    agent->eid.name);
 
@@ -361,6 +413,31 @@ static int agentShowTextReports(struct mg_connection *conn, agent_t *agent)
 
 }
 
+static int agentShowTextTables(struct mg_connection *conn, agent_t *agent)
+{
+   vecit_t table_it;
+   ui_print_cfg_t fd = INIT_UI_PRINT_CFG_CONN(conn);
+
+   if (agent == NULL)
+   {
+      return HTTP_INTERNAL_ERROR;
+   }
+
+   start_text_page(conn);
+   mg_printf(conn, "Showing %d tables for agent %s \n",
+                   vec_num_entries_ptr(&(agent->tbls)),
+                   agent->eid.name);
+   
+   /* Iterate through all tables for this agent. */
+   for(table_it = vecit_first(&(agent->tbls)); vecit_valid(table_it); table_it = vecit_next(table_it))
+   {
+     ui_fprint_table(&fd, (tbl_t*)vecit_data(table_it));
+   }
+   
+   return HTTP_OK;
+
+}
+
 static int agentShowJSONReports(struct mg_connection *conn, agent_t *agent)
 {
    cJSON *obj;
@@ -391,6 +468,37 @@ static int agentShowJSONReports(struct mg_connection *conn, agent_t *agent)
 
 }
 
+static int agentShowJSONTables(struct mg_connection *conn, agent_t *agent)
+{
+   cJSON *obj;
+   cJSON *tables;
+   vecit_t table_it;
+   ui_print_cfg_t fd = INIT_UI_PRINT_CFG_CONN(conn);
+
+   if (agent == NULL)
+   {
+      return HTTP_INTERNAL_ERROR;
+   }
+
+   obj = cJSON_CreateObject();
+   cJSON_AddStringToObject(obj, "eid", agent->eid.name);
+   tables = cJSON_AddArrayToObject(obj, "tables");
+   
+   /* Iterate through all tables for this agent. */
+   for(table_it = vecit_first(&(agent->tbls)); vecit_valid(table_it); table_it = vecit_next(table_it))
+   {
+      tbl_t *table = ( (tbl_t*)vecit_data(table_it) );
+
+      /* Populate the data in the table */
+      cJSON_AddItemToArray(tables, ui_json_table(table) );
+   }
+
+   SendJSON(conn, obj);
+   cJSON_Delete(obj);
+   return HTTP_OK;
+
+}
+
 static int agentShowRawReports(struct mg_connection *conn, agent_t *agent)
 {
    cJSON *obj;
@@ -426,6 +534,40 @@ static int agentShowRawReports(struct mg_connection *conn, agent_t *agent)
 
 }
 
+
+static int agentShowRawTables(struct mg_connection *conn, agent_t *agent)
+{
+   cJSON *obj;
+   cJSON *tables;
+   vecit_t table_it;
+
+   if (agent == NULL)
+   {
+      return HTTP_INTERNAL_ERROR;
+   }
+   
+   obj = cJSON_CreateObject();
+   cJSON_AddStringToObject(obj, "eid", agent->eid.name);
+   tables = cJSON_AddArrayToObject(obj, "tables");
+   
+   /* Iterate through all tables for this agent. */
+   for(table_it = vecit_first(&(agent->tbls)); vecit_valid(table_it); table_it = vecit_next(table_it))
+   {
+      blob_t *tbl = tbl_serialize_wrapper( (tbl_t*)vecit_data(table_it) );
+      char *tbl_str = utils_hex_to_string(tbl->value, tbl->length);
+
+      cJSON_AddItemToArray(tables, cJSON_CreateStringReference(tbl_str));
+      SRELEASE(tbl_str);
+      blob_release(tbl,1);
+   }
+
+   SendJSON(conn, obj);
+   cJSON_Delete(obj);
+   return HTTP_OK;
+
+}
+
+
 /** Handler for /agents/eid*
  *    Supported requests:
  *    - PUT /agents/eid/$eid/hex - Send HEX-encoded CBOR Command (hex string as request body).
@@ -434,7 +576,11 @@ static int agentShowRawReports(struct mg_connection *conn, agent_t *agent)
  *    - PUT /agents/eid/$eid/clear_tables - Clear all received tables for this agent.
  *    - GET /agents/eid/$eid/reports/hex - Retrieve array of reports in CBOR-encoded HEX form
  *    - GET /agents/eid/$eid/reports/text - Retrieve array of reports in ASCII Text form (same as ui)
+ *    - GET /agents/eid/$eid/reports/json - Retrieve reports in JSON.
  *    - GET /agents/eid/$eid/reports* - Alias for hex reports. format will change in the future.
+ *    - GET /agents/eid/$eid/tables/hex - Retrieve array of tables in CBOR-encoded HEX form
+ *    - GET /agents/eid/$eid/tables/text - Retrieve array of tables in ASCII Text form (same as ui)
+ *    - GET /agents/eid/$eid/tables/json - Retrieve tables in JSON.
  */
 static int agentEidHandler(struct mg_connection *conn, void *cbdata)
 {
@@ -460,21 +606,23 @@ static int agentEidHandler(struct mg_connection *conn, void *cbdata)
       }
       else if (0 == strcmp(cmd, "hex"))
       {
-         // URL idx field translates to agent name
-         // Optional query parameter "ts" will translate to timestamp (TODO: Always 0 for initial cut)
-         // Request body contains CBOR-encoded HEX string
-         char buffer[MAX_INPUT_BYTES];
-         int dlen = mg_read(conn, buffer, sizeof(buffer));
-         if (dlen <= 0) {
-            return HTTP_BAD_REQUEST;
-         }
-         buffer[dlen] = 0; // Ensure string is NULL-terminated
-         int ts = 0;
-         if (cnt == 3) {
-            // Optional Timestamp as last element of URL path
-            ts = atoi(cmd2);
-         }
-         return agentSendRaw(conn,
+        // URL idx field translates to agent name
+        // Optional query parameter "ts" will translate to timestamp (TODO: Always 0 for initial cut)
+        // Request body contains CBOR-encoded HEX string
+        char buffer[MAX_INPUT_BYTES];
+        int dlen = mg_read(conn, buffer, sizeof(buffer) - 1);
+        if (dlen <= 0) {
+          return HTTP_BAD_REQUEST;
+        }
+        buffer[dlen] = '\0';
+
+        int ts = 0;
+        if (cnt == 3) {
+          // Optional Timestamp as last element of URL path
+          ts = atoi(cmd2);
+        }
+
+        return agentSendRaw(conn,
                             ts,
                             agent,
                             buffer
@@ -483,13 +631,15 @@ static int agentEidHandler(struct mg_connection *conn, void *cbdata)
       else if (0 == strcmp(cmd, "clear_reports"))
       {
          ui_clear_reports(agent);
-         start_text_page(conn, "Successfully cleared reports");
+         start_text_page(conn);
+         mg_printf(conn, "Successfully cleared reports");
          return HTTP_OK;
       }
       else if (0 == strcmp(cmd, "clear_tables"))
       {
          ui_clear_tables(agent);
-         start_text_page(conn, "Successfully cleared tables");
+         start_text_page(conn);
+         mg_printf(conn, "Successfully cleared tables");
          return HTTP_OK;
       }
    }
@@ -510,6 +660,22 @@ static int agentEidHandler(struct mg_connection *conn, void *cbdata)
             return agentShowJSONReports(conn, agent_get((eid_t*)eid) );
          }
       }
+
+      else if (0 == strcmp(cmd, "tables"))
+      {
+         if (cnt == 2 || 0 == strcmp(cmd2, "text") )
+         {
+            return agentShowTextTables(conn,agent_get((eid_t*)eid) );
+         }
+         else if (cnt == 3 && 0 == strcmp(cmd2, "hex") )
+         {
+            return agentShowRawTables(conn, agent_get((eid_t*)eid) );
+         }
+         else if (cnt == 3 && 0 == strcmp(cmd2, "json") )
+         {
+            return agentShowJSONTables(conn, agent_get((eid_t*)eid) );
+         }
+      }
     }
 
    // Invalid request if we make it to this point     
@@ -557,7 +723,12 @@ static int agentIdxHandler(struct mg_connection *conn, void *cbdata)
          // Optional query parameter "ts" will translate to timestamp (TODO: Always 0 for initial cut)
          // Request body contains CBOR-encoded HEX string
          char buffer[MAX_INPUT_BYTES];
-         int dlen = mg_read(conn, buffer, sizeof(buffer));
+         int dlen = mg_read(conn, buffer, sizeof(buffer) - 1);
+         if (dlen <= 0) {
+           return HTTP_BAD_REQUEST;
+         }
+         buffer[dlen] = '\0';
+
          return agentSendRaw(conn,
                             0, // Timestamp TODO. This will be an optional query param
                             agent,
@@ -567,13 +738,15 @@ static int agentIdxHandler(struct mg_connection *conn, void *cbdata)
       else if (0 == strcmp(cmd, "clear_reports"))
       {
          ui_clear_reports(agent);
-         start_text_page(conn, "Successfully cleared reports");
+         start_text_page(conn);
+         mg_printf(conn, "Successfully cleared reports");
          return HTTP_OK;
       }
       else if (0 == strcmp(cmd, "clear_tables"))
       {
          ui_clear_tables(agent);
-         start_text_page(conn, "Successfully cleared tables");
+         start_text_page(conn);
+         mg_printf(conn, "Successfully cleared tables");
          return HTTP_OK;
       }
    }
diff --git a/nm/mgr/nm_rest.h b/nm/mgr/nm_rest.h
index 24a5dda0..5e5b4ca5 100644
--- a/nm/mgr/nm_rest.h
+++ b/nm/mgr/nm_rest.h
@@ -1,6 +1,29 @@
+/*
+ * Copyright (c) 2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 #ifndef __NM_REST_H__
 #define __NM_REST_H__
 
+#include "nmmgr.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 // TODO: Allow these to be configurable
 #ifdef NO_SSL
 #define PORT "8089"
@@ -10,8 +33,8 @@
 #define HOST_INFO "https://localhost:8843"
 #endif
 
-int nm_rest_start();
-void nm_rest_stop();
+int nm_rest_start(nmmgr_t *mgr);
+void nm_rest_stop(void);
 
 // Standard HTTP Status Codes
 #define HTTP_OK                  200
@@ -24,5 +47,8 @@ void nm_rest_stop();
 #define HTTP_NOT_IMPLEMENTED     501
 #define HTTP_NO_SERVICE          503
 
-
+#ifdef __cplusplus
+}
 #endif
+
+#endif  /* _NM_REST_H_ */
diff --git a/nm/mgr/ui_input.c b/nm/mgr/ui_input.c
index 0beeab4f..92ad81bc 100644
--- a/nm/mgr/ui_input.c
+++ b/nm/mgr/ui_input.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file ui_input.h
@@ -23,12 +35,13 @@
  **  10/06/18  E. Birrane     Updated to AMP v0.5 (JHU/APL)
  *****************************************************************************/
 
+#include <inttypes.h>
 #include "ui_input.h"
 #include "metadata.h"
 
 #include "../shared/adm/adm.h"
 
-extern int *global_nm_running;
+extern nmmgr_t *global_mgr;
 
 
 /******************************************************************************
@@ -52,22 +65,22 @@ extern int *global_nm_running;
  *  01/18/13  E. Birrane     Initial Implementation
  *****************************************************************************/
 
-int ui_input_get_line(char *prompt, char **line, int max_len)
+int ui_input_get_line(const char *prompt, char *line, int max_len)
 {
-	int len = 0;
-
-	while(*global_nm_running && len == 0)
+	while(daemon_run_get(&global_mgr->running))
 	{
 		printf("%s\n", prompt);
 
-		if (igets(STDIN_FILENO, (char *)line, max_len, &len) == NULL)
+		if (fgets(line, max_len, stdin) == NULL)
 		{
-			if (len != 0)
-			{
-				AMP_DEBUG_ERR("ui_input_get_line","igets failed.", NULL);
-				AMP_DEBUG_EXIT("ui_input_get_line","->0.",NULL);
-				return 0;
-			}
+		  AMP_DEBUG_ERR("ui_input_get_line","igets failed.", NULL);
+		  AMP_DEBUG_EXIT("ui_input_get_line","->0.",NULL);
+		  return 0;
+		}
+		size_t len = strlen(line);
+		if (len > 0)
+		{
+		  break;
 		}
 	}
     
@@ -77,7 +90,7 @@ int ui_input_get_line(char *prompt, char **line, int max_len)
 	return 1;
 }
 
-blob_t *ui_input_file_contents(char *prompt)
+blob_t *ui_input_file_contents(const char *prompt)
 {
 	blob_t *result = NULL;
 	char *filename = NULL;
@@ -177,7 +190,7 @@ uint8_t ui_input_adm_id()
 }
 
 
-blob_t* ui_input_blob(char *prompt, uint8_t no_file)
+blob_t* ui_input_blob(const char *prompt, uint8_t no_file)
 {
 	blob_t *result = NULL;
 	uint32_t len = 0;
@@ -211,12 +224,12 @@ blob_t* ui_input_blob(char *prompt, uint8_t no_file)
 }
 
 
-uint8_t  ui_input_byte(char *prompt)
+uint8_t  ui_input_byte(const char *prompt)
 {
 	uint8_t result = 0;
 	char line[3];
 	memset(line,0,3);
-	ui_input_get_line(prompt, (char**)&line, 2);
+	ui_input_get_line(prompt, line, 3);
 
 	blob_t *blob = utils_string_to_hex(line);
 	if(blob == NULL)
@@ -224,6 +237,7 @@ uint8_t  ui_input_byte(char *prompt)
 		AMP_DEBUG_ERR("ui_input_byte","Problem reading value. Returning 0.", NULL);
 		return 0;
 	}
+
 	if(blob->length > 1)
 	{
 		ui_printf("Read %d bytes. Only selecting first.", blob->length);
@@ -233,24 +247,24 @@ uint8_t  ui_input_byte(char *prompt)
 	return result;
 }
 
-double   ui_input_real64(char *prompt)
+double   ui_input_real64(const char *prompt)
 {
 	double result = 0;
 	char line[20];
 
-	ui_input_get_line(prompt, (char**)&line, 20);
+	ui_input_get_line(prompt, line, 20);
 
 	sscanf(line, "%lf", &result);
 
 	return result;
 }
 
-float    ui_input_real32(char *prompt)
+float    ui_input_real32(const char *prompt)
 {
 	float result = 0;
 	char line[20];
 
-	ui_input_get_line(prompt, (char**)&line, 20);
+	ui_input_get_line(prompt, line, 20);
 
 	sscanf(line, "%f", &result);
 
@@ -258,18 +272,8 @@ float    ui_input_real32(char *prompt)
 }
 
 
-Sdnv     ui_input_sdnv(char *prompt)
-{
-	Sdnv val_sdnv;
-	uvast val = ui_input_uvast(prompt);
-
-	encodeSdnv(&val_sdnv, val);
-
-	return val_sdnv;
-}
-
 #ifdef USE_NCURSES
-char *   ui_input_string(char *prompt)
+char *   ui_input_string(const char *prompt)
 {
    char line[MAX_INPUT_BYTES] = "";
    char *result;
@@ -290,12 +294,12 @@ char *   ui_input_string(char *prompt)
    }   
 }
 #else
-char *   ui_input_string(char *prompt)
+char *   ui_input_string(const char *prompt)
 {
 	char *result = NULL;
 	char line[MAX_INPUT_BYTES];
 	memset(line, 0, MAX_INPUT_BYTES);
-	ui_input_get_line(prompt, (char**)&line, MAX_INPUT_BYTES-1);
+	ui_input_get_line(prompt, line, MAX_INPUT_BYTES-1);
 
 	result = (char *) STAKE(strlen(line) + 1);
 
@@ -305,56 +309,56 @@ char *   ui_input_string(char *prompt)
 }
 #endif
 
-int32_t     ui_input_int(char *prompt)
+int32_t     ui_input_int(const char *prompt)
 {
 	int32_t result = 0;
 	char line[20];
 
-	ui_input_get_line(prompt, (char**)&line, 20);
+	ui_input_get_line(prompt, line, 20);
 
 	sscanf(line, "%d", &result);
 
 	return result;
 }
 
-uint32_t     ui_input_uint(char *prompt)
+uint32_t     ui_input_uint(const char *prompt)
 {
 	uint32_t result = 0;
 	char line[20];
 
-	ui_input_get_line(prompt, (char**)&line, 20);
+	ui_input_get_line(prompt, line, 20);
 
 	sscanf(line, "%u", &result);
 
 	return result;
 }
 
-uvast     ui_input_uvast(char *prompt)
+amp_uvast     ui_input_uvast(const char *prompt)
 {
-	uvast result = 0;
+	amp_uvast result = 0;
 	char line[MAX_INPUT_BYTES];
 
-	ui_input_get_line(prompt, (char**)&line, MAX_INPUT_BYTES);
+	ui_input_get_line(prompt, line, MAX_INPUT_BYTES);
 
-	sscanf(line, UVAST_FIELDSPEC, &result);
+	sscanf(line, PRIu64, &result);
 
 	return result;
 }
 
-vast     ui_input_vast(char *prompt)
+amp_vast     ui_input_vast(const char *prompt)
 {
-	vast result = 0;
+	amp_vast result = 0;
 	char line[MAX_INPUT_BYTES];
 
-	ui_input_get_line(prompt, (char**)&line, MAX_INPUT_BYTES);
+	ui_input_get_line(prompt, line, MAX_INPUT_BYTES);
 
-	sscanf(line, VAST_FIELDSPEC, &result);
+	sscanf(line, PRId64, &result);
 
 	return result;
 }
 
 
-ac_t *ui_input_ac(char *prompt)
+ac_t *ui_input_ac(const char *prompt)
 {
 	uint32_t i = 0;
 	uint32_t num = 0;
@@ -418,7 +422,7 @@ ac_t *ui_input_ac(char *prompt)
  *  07/05/16  E. Birrane     Check for NULL result. Add File input.
  *****************************************************************************/
 
-ari_t *ui_input_ari(char *prompt, uint8_t adm_id, uvast mask)
+ari_t *ui_input_ari(const char *prompt, uint8_t adm_id, amp_uvast mask)
 {
 	ari_t *result = NULL;
 	metadata_t *meta = NULL;
@@ -472,13 +476,12 @@ ari_t *ui_input_ari(char *prompt, uint8_t adm_id, uvast mask)
 	return result;
 }
 
-ari_t* ui_input_ari_build(uvast mask)
+ari_t* ui_input_ari_build(amp_uvast mask)
 {
 	ari_t *result = NULL;
 	uint8_t flags;
 	int success;
 
-
 	ui_input_ari_flags(&flags);
 
 
@@ -494,18 +497,27 @@ ari_t* ui_input_ari_build(uvast mask)
 
 	if(result->type == AMP_TYPE_LIT)
 	{
+		ari_release(result, 1);
+		result = ui_input_ari_lit("");
 
-		result->type = AMP_TYPE_LIT;
-		tnv_t *tmp = ui_input_tnv(AMP_TYPE_LIT, "");
-		result->as_lit = tnv_copy(*tmp, &success);
-		tnv_release(tmp, 1);
-
-		if(result->as_lit.type == AMP_TYPE_UNK)
+		if((result == NULL) || (result->as_lit.type == AMP_TYPE_UNK))
 		{
 			AMP_DEBUG_ERR("ui_input_ari_build", "Problem building ARI.", NULL);
 			ari_release(result, 1);
 			result = NULL;
 		}
+		else
+		{
+			blob_t* blob = ari_serialize_wrapper(result);
+			if(blob)
+			{
+				char *ari_str = utils_hex_to_string(blob->value, blob->length);
+				AMP_DEBUG_INFO("ui_input_ari_build", "Constructed ARI: %s\n", ari_str);
+				SRELEASE(ari_str);
+				blob_release(blob, 1);
+			}
+		}
+
 		return result;
 	}
 
@@ -513,7 +525,7 @@ ari_t* ui_input_ari_build(uvast mask)
 
 	if(ARI_GET_FLAG_NN(flags))
 	{
-		uvast nn = ui_input_uvast("ARI Nickname:");
+		amp_uvast nn = ui_input_uvast("ARI Nickname:");
 		if(VDB_ADD_NN(nn, &(result->as_reg.nn_idx)) != VEC_OK)
 		{
 			AMP_DEBUG_ERR("ui_input_ari","Unable to add nickname.", NULL);
@@ -525,7 +537,7 @@ ari_t* ui_input_ari_build(uvast mask)
 	if(ARI_GET_FLAG_ISS(flags))
 	{
 #if AMP_VERSION < 7
-		uvast iss = ui_input_uvast("ARI Issuer:");
+		amp_uvast iss = ui_input_uvast("ARI Issuer:");
 		if(VDB_ADD_ISS(iss, &(result->as_reg.iss_idx)) != VEC_OK)
 		{
 			AMP_DEBUG_ERR("ui_input_ari","Unable to add issuer.", NULL);
@@ -721,7 +733,7 @@ int ui_input_ari_flags(uint8_t *flag)
 	return AMP_OK;
 }
 
-ari_t *ui_input_ari_list(uint8_t adm_id, uvast mask)
+ari_t *ui_input_ari_list(uint8_t adm_id, amp_uvast mask)
 {
 	ari_t *result = NULL;
 	int idx = 0;
@@ -733,10 +745,10 @@ ari_t *ui_input_ari_list(uint8_t adm_id, uvast mask)
 	return result;
 }
 
-ari_t*  ui_input_ari_lit(char *prompt)
+ari_t*  ui_input_ari_lit(const char *prompt)
 {
 	ari_t *result = NULL;
-	uvast mask = 0;
+	amp_uvast mask = 0;
 	amp_type_e type;
 
 	if(prompt != NULL)
@@ -821,7 +833,7 @@ ari_t* ui_input_ari_raw(uint8_t no_file)
 }
 
 
-int ui_input_ari_type(uvast mask)
+int ui_input_ari_type(amp_uvast mask)
 {
 	int i= 0;
 	int idx = 0;
@@ -962,7 +974,7 @@ tnv_t *ui_input_tnv(int type, char *prompt)
 }
 
 
-tnvc_t* ui_input_tnvc(char *prompt)
+tnvc_t* ui_input_tnvc(const char *prompt)
 {
 	tnvc_t *result = NULL;
 	int num;
@@ -991,7 +1003,7 @@ tnvc_t* ui_input_tnvc(char *prompt)
 
 
 
-ctrl_t* ui_input_ctrl(char * prompt)
+ctrl_t* ui_input_ctrl(const char *prompt)
 {
 
    
@@ -999,12 +1011,12 @@ ctrl_t* ui_input_ctrl(char * prompt)
 	return NULL;
 }
 
-expr_t* ui_input_expr(char* prompt)
+expr_t* ui_input_expr(const char *prompt)
 {
    expr_t* expr = NULL;
    ari_t *val = NULL;
    amp_type_e type = AMP_TYPE_UNK;
-   uvast mask;
+   amp_uvast mask;
 
    ui_printf("\n\n");
    ui_printf("Expression Builder\n");
@@ -1044,50 +1056,50 @@ expr_t* ui_input_expr(char* prompt)
    return expr;
 }
 
-op_t* ui_input_oper(char* prompt)
+op_t* ui_input_oper(const char *prompt)
 {
 	AMP_DEBUG_ERR("ui_input_oper", "Not implemented yet.", NULL);
 	return NULL;
 }
 
-rpt_t* ui_input_rpt(char* prompt)
+rpt_t* ui_input_rpt(const char *prompt)
 {
 	AMP_DEBUG_ERR("ui_input_rpt", "Not implemented yet.", NULL);
 	return NULL;
 }
 
-rpttpl_t* ui_input_rpttpl(char* prompt)
+rpttpl_t* ui_input_rpttpl(const char *prompt)
 {
 	AMP_DEBUG_ERR("ui_input_rpttpl", "Not implemented yet.", NULL);
 	return NULL;
 }
 
-rule_t *ui_input_rule(char* prompt)
+rule_t *ui_input_rule(const char *prompt)
 {
 	AMP_DEBUG_ERR("ui_input_rule", "Not implemented yet.", NULL);
 	return NULL;
 }
 
-tbl_t* ui_input_tbl(char* prompt)
+tbl_t* ui_input_tbl(const char *prompt)
 {
 	AMP_DEBUG_ERR("ui_input_tbl", "Not implemented yet.", NULL);
 	return NULL;
 }
 
-tblt_t* ui_input_tblt(char* prompt)
+tblt_t* ui_input_tblt(const char *prompt)
 {
 	AMP_DEBUG_ERR("ui_input_tblt", "Not implemented yet.", NULL);
 	return NULL;
 }
 
 
-var_t* ui_input_var(char* prompt)
+var_t* ui_input_var(const char *prompt)
 {
 	AMP_DEBUG_ERR("ui_input_var", "Not implemented yet.", NULL);
 	return NULL;
 }
 
-macdef_t *ui_input_mac(char *prompt)
+macdef_t *ui_input_mac(const char *prompt)
 {
 	AMP_DEBUG_ERR("ui_input_var", "Not implemented yet.", NULL);
 	return NULL;
diff --git a/nm/mgr/ui_input.h b/nm/mgr/ui_input.h
index b7f955cd..693ad084 100644
--- a/nm/mgr/ui_input.h
+++ b/nm/mgr/ui_input.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file ui_input.h
@@ -33,9 +45,13 @@
 
 #include "nm_mgr_ui.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #define MAX_INPUT_BYTES 1024
 
-#define TYPE_AS_MASK(type) (((uvast)1) << ((uvast)type))
+#define TYPE_AS_MASK(type) (((amp_uvast)1) << ((amp_uvast)type))
 #define TYPE_MATCHES_MASK(type, mask) (TYPE_AS_MASK(type) & mask)
 
 #if (LONG_LONG_OKAY)
@@ -44,7 +60,7 @@
 #define TYPE_MASK_ALL (0xFFFFFFFF)
 #endif
 
-int ui_input_get_line(char *prompt, char **line, int max_len);
+int ui_input_get_line(const char *prompt, char *line, int max_len);
 
 /*
  * AMM Object Input Functions
@@ -55,55 +71,60 @@ uint8_t ui_input_adm_id();
 /*
  * User input methods for basic data types.
  */
-uint8_t  ui_input_byte(char *prompt);
-int32_t  ui_input_int(char *prompt);
-float    ui_input_real32(char *prompt);
-double   ui_input_real64(char *prompt);
-char *   ui_input_string(char *prompt);
-uint32_t ui_input_uint(char *prompt);
-uvast    ui_input_uvast(char *prompt);
-vast     ui_input_vast(char *prompt);
+uint8_t  ui_input_byte(const char *prompt);
+int32_t  ui_input_int(const char *prompt);
+float    ui_input_real32(const char *prompt);
+double   ui_input_real64(const char *prompt);
+char *   ui_input_string(const char *prompt);
+uint32_t ui_input_uint(const char *prompt);
+amp_uvast    ui_input_uvast(const char *prompt);
+amp_vast     ui_input_vast(const char *prompt);
 
 /*
  * User input for compound object types.
  */
 
-ac_t*   ui_input_ac(char *prompt);
+ac_t*   ui_input_ac(const char *prompt);
 
-ari_t*  ui_input_ari(char *prompt, uint8_t adm_id, uvast mask);
-ari_t*  ui_input_ari_build(uvast mask);
+ari_t*  ui_input_ari(const char *prompt, uint8_t adm_id, amp_uvast mask);
+ari_t*  ui_input_ari_build(amp_uvast mask);
 int     ui_input_ari_flags(uint8_t *flag);
-ari_t*  ui_input_ari_list(uint8_t adm_id, uvast mask);
-ari_t*  ui_input_ari_lit(char *prompt);
+ari_t*  ui_input_ari_list(uint8_t adm_id, amp_uvast mask);
+ari_t*  ui_input_ari_lit(const char *prompt);
 ari_t*  ui_input_ari_raw(uint8_t no_file);
-int     ui_input_ari_type(uvast mask);
+int     ui_input_ari_type(amp_uvast mask);
 int     ui_input_parms(ari_t *id);
 
 tnv_t*  ui_input_tnv(int type, char *prompt);
-tnvc_t* ui_input_tnvc(char *prompt);
+tnvc_t* ui_input_tnvc(const char *prompt);
 
 
 /* Input for helper types. */
-blob_t*  ui_input_blob(char *prompt, uint8_t no_file);
-blob_t*  ui_input_file_contents(char *prompt);
+blob_t*  ui_input_blob(const char *prompt, uint8_t no_file);
+blob_t*  ui_input_file_contents(const char *prompt);
 
 
-ctrl_t* ui_input_ctrl(char* prompt);
-expr_t* ui_input_expr(char* prompt);
-op_t* ui_input_oper(char* prompt);
-rpt_t* ui_input_rpt(char* prompt);
-rpttpl_t* ui_input_rpttpl(char* prompt);
-rule_t *ui_input_rule(char* prompt);
+ctrl_t* ui_input_ctrl(const char *prompt);
+expr_t* ui_input_expr(const char *prompt);
+op_t* ui_input_oper(const char *prompt);
+rpt_t* ui_input_rpt(const char *prompt);
+rpttpl_t* ui_input_rpttpl(const char *prompt);
+rule_t *ui_input_rule(const char *prompt);
 
-tbl_t* ui_input_tbl(char* prompt);
-tblt_t* ui_input_tblt(char* prompt);
+tbl_t* ui_input_tbl(const char *prompt);
+tblt_t* ui_input_tblt(const char *prompt);
 
-rule_t *ui_input_tbr(char* prompt);
+rule_t *ui_input_tbr(const char *prompt);
 
-var_t* ui_input_var(char* prompt);
+var_t* ui_input_var(const char *prompt);
 
-tnvc_t* ui_input_tnvc(char* prompt);
+tnvc_t* ui_input_tnvc(const char *prompt);
 
-macdef_t *ui_input_mac(char *prompt);
+macdef_t *ui_input_mac(const char *prompt);
+
+
+#ifdef __cplusplus
+}
+#endif
 
-#endif // _UI_INPUT_H
+#endif  /* _UI_INPUT_H_ */
diff --git a/nm/shared/adm/adm.c b/nm/shared/adm/adm.c
index 8f14ee69..f7885430 100644
--- a/nm/shared/adm/adm.c
+++ b/nm/shared/adm/adm.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2011-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: adm.c
@@ -27,8 +39,7 @@
  **  01/10/18  E. Birrane     CLean up reports, added report parameter maps. (JHU/APL)
  *****************************************************************************/
 
-#include "ion.h"
-#include "platform.h"
+#include "shared/platform.h"
 
 #include "adm.h"
 
@@ -160,7 +171,7 @@ int adm_add_ctrldef_ari(ari_t *id, uint8_t num, ctrldef_run_fn run)
 	return ((rh_code == RH_OK) || (rh_code == RH_DUPLICATE)) ? AMP_OK : AMP_FAIL;
 }
 
-int adm_add_ctrldef(uint8_t nn, uvast name, uint8_t num, ctrldef_run_fn run)
+int adm_add_ctrldef(uint8_t nn, amp_uvast name, uint8_t num, ctrldef_run_fn run)
 {
 	ari_t *id = adm_build_ari(AMP_TYPE_CTRL, (num > 0) ? 1 : 0, nn, name);
 
@@ -365,6 +376,8 @@ int adm_add_op_ari(ari_t *id, uint8_t num_parm, op_fn apply_fn)
 
 	if((def = op_create(id, num_parm, apply_fn)) == NULL)
 	{
+		AMP_DEBUG_ERR("adm_add_op_ari","Cannot create op.", NULL);
+
 		ari_release(id, 1);
 		return AMP_FAIL;
 	}
@@ -377,14 +390,17 @@ int adm_add_op_ari(ari_t *id, uint8_t num_parm, op_fn apply_fn)
 	}
 	if(rh_code != RH_OK)
 	{
+		AMP_DEBUG_ERR("adm_add_op_ari","Cannot create op.", NULL);
+
 		op_release(def, 1);
 	}
 
 	return ((rh_code == RH_OK) || (rh_code == RH_DUPLICATE)) ? AMP_OK : AMP_FAIL;
 }
 
-int adm_add_op(vec_idx_t nn, uvast name, uint8_t num_parm, op_fn apply_fn)
+int adm_add_op(vec_idx_t nn, amp_uvast name, uint8_t num_parm, op_fn apply_fn)
 {
+	// The OPER ARI itself has no parameters, but the operator consumes stack items
 	return adm_add_op_ari(adm_build_ari(AMP_TYPE_OPER, 1, nn, name),num_parm, apply_fn);
 }
 
@@ -471,6 +487,7 @@ int	adm_add_var_from_expr(ari_t *id, amp_type_e type, expr_t *expr)
 
 	if((id == NULL) || (expr == NULL))
 	{
+		AMP_DEBUG_ERR("adm_add_var_from_expr","Bad args.", NULL);
 		return AMP_FAIL;
 	}
 
@@ -529,7 +546,7 @@ int adm_add_var_from_tnv(ari_t *id, tnv_t value)
 
 
 // Takes over name and parms, no matter what.
-ari_t* adm_build_ari(amp_type_e type, uint8_t has_parms, vec_idx_t nn, uvast id)
+ari_t* adm_build_ari(amp_type_e type, uint8_t has_parms, vec_idx_t nn, amp_uvast id)
 {
 	ari_t *result = ari_create(type);
 	CHKNULL(result);
@@ -564,7 +581,7 @@ ari_t* adm_build_ari(amp_type_e type, uint8_t has_parms, vec_idx_t nn, uvast id)
 }
 
 
-ari_t *adm_build_ari_parm_6(amp_type_e type, vec_idx_t nn, uvast id, tnv_t *p1, tnv_t *p2, tnv_t* p3, tnv_t *p4, tnv_t *p5, tnv_t *p6)
+ari_t *adm_build_ari_parm_6(amp_type_e type, vec_idx_t nn, amp_uvast id, tnv_t *p1, tnv_t *p2, tnv_t* p3, tnv_t *p4, tnv_t *p5, tnv_t *p6)
 {
 	ari_t *ari = adm_build_ari(type, 1, nn, id);
 
@@ -615,17 +632,23 @@ uint32_t adm_get_parm_uint(tnvc_t *parms, uint8_t idx, int *success)
 	tnv_t *val = tnvc_get(parms, idx);
 	return (val == NULL) ? 0 : tnv_to_uint(*val, success);}
 
-uvast adm_get_parm_uvast(tnvc_t *parms, uint8_t idx, int *success)
+amp_uvast adm_get_parm_uvast(tnvc_t *parms, uint8_t idx, int *success)
 {
 	tnv_t *val = tnvc_get(parms, idx);
 	return (val == NULL) ? 0 : tnv_to_uvast(*val, success);}
 
-vast adm_get_parm_vast(tnvc_t *parms, uint8_t idx, int *success)
+amp_vast adm_get_parm_vast(tnvc_t *parms, uint8_t idx, int *success)
 {
 	tnv_t *val = tnvc_get(parms, idx);
 	return (val == NULL) ? 0 : tnv_to_vast(*val, success);
 }
 
+amp_tv_t adm_get_parm_tv(tnvc_t *parms, uint8_t idx, int *success)
+{
+  tnv_t *val = tnvc_get(parms, idx);
+  return (val == NULL) ? AMP_TV_ZERO : tnv_to_tv(*val, success);
+}
+
 /******************************************************************************
  *
  * \par Function Name: adm_common_init
@@ -648,9 +671,15 @@ void adm_common_init()
 
 	AMP_DEBUG_ENTRY("adm_init","()", NULL);
 
+	//FIXME: memory leak in the vector elements
 	g_adm_info = vec_create(8, NULL, NULL, NULL, 0, &success);
 
 	adm_add_adm_info("ALL", 0);
 
 	AMP_DEBUG_EXIT("adm_init","->.", NULL);
 }
+
+void adm_common_destroy()
+{
+  vec_release(&g_adm_info, false);
+}
diff --git a/nm/shared/adm/adm.h b/nm/shared/adm/adm.h
index 633124fa..abc559b0 100644
--- a/nm/shared/adm/adm.h
+++ b/nm/shared/adm/adm.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2011-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -36,6 +48,11 @@
 #include "../primitives/report.h"
 #include "../primitives/ctrl.h"
 #include "../primitives/table.h"
+#include "../primitives/time.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /*
  * +--------------------------------------------------------------------------+
@@ -100,14 +117,14 @@ typedef struct
 int adm_add_adm_info(char *name, int id);
 
 int adm_add_cnst(ari_t *id, edd_collect_fn collect);
-int adm_add_ctrldef(uint8_t nn, uvast id, uint8_t num, ctrldef_run_fn run);
+int adm_add_ctrldef(uint8_t nn, amp_uvast id, uint8_t num, ctrldef_run_fn run);
 int adm_add_ctrldef_ari(ari_t *id, uint8_t num, ctrldef_run_fn run);
 
 int adm_add_edd(ari_t *id, edd_collect_fn collect);
 int adm_add_lit(ari_t *id);
 int adm_add_macdef(macdef_t *def);
 int adm_add_macdef_ctrl(macdef_t *def, ari_t *id);
-int adm_add_op(vec_idx_t nn, uvast name, uint8_t num_parm, op_fn apply_fn);
+int adm_add_op(vec_idx_t nn, amp_uvast name, uint8_t num_parm, op_fn apply_fn);
 int adm_add_op_ari(ari_t *id, uint8_t num_parm, op_fn apply_fn);
 
 int adm_add_rpttpl(rpttpl_t *def);
@@ -116,8 +133,8 @@ int	adm_add_var_from_expr(ari_t *id, amp_type_e type, expr_t *expr);
 int adm_add_var_from_tnv(ari_t *id, tnv_t value)
 ;
 
-ari_t* adm_build_ari(amp_type_e type, uint8_t has_parms, vec_idx_t nn, uvast id);
-ari_t *adm_build_ari_parm_6(amp_type_e type, vec_idx_t nn, uvast id, tnv_t *p1, tnv_t *p2, tnv_t* p3, tnv_t *p4, tnv_t *p5, tnv_t *p6);
+ari_t* adm_build_ari(amp_type_e type, uint8_t has_parms, vec_idx_t nn, amp_uvast id);
+ari_t *adm_build_ari_parm_6(amp_type_e type, vec_idx_t nn, amp_uvast id, tnv_t *p1, tnv_t *p2, tnv_t* p3, tnv_t *p4, tnv_t *p5, tnv_t *p6);
 
 
 int32_t adm_get_parm_int(tnvc_t *parms, uint8_t idx, int *success);
@@ -125,10 +142,17 @@ void *adm_get_parm_obj(tnvc_t *parms, uint8_t idx, amp_type_e type);
 float adm_get_parm_real32(tnvc_t *parms, uint8_t idx, int *success);
 double adm_get_parm_real64(tnvc_t *parms, uint8_t idx, int *success);
 uint32_t adm_get_parm_uint(tnvc_t *parms, uint8_t idx, int *success);
-uvast adm_get_parm_uvast(tnvc_t *parms, uint8_t idx, int *success);
-vast adm_get_parm_vast(tnvc_t *parms, uint8_t idx, int *success);
+amp_uvast adm_get_parm_uvast(tnvc_t *parms, uint8_t idx, int *success);
+amp_vast adm_get_parm_vast(tnvc_t *parms, uint8_t idx, int *success);
+amp_tv_t adm_get_parm_tv(tnvc_t *parms, uint8_t idx, int *success);
 
 void adm_init();
 void adm_common_init();
 
-#endif /* ADM_H_*/
+void adm_common_destroy();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _ADM_H_*/
diff --git a/nm/shared/adm/adm_amp_agent.h b/nm/shared/adm/adm_amp_agent.h
deleted file mode 100644
index d006f895..00000000
--- a/nm/shared/adm/adm_amp_agent.h
+++ /dev/null
@@ -1,477 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_amp_agent.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-16  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-
-#ifndef ADM_AMP_AGENT_H_
-#define ADM_AMP_AGENT_H_
-#define _HAVE_AMP_AGENT_ADM_
-#ifdef _HAVE_AMP_AGENT_ADM_
-
-#include "shared/utils/nm_types.h"
-#include "shared/adm/adm.h"
-
-extern vec_idx_t g_amp_agent_idx[11];
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 ADM TEMPLATE DOCUMENTATION                                  +
- * +---------------------------------------------------------------------------------------------+
- *
- * ADM ROOT STRING:Amp/Agent
- */
-#define ADM_ENUM_AMP_AGENT 1
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AGENT NICKNAME DEFINITIONS                                  +
- * +---------------------------------------------------------------------------------------------+
- */
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               AMP_AGENT META-DATA DEFINITIONS                               +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |name                 |The human-readable name of the ADM.   |STR    |amp_agent               |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |namespace            |The namespace of the ADM.             |STR    |Amp/Agent               |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |version              |The version of the ADM.               |STR    |v3.1                    |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |organization         |The name of the issuing organization o|       |                        |
- * |                     |f the ADM.                            |STR    |JHUAPL                  |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-// "name"
-#define AMP_AGENT_META_NAME 0x00
-// "namespace"
-#define AMP_AGENT_META_NAMESPACE 0x01
-// "version"
-#define AMP_AGENT_META_VERSION 0x02
-// "organization"
-#define AMP_AGENT_META_ORGANIZATION 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                        AMP_AGENT EXTERNALLY DEFINED DATA DEFINITIONS                        +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |num_rpt_tpls         |This is the number of report templates|       |
- * |                     | known to the Agent.                  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_tbl_tpls         |This is the number of table templates |       |
- * |                     |known to the Agent.                   |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |sent_reports         |This is the number of reports sent by |       |
- * |                     |the agent.                            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_tbr              |This is the number of time-based rules|       |
- * |                     | running on the agent.                |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |run_tbr              |This is the number of time-based rules|       |
- * |                     | run by the agent since the last reset|       |
- * |                     |.                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_sbr              |This is the number of state-based rule|       |
- * |                     |s running on the agent.               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |run_sbr              |This is the number of state-based rule|       |
- * |                     |s run by the agent since the last rese|       |
- * |                     |t.                                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_const            |This is the number of constants known |       |
- * |                     |by the agent.                         |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_var              |This is the number of variables known |       |
- * |                     |by the agent.                         |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_macros           |This is the number of macros known by |       |
- * |                     |the agent.                            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |run_macros           |This is the number of macros run by th|       |
- * |                     |e agent since the last reset.         |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |num_controls         |This is the number of controls known b|       |
- * |                     |y the agent.                          |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |run_controls         |This is the number of controls run by |       |
- * |                     |the agent since the last reset.       |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |cur_time             |This is the current system time.      |TV     |
- * +---------------------+--------------------------------------+-------+
- */
-#define AMP_AGENT_EDD_NUM_RPT_TPLS 0x00
-#define AMP_AGENT_EDD_NUM_TBL_TPLS 0x01
-#define AMP_AGENT_EDD_SENT_REPORTS 0x02
-#define AMP_AGENT_EDD_NUM_TBR 0x03
-#define AMP_AGENT_EDD_RUN_TBR 0x04
-#define AMP_AGENT_EDD_NUM_SBR 0x05
-#define AMP_AGENT_EDD_RUN_SBR 0x06
-#define AMP_AGENT_EDD_NUM_CONST 0x07
-#define AMP_AGENT_EDD_NUM_VAR 0x08
-#define AMP_AGENT_EDD_NUM_MACROS 0x09
-#define AMP_AGENT_EDD_RUN_MACROS 0x0a
-#define AMP_AGENT_EDD_NUM_CONTROLS 0x0b
-#define AMP_AGENT_EDD_RUN_CONTROLS 0x0c
-#define AMP_AGENT_EDD_CUR_TIME 0x0d
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               AMP_AGENT VARIABLE DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |num_rules            |This is the number of rules known to t|       |
- * |                     |he Agent (#TBR + #SBR).               |UINT   |
- * +---------------------+--------------------------------------+-------+
- */
-#define AMP_AGENT_VAR_NUM_RULES 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                AMP_AGENT REPORT DEFINITIONS                                 +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |full_report          |This is all known meta-data, EDD, and |       |
- * |                     |VAR values known by the agent.        |TNVC   |
- * +---------------------+--------------------------------------+-------+
- */
-#define AMP_AGENT_RPTTPL_FULL_REPORT 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AMP_AGENT TABLE DEFINITIONS                                 +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |adms                 |This table lists all the adms that are|       |
- * |                     | supported by the agent.              |       |
- * +---------------------+--------------------------------------+-------+
- * |variables            |This table lists the ARI for every var|       |
- * |                     |iable that is known to the agent.     |       |
- * +---------------------+--------------------------------------+-------+
- * |rptts                |This table lists the ARI for every rep|       |
- * |                     |ort template that is known to the agen|       |
- * |                     |t.                                    |       |
- * +---------------------+--------------------------------------+-------+
- * |macros               |This table lists the ARI for every mac|       |
- * |                     |ro that is known to the agent.        |       |
- * +---------------------+--------------------------------------+-------+
- * |rules                |This table lists the ARI for every rul|       |
- * |                     |e that is known to the agent.         |       |
- * +---------------------+--------------------------------------+-------+
- * |tblts                |This table lists the ARI for every tab|       |
- * |                     |le template that is known to the agent|       |
- * |                     |.                                     |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define AMP_AGENT_TBLT_ADMS 0x00
-#define AMP_AGENT_TBLT_VARIABLES 0x01
-#define AMP_AGENT_TBLT_RPTTS 0x02
-#define AMP_AGENT_TBLT_MACROS 0x03
-#define AMP_AGENT_TBLT_RULES 0x04
-#define AMP_AGENT_TBLT_TBLTS 0x05
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                AMP_AGENT CONTROL DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |add_var              |This control configures a new variable|       |
- * |                     | definition on the Agent.             |       |
- * +---------------------+--------------------------------------+-------+
- * |del_var              |This control removes one or more varia|       |
- * |                     |ble definitions from the Agent.       |       |
- * +---------------------+--------------------------------------+-------+
- * |add_rptt             |This control configures a new report t|       |
- * |                     |emplate definition on the Agent.      |       |
- * +---------------------+--------------------------------------+-------+
- * |del_rptt             |This control removes one or more repor|       |
- * |                     |t template definitions from the Agent.|       |
- * +---------------------+--------------------------------------+-------+
- * |desc_rptt            |This control produces a detailed descr|       |
- * |                     |iption of one or more report template |       |
- * |                     | identifier(ARI) known to the Agent.  |       |
- * +---------------------+--------------------------------------+-------+
- * |gen_rpts             |This control causes the Agent to produ|       |
- * |                     |ce a report entry for each identified |       |
- * |                     |report templates and send them to one |       |
- * |                     |or more identified managers(ARIs).    |       |
- * +---------------------+--------------------------------------+-------+
- * |gen_tbls             |This control causes the Agent to produ|       |
- * |                     |ce a table for each identified table t|       |
- * |                     |emplates and send them to one or more |       |
- * |                     |identified managers(ARIs).            |       |
- * +---------------------+--------------------------------------+-------+
- * |add_macro            |This control configures a new macro de|       |
- * |                     |finition on the Agent.                |       |
- * +---------------------+--------------------------------------+-------+
- * |del_macro            |This control removes one or more macro|       |
- * |                     | definitions from the Agent.          |       |
- * +---------------------+--------------------------------------+-------+
- * |desc_macro           |This control produces a detailed descr|       |
- * |                     |iption of one or more macro identifier|       |
- * |                     |(ARI) known to the Agent.             |       |
- * +---------------------+--------------------------------------+-------+
- * |add_tbr              |This control configures a new time-bas|       |
- * |                     |ed rule(TBR) definition on the Agent. |       |
- * +---------------------+--------------------------------------+-------+
- * |add_sbr              |This control configures a new state-ba|       |
- * |                     |sed rule(SBR) definition on the Agent.|       |
- * +---------------------+--------------------------------------+-------+
- * |del_rule             |This control removes one or more rule |       |
- * |                     |definitions from the Agent.           |       |
- * +---------------------+--------------------------------------+-------+
- * |desc_rule            |This control produces a detailed descr|       |
- * |                     |iption of one or more rules known to t|       |
- * |                     |he Agent.                             |       |
- * +---------------------+--------------------------------------+-------+
- * |store_var            |This control stores variables.        |       |
- * +---------------------+--------------------------------------+-------+
- * |reset_counts         |This control resets all Agent ADM stat|       |
- * |                     |istics reported in the Agent ADM repor|       |
- * |                     |t.                                    |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define AMP_AGENT_CTRL_ADD_VAR 0x00
-#define AMP_AGENT_CTRL_DEL_VAR 0x01
-#define AMP_AGENT_CTRL_ADD_RPTT 0x02
-#define AMP_AGENT_CTRL_DEL_RPTT 0x03
-#define AMP_AGENT_CTRL_DESC_RPTT 0x04
-#define AMP_AGENT_CTRL_GEN_RPTS 0x05
-#define AMP_AGENT_CTRL_GEN_TBLS 0x06
-#define AMP_AGENT_CTRL_ADD_MACRO 0x07
-#define AMP_AGENT_CTRL_DEL_MACRO 0x08
-#define AMP_AGENT_CTRL_DESC_MACRO 0x09
-#define AMP_AGENT_CTRL_ADD_TBR 0x0a
-#define AMP_AGENT_CTRL_ADD_SBR 0x0b
-#define AMP_AGENT_CTRL_DEL_RULE 0x0c
-#define AMP_AGENT_CTRL_DESC_RULE 0x0d
-#define AMP_AGENT_CTRL_STORE_VAR 0x0e
-#define AMP_AGENT_CTRL_RESET_COUNTS 0x0f
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               AMP_AGENT CONSTANT DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |amp_epoch            |This constant is the time epoch for th|       |                        |
- * |                     |e Agent.                              |TS     |1504915200              |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-#define AMP_AGENT_CNST_AMP_EPOCH 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AMP_AGENT MACRO DEFINITIONS                                 +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               AMP_AGENT OPERATOR DEFINITIONS                                +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |plusINT              |Int32 addition                        |INT    |
- * +---------------------+--------------------------------------+-------+
- * |plusUINT             |Unsigned Int32 addition               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |plusVAST             |Int64 addition                        |VAST   |
- * +---------------------+--------------------------------------+-------+
- * |plusUVAST            |Unsigned Int64 addition               |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |plusREAL32           |Real32 addition                       |REAL32 |
- * +---------------------+--------------------------------------+-------+
- * |plusREAL64           |Real64 addition                       |REAL64 |
- * +---------------------+--------------------------------------+-------+
- * |minusINT             |Int32 subtraction                     |INT    |
- * +---------------------+--------------------------------------+-------+
- * |minusUINT            |Unsigned Int32 subtraction            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |minusVAST            |Int64 subtraction                     |VAST   |
- * +---------------------+--------------------------------------+-------+
- * |minusUVAST           |Unsigned Int64 subtraction            |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |minusREAL32          |Real32 subtraction                    |REAL32 |
- * +---------------------+--------------------------------------+-------+
- * |minusREAL64          |Real64 subtraction                    |REAL64 |
- * +---------------------+--------------------------------------+-------+
- * |multINT              |Int32 multiplication                  |INT    |
- * +---------------------+--------------------------------------+-------+
- * |multUINT             |Unsigned Int32 multiplication         |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |multVAST             |Int64 multiplication                  |VAST   |
- * +---------------------+--------------------------------------+-------+
- * |multUVAST            |Unsigned Int64 multiplication         |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |multREAL32           |Real32 multiplication                 |REAL32 |
- * +---------------------+--------------------------------------+-------+
- * |multREAL64           |Real64 multiplication                 |REAL64 |
- * +---------------------+--------------------------------------+-------+
- * |divINT               |Int32 division                        |INT    |
- * +---------------------+--------------------------------------+-------+
- * |divUINT              |Unsigned Int32 division               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |divVAST              |Int64 division                        |VAST   |
- * +---------------------+--------------------------------------+-------+
- * |divUVAST             |Unsigned Int64 division               |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |divREAL32            |Real32 division                       |REAL32 |
- * +---------------------+--------------------------------------+-------+
- * |divREAL64            |Real64 division                       |REAL64 |
- * +---------------------+--------------------------------------+-------+
- * |modINT               |Int32 modulus division                |INT    |
- * +---------------------+--------------------------------------+-------+
- * |modUINT              |Unsigned Int32 modulus division       |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |modVAST              |Int64 modulus division                |VAST   |
- * +---------------------+--------------------------------------+-------+
- * |modUVAST             |Unsigned Int64 modulus division       |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |modREAL32            |Real32 modulus division               |REAL32 |
- * +---------------------+--------------------------------------+-------+
- * |modREAL64            |Real64 modulus division               |REAL64 |
- * +---------------------+--------------------------------------+-------+
- * |expINT               |Int32 exponentiation                  |INT    |
- * +---------------------+--------------------------------------+-------+
- * |expUINT              |Unsigned int32 exponentiation         |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |expVAST              |Int64 exponentiation                  |VAST   |
- * +---------------------+--------------------------------------+-------+
- * |expUVAST             |Unsigned Int64 exponentiation         |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |expREAL32            |Real32 exponentiation                 |REAL32 |
- * +---------------------+--------------------------------------+-------+
- * |expREAL64            |Real64 exponentiation                 |REAL64 |
- * +---------------------+--------------------------------------+-------+
- * |bitAND               |Bitwise and                           |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |bitOR                |Bitwise or                            |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |bitXOR               |Bitwise xor                           |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |bitNOT               |Bitwise not                           |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |logAND               |Logical and                           |BOOL   |
- * +---------------------+--------------------------------------+-------+
- * |logOR                |Logical or                            |BOOL   |
- * +---------------------+--------------------------------------+-------+
- * |logNOT               |Logical not                           |BOOL   |
- * +---------------------+--------------------------------------+-------+
- * |abs                  |absolute value                        |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |lessThan             |<                                     |BOOL   |
- * +---------------------+--------------------------------------+-------+
- * |greaterThan          |>                                     |BOOL   |
- * +---------------------+--------------------------------------+-------+
- * |lessEqual            |<=                                    |BOOL   |
- * +---------------------+--------------------------------------+-------+
- * |greaterEqual         |>=                                    |BOOL   |
- * +---------------------+--------------------------------------+-------+
- * |notEqual             |!=                                    |BOOL   |
- * +---------------------+--------------------------------------+-------+
- * |Equal                |==                                    |BOOL   |
- * +---------------------+--------------------------------------+-------+
- * |bitShiftLeft         |<<                                    |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |bitShiftRight        |>>                                    |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |STOR                 |Store value of parm 2 in parm 1       |UNK    |
- * +---------------------+--------------------------------------+-------+
- */
-#define AMP_AGENT_OP_PLUSINT 0x00
-#define AMP_AGENT_OP_PLUSUINT 0x01
-#define AMP_AGENT_OP_PLUSVAST 0x02
-#define AMP_AGENT_OP_PLUSUVAST 0x03
-#define AMP_AGENT_OP_PLUSREAL32 0x04
-#define AMP_AGENT_OP_PLUSREAL64 0x05
-#define AMP_AGENT_OP_MINUSINT 0x06
-#define AMP_AGENT_OP_MINUSUINT 0x07
-#define AMP_AGENT_OP_MINUSVAST 0x08
-#define AMP_AGENT_OP_MINUSUVAST 0x09
-#define AMP_AGENT_OP_MINUSREAL32 0x0a
-#define AMP_AGENT_OP_MINUSREAL64 0x0b
-#define AMP_AGENT_OP_MULTINT 0x0c
-#define AMP_AGENT_OP_MULTUINT 0x0d
-#define AMP_AGENT_OP_MULTVAST 0x0e
-#define AMP_AGENT_OP_MULTUVAST 0x0f
-#define AMP_AGENT_OP_MULTREAL32 0x10
-#define AMP_AGENT_OP_MULTREAL64 0x11
-#define AMP_AGENT_OP_DIVINT 0x12
-#define AMP_AGENT_OP_DIVUINT 0x13
-#define AMP_AGENT_OP_DIVVAST 0x14
-#define AMP_AGENT_OP_DIVUVAST 0x15
-#define AMP_AGENT_OP_DIVREAL32 0x16
-#define AMP_AGENT_OP_DIVREAL64 0x17
-#define AMP_AGENT_OP_MODINT 0x18
-#define AMP_AGENT_OP_MODUINT 0x19
-#define AMP_AGENT_OP_MODVAST 0x1a
-#define AMP_AGENT_OP_MODUVAST 0x1b
-#define AMP_AGENT_OP_MODREAL32 0x1c
-#define AMP_AGENT_OP_MODREAL64 0x1d
-#define AMP_AGENT_OP_EXPINT 0x1e
-#define AMP_AGENT_OP_EXPUINT 0x1f
-#define AMP_AGENT_OP_EXPVAST 0x20
-#define AMP_AGENT_OP_EXPUVAST 0x21
-#define AMP_AGENT_OP_EXPREAL32 0x22
-#define AMP_AGENT_OP_EXPREAL64 0x23
-#define AMP_AGENT_OP_BITAND 0x24
-#define AMP_AGENT_OP_BITOR 0x25
-#define AMP_AGENT_OP_BITXOR 0x26
-#define AMP_AGENT_OP_BITNOT 0x27
-#define AMP_AGENT_OP_LOGAND 0x28
-#define AMP_AGENT_OP_LOGOR 0x29
-#define AMP_AGENT_OP_LOGNOT 0x2a
-#define AMP_AGENT_OP_ABS 0x2b
-#define AMP_AGENT_OP_LESSTHAN 0x2c
-#define AMP_AGENT_OP_GREATERTHAN 0x2d
-#define AMP_AGENT_OP_LESSEQUAL 0x2e
-#define AMP_AGENT_OP_GREATEREQUAL 0x2f
-#define AMP_AGENT_OP_NOTEQUAL 0x30
-#define AMP_AGENT_OP_EQUAL 0x31
-#define AMP_AGENT_OP_BITSHIFTLEFT 0x32
-#define AMP_AGENT_OP_BITSHIFTRIGHT 0x33
-#define AMP_AGENT_OP_STOR 0x34
-
-/* Initialization functions. */
-void amp_agent_init();
-void amp_agent_init_meta();
-void amp_agent_init_cnst();
-void amp_agent_init_edd();
-void amp_agent_init_op();
-void amp_agent_init_var();
-void amp_agent_init_ctrl();
-void amp_agent_init_mac();
-void amp_agent_init_rpttpl();
-void amp_agent_init_tblt();
-#endif /* _HAVE_AMP_AGENT_ADM_ */
-#endif //ADM_AMP_AGENT_H_
diff --git a/nm/shared/adm/adm_init.c b/nm/shared/adm/adm_init.c
deleted file mode 100644
index c9037fe8..00000000
--- a/nm/shared/adm/adm_init.c
+++ /dev/null
@@ -1,66 +0,0 @@
-
-#include "adm.h"
-
-// ADM Header files.  This listing may be auto-generated in the future
-#include "adm_amp_agent.h"
-#include "adm_bp_agent.h"
-#include "adm_ion_admin.h"
-#include "adm_ion_ipn_admin.h"
-#include "adm_ionsec_admin.h"
-#include "adm_ion_ltp_admin.h"
-#include "adm_ltp_agent.h"
-#include "adm_ion_bp_admin.h"
-
-#ifdef BUILD_BPv6
-#include "adm_sbsp.h"
-#else
-#include "adm_bpsec.h"
-#endif
-
-/******************************************************************************
- *
- * \par Function Name: adm_init
- *
- * \par Initialize pre-configured ADMs.
- *
- * \par Notes:
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- *  11/25/12  E. Birrane     Initial implementation.
- *  12/01/19  D. Edell       Split into adm_common() and adm_common_init() to
- *                             break potential circular dependencies.
- *****************************************************************************/
-
-void adm_init()
-{
-   adm_common_init();
-
-#ifdef ADM_DYNAMIC_LOADER
-	/*
-	  PLACEHOLDER for future dynamic loader concept for target systems supporting dlopen
-	  - List files in configured plugins directory (*.so - extension may vary by OS)
-	  - Filenames shall be of the standard form libAdm$NAME.so
-	  - After loading (dlopen), the function $NAME_init() will be called for each file (dlsym() to lookup).
-	 */
-#else // Default statically defined set
-   // NOTE: The following section may be modified to be auto-generated by Makefile in future.
-	amp_agent_init();
-	dtn_bp_agent_init();
-	dtn_ion_ionadmin_init();
-	dtn_ion_ipnadmin_init();
-	dtn_ion_ionsecadmin_init();
-	dtn_ion_ltpadmin_init();
-	dtn_ltp_agent_init();
-	dtn_ion_bpadmin_init();
-	
-#ifdef BUILD_BPv6
-	dtn_sbsp_init();
-#else
-	dtn_bpsec_init();
-#endif
-
-#endif
-	AMP_DEBUG_EXIT("adm_init","->.", NULL);
-}
diff --git a/nm/shared/adm/adm_ion_admin.h b/nm/shared/adm/adm_ion_admin.h
deleted file mode 100644
index 3bfcab94..00000000
--- a/nm/shared/adm/adm_ion_admin.h
+++ /dev/null
@@ -1,418 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_admin.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-
-#ifndef ADM_ION_ADMIN_H_
-#define ADM_ION_ADMIN_H_
-#define _HAVE_DTN_ION_IONADMIN_ADM_
-#ifdef _HAVE_DTN_ION_IONADMIN_ADM_
-
-#include "shared/utils/nm_types.h"
-#include "shared/adm/adm.h"
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 ADM TEMPLATE DOCUMENTATION                                  +
- * +---------------------------------------------------------------------------------------------+
- *
- * ADM ROOT STRING:DTN/ION/ionadmin
- */
-#define ADM_ENUM_DTN_ION_IONADMIN 7
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AGENT NICKNAME DEFINITIONS                                  +
- * +---------------------------------------------------------------------------------------------+
- */
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                           DTN_ION_IONADMIN META-DATA DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |name                 |The human-readable name of the ADM.   |STR    |ion_admin               |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |namespace            |The namespace of the ADM.             |STR    |DTN/ION/ionadmin        |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |version              |The version of the ADM.               |STR    |v0.0                    |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |organization         |The name of the issuing organization o|       |                        |
- * |                     |f the ADM.                            |STR    |JHUAPL                  |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-// "name"
-#define DTN_ION_IONADMIN_META_NAME 0x00
-// "namespace"
-#define DTN_ION_IONADMIN_META_NAMESPACE 0x01
-// "version"
-#define DTN_ION_IONADMIN_META_VERSION 0x02
-// "organization"
-#define DTN_ION_IONADMIN_META_ORGANIZATION 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                    DTN_ION_IONADMIN EXTERNALLY DEFINED DATA DEFINITIONS                     +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |clock_error          |This is how accurate the ION Agent's c|       |
- * |                     |lock is described as number of seconds|       |
- * |                     |, an absolute value.                  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |clock_sync           |This is whether or not the the compute|       |
- * |                     |r on which the local ION node is runni|       |
- * |                     |ng has a synchronized clock.          |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |congestion_alarm_cont|This is whether or not the node has a |       |
- * |                     |control that will set off alarm if it |       |
- * |                     |will become congested at some future t|       |
- * |                     |ime.                                  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |congestion_end_time_f|This is the time horizon beyond which |       |
- * |                     |we don't attempt to forecast congestio|       |
- * |                     |n                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |consumption_rate     |This is the mean rate of continuous da|       |
- * |                     |ta delivery to local BP applications. |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |inbound_file_system_o|This is the maximum number of megabyte|       |
- * |                     |s of storage space in ION's local file|       |
- * |                     | system that can be used for the stora|       |
- * |                     |ge of inbound zero-copy objects. The d|       |
- * |                     |efault heap limit is 1 Terabyte.      |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |inbound_heap_occupanc|This is the maximum number of megabyte|       |
- * |                     |s of storage space in ION's SDR non-vo|       |
- * |                     |latile heap that can be used for the s|       |
- * |                     |torage of inbound zero-copy objects. T|       |
- * |                     |he default heap limit is 20% of the SD|       |
- * |                     |R data space's total heap size.       |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |number               |This is a CBHE node number which uniqu|       |
- * |                     |ely identifies the node in the delay-t|       |
- * |                     |olerant network.                      |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |outbound_file_system_|This is the maximum number of megabyte|       |
- * |                     |s of storage space in ION's local file|       |
- * |                     | system that can be used for the stora|       |
- * |                     |ge of outbound zero-copy objects. The |       |
- * |                     |default heap limit is 1 Terabyte.     |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |outbound_heap_occupan|This is the maximum number of megabyte|       |
- * |                     |s of storage space in ION's SDR non-vo|       |
- * |                     |latile heap that can be used for the s|       |
- * |                     |torage of outbound zero-copy objects. |       |
- * |                     |The default heap limit is 20% of the S|       |
- * |                     |DR data space's total heap size.      |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |production_rate      |This is the rate of local data product|       |
- * |                     |ion.                                  |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |ref_time             |This is the reference time that will b|       |
- * |                     |e used for interpreting relative time |       |
- * |                     |values from now until the next revisio|       |
- * |                     |n of reference time.                  |TV     |
- * +---------------------+--------------------------------------+-------+
- * |time_delta           |The time delta is used to compensate f|       |
- * |                     |or error (drift) in clocks, particular|       |
- * |                     |ly spacecraft clocks. The hardware clo|       |
- * |                     |ck on a spacecraft might gain or lose |       |
- * |                     |a few seconds every month, to the poin|       |
- * |                     |t at which its understanding of the cu|       |
- * |                     |rrent time - as reported out by the op|       |
- * |                     |erating system - might differ signific|       |
- * |                     |antly from the actual value of Unix Ep|       |
- * |                     |och time as reported by authoritative |       |
- * |                     |clocks on Earth. To compensate for thi|       |
- * |                     |s difference without correcting the cl|       |
- * |                     |ock itself (which can be difficult and|       |
- * |                     | dangerous), ION simply adds the time |       |
- * |                     |delta to the Epoch time reported by th|       |
- * |                     |e operating system.                   |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |version              |This is the version of ION that is cur|       |
- * |                     |rently installed.                     |STR    |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_IONADMIN_EDD_CLOCK_ERROR 0x00
-#define DTN_ION_IONADMIN_EDD_CLOCK_SYNC 0x01
-#define DTN_ION_IONADMIN_EDD_CONGESTION_ALARM_CONTROL 0x02
-#define DTN_ION_IONADMIN_EDD_CONGESTION_END_TIME_FORECASTS 0x03
-#define DTN_ION_IONADMIN_EDD_CONSUMPTION_RATE 0x04
-#define DTN_ION_IONADMIN_EDD_INBOUND_FILE_SYSTEM_OCCUPANCY_LIMIT 0x05
-#define DTN_ION_IONADMIN_EDD_INBOUND_HEAP_OCCUPANCY_LIMIT 0x06
-#define DTN_ION_IONADMIN_EDD_NUMBER 0x07
-#define DTN_ION_IONADMIN_EDD_OUTBOUND_FILE_SYSTEM_OCCUPANCY_LIMIT 0x08
-#define DTN_ION_IONADMIN_EDD_OUTBOUND_HEAP_OCCUPANCY_LIMIT 0x09
-#define DTN_ION_IONADMIN_EDD_PRODUCTION_RATE 0x0a
-#define DTN_ION_IONADMIN_EDD_REF_TIME 0x0b
-#define DTN_ION_IONADMIN_EDD_TIME_DELTA 0x0c
-#define DTN_ION_IONADMIN_EDD_VERSION 0x0d
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IONADMIN VARIABLE DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_IONADMIN REPORT DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_IONADMIN TABLE DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |contacts             |This table shows all scheduled periods|       |
- * |                     | of data transmission.                |       |
- * +---------------------+--------------------------------------+-------+
- * |ranges               |This table shows all predicted periods|       |
- * |                     | of constant distance between nodes.  |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_IONADMIN_TBLT_CONTACTS 0x00
-#define DTN_ION_IONADMIN_TBLT_RANGES 0x01
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IONADMIN CONTROL DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |node_init            |Until this control is executed, the lo|       |
- * |                     |cal ION node does not exist and most i|       |
- * |                     |onadmin controls will fail. The contro|       |
- * |                     |l configures the local node to be iden|       |
- * |                     |tified by node_number, a CBHE node num|       |
- * |                     |ber which uniquely identifies the node|       |
- * |                     | in the delay-tolerant network.  It al|       |
- * |                     |so configures ION's data space (SDR) a|       |
- * |                     |nd shared working-memory region.  For |       |
- * |                     |this purpose it uses a set of default |       |
- * |                     |settings if no argument follows node_n|       |
- * |                     |umber or if the argument following nod|       |
- * |                     |e_number is ''; otherwise it uses the |       |
- * |                     |configuration settings found in a conf|       |
- * |                     |iguration file.  If configuration file|       |
- * |                     | name is provided, then the configurat|       |
- * |                     |ion file's name is implicitly 'hostnam|       |
- * |                     |e.ionconfig'; otherwise, ion_config_fi|       |
- * |                     |lename is taken to be the explicit con|       |
- * |                     |figuration file name.                 |       |
- * +---------------------+--------------------------------------+-------+
- * |node_clock_error_set |This management control sets ION's und|       |
- * |                     |erstanding of the accuracy of the sche|       |
- * |                     |duled start and stop times of planned |       |
- * |                     |contacts, in seconds.  The default val|       |
- * |                     |ue is 1.                              |       |
- * +---------------------+--------------------------------------+-------+
- * |node_clock_sync_set  |This management control reports whethe|       |
- * |                     |r or not the computer on which the loc|       |
- * |                     |al ION node is running has a synchroni|       |
- * |                     |zed clock.                            |       |
- * +---------------------+--------------------------------------+-------+
- * |node_congestion_alarm|This management control establishes a |       |
- * |                     |control which will automatically be ex|       |
- * |                     |ecuted whenever ionadmin predicts that|       |
- * |                     | the node will become congested at som|       |
- * |                     |e future time.                        |       |
- * +---------------------+--------------------------------------+-------+
- * |node_congestion_end_t|This management control sets the end t|       |
- * |                     |ime for computed congestion forecasts.|       |
- * |                     | Setting congestion forecast horizon t|       |
- * |                     |o zero sets the congestion forecast en|       |
- * |                     |d time to infinite time in the future:|       |
- * |                     | if there is any predicted net growth |       |
- * |                     |in bundle storage space occupancy at a|       |
- * |                     |ll, following the end of the last sche|       |
- * |                     |duled contact, then eventual congestio|       |
- * |                     |n will be predicted. The default value|       |
- * |                     | is zero, i.e., no end time.          |       |
- * +---------------------+--------------------------------------+-------+
- * |node_consumption_rate|This management control sets ION's exp|       |
- * |                     |ectation of the mean rate of continuou|       |
- * |                     |s data delivery to local BP applicatio|       |
- * |                     |ns throughout the period of time over |       |
- * |                     |which congestion forecasts are compute|       |
- * |                     |d. For nodes that function only as rou|       |
- * |                     |ters this variable will normally be ze|       |
- * |                     |ro. A value of -1, which is the defaul|       |
- * |                     |t, indicates that the rate of local da|       |
- * |                     |ta consumption is unknown; in that cas|       |
- * |                     |e local data consumption is not consid|       |
- * |                     |ered in the computation of congestion |       |
- * |                     |forecasts.                            |       |
- * +---------------------+--------------------------------------+-------+
- * |node_contact_add     |This control schedules a period of dat|       |
- * |                     |a transmission from source_node to des|       |
- * |                     |t_node. The period of transmission wil|       |
- * |                     |l begin at start_time and end at stop_|       |
- * |                     |time, and the rate of data transmissio|       |
- * |                     |n will be xmit_data_rate bytes/second.|       |
- * |                     | Our confidence in the contact default|       |
- * |                     |s to 1.0, indicating that the contact |       |
- * |                     |is scheduled - not that non-occurrence|       |
- * |                     | of the contact is impossible, just th|       |
- * |                     |at occurrence of the contact is planne|       |
- * |                     |d and scheduled rather than merely imp|       |
- * |                     |uted from past node behavior. In the l|       |
- * |                     |atter case, confidence indicates our e|       |
- * |                     |stimation of the likelihood of this po|       |
- * |                     |tential contact.                      |       |
- * +---------------------+--------------------------------------+-------+
- * |node_contact_del     |This control deletes the scheduled per|       |
- * |                     |iod of data transmission from source_n|       |
- * |                     |ode to dest_node starting at start_tim|       |
- * |                     |e. To delete all contacts between some|       |
- * |                     | pair of nodes, use '*' as start_time.|       |
- * +---------------------+--------------------------------------+-------+
- * |node_inbound_heap_occ|This management control sets the maxim|       |
- * |                     |um number of megabytes of storage spac|       |
- * |                     |e in ION's SDR non-volatile heap that |       |
- * |                     |can be used for the storage of inbound|       |
- * |                     | zero-copy objects. A value of -1 for |       |
- * |                     |either limit signifies 'leave unchange|       |
- * |                     |d'. The default heap limit is 30% of t|       |
- * |                     |he SDR data space's total heap size.  |       |
- * +---------------------+--------------------------------------+-------+
- * |node_outbound_heap_oc|This management control sets the maxim|       |
- * |                     |um number of megabytes of storage spac|       |
- * |                     |e in ION's SDR non-volatile heap that |       |
- * |                     |can be used for the storage of outboun|       |
- * |                     |d zero-copy objects.  A value of  -1 f|       |
- * |                     |or either limit signifies 'leave uncha|       |
- * |                     |nged'. The default heap  limit is 30% |       |
- * |                     |of the SDR data space's total heap siz|       |
- * |                     |e.                                    |       |
- * +---------------------+--------------------------------------+-------+
- * |node_production_rate_|This management control sets ION's exp|       |
- * |                     |ectation of the mean rate of continuou|       |
- * |                     |s data origination by local BP applica|       |
- * |                     |tions throughout the period of time ov|       |
- * |                     |er which congestion forecasts are comp|       |
- * |                     |uted. For nodes that function only as |       |
- * |                     |routers this variable will normally be|       |
- * |                     | zero. A value of -1, which is the def|       |
- * |                     |ault, indicates that the rate of local|       |
- * |                     | data production is unknown; in that c|       |
- * |                     |ase local data production is not consi|       |
- * |                     |dered in the computation of congestion|       |
- * |                     | forecasts.                           |       |
- * +---------------------+--------------------------------------+-------+
- * |node_range_add       |This control predicts a period of time|       |
- * |                     | during which the distance from node t|       |
- * |                     |o other_node will be constant to withi|       |
- * |                     |n one light second. The period will be|       |
- * |                     |gin at start_time and end at stop_time|       |
- * |                     |, and the distance between the nodes d|       |
- * |                     |uring that time will be distance light|       |
- * |                     | seconds.                             |       |
- * +---------------------+--------------------------------------+-------+
- * |node_range_del       |This control deletes the predicted per|       |
- * |                     |iod of constant distance between node |       |
- * |                     |and other_node starting at start_time.|       |
- * |                     | To delete all ranges between some pai|       |
- * |                     |r of nodes, use '*' as start_time.    |       |
- * +---------------------+--------------------------------------+-------+
- * |node_ref_time_set    |This is used to set the reference time|       |
- * |                     | that will be used for interpreting re|       |
- * |                     |lative time values from now until the |       |
- * |                     |next revision of reference time. Note |       |
- * |                     |that the new reference time can be a r|       |
- * |                     |elative time, i.e., an offset beyond t|       |
- * |                     |he current reference time.            |       |
- * +---------------------+--------------------------------------+-------+
- * |node_time_delta_set  |This management control sets ION's und|       |
- * |                     |erstanding of the current difference b|       |
- * |                     |etween correct time and the Unix Epoch|       |
- * |                     | time values reported by the clock for|       |
- * |                     | the local ION node's computer. This d|       |
- * |                     |elta is automatically applied to local|       |
- * |                     |ly obtained time values whenever ION n|       |
- * |                     |eeds to know the current time.        |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_IONADMIN_CTRL_NODE_INIT 0x00
-#define DTN_ION_IONADMIN_CTRL_NODE_CLOCK_ERROR_SET 0x01
-#define DTN_ION_IONADMIN_CTRL_NODE_CLOCK_SYNC_SET 0x02
-#define DTN_ION_IONADMIN_CTRL_NODE_CONGESTION_ALARM_CONTROL_SET 0x03
-#define DTN_ION_IONADMIN_CTRL_NODE_CONGESTION_END_TIME_FORECASTS_SET 0x04
-#define DTN_ION_IONADMIN_CTRL_NODE_CONSUMPTION_RATE_SET 0x05
-#define DTN_ION_IONADMIN_CTRL_NODE_CONTACT_ADD 0x06
-#define DTN_ION_IONADMIN_CTRL_NODE_CONTACT_DEL 0x07
-#define DTN_ION_IONADMIN_CTRL_NODE_INBOUND_HEAP_OCCUPANCY_LIMIT_SET 0x08
-#define DTN_ION_IONADMIN_CTRL_NODE_OUTBOUND_HEAP_OCCUPANCY_LIMIT_SET 0x09
-#define DTN_ION_IONADMIN_CTRL_NODE_PRODUCTION_RATE_SET 0x0a
-#define DTN_ION_IONADMIN_CTRL_NODE_RANGE_ADD 0x0b
-#define DTN_ION_IONADMIN_CTRL_NODE_RANGE_DEL 0x0c
-#define DTN_ION_IONADMIN_CTRL_NODE_REF_TIME_SET 0x0d
-#define DTN_ION_IONADMIN_CTRL_NODE_TIME_DELTA_SET 0x0e
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IONADMIN CONSTANT DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_IONADMIN MACRO DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IONADMIN OPERATOR DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-/* Initialization functions. */
-void dtn_ion_ionadmin_init();
-void dtn_ion_ionadmin_init_meta();
-void dtn_ion_ionadmin_init_cnst();
-void dtn_ion_ionadmin_init_edd();
-void dtn_ion_ionadmin_init_op();
-void dtn_ion_ionadmin_init_var();
-void dtn_ion_ionadmin_init_ctrl();
-void dtn_ion_ionadmin_init_mac();
-void dtn_ion_ionadmin_init_rpttpl();
-void dtn_ion_ionadmin_init_tblt();
-#endif /* _HAVE_DTN_ION_IONADMIN_ADM_ */
-#endif //ADM_ION_ADMIN_H_
\ No newline at end of file
diff --git a/nm/shared/adm/adm_ion_ipn_admin.h b/nm/shared/adm/adm_ion_ipn_admin.h
deleted file mode 100644
index 94152581..00000000
--- a/nm/shared/adm/adm_ion_ipn_admin.h
+++ /dev/null
@@ -1,193 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ipn_admin.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-
-#ifndef ADM_ION_IPN_ADMIN_H_
-#define ADM_ION_IPN_ADMIN_H_
-#define _HAVE_DTN_ION_IPNADMIN_ADM_
-#ifdef _HAVE_DTN_ION_IPNADMIN_ADM_
-
-#include "shared/utils/nm_types.h"
-#include "shared/adm/adm.h"
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 ADM TEMPLATE DOCUMENTATION                                  +
- * +---------------------------------------------------------------------------------------------+
- *
- * ADM ROOT STRING:DTN/ION/ipnadmin
- */
-#define ADM_ENUM_DTN_ION_IPNADMIN 6
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AGENT NICKNAME DEFINITIONS                                  +
- * +---------------------------------------------------------------------------------------------+
- */
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                           DTN_ION_IPNADMIN META-DATA DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |name                 |The human-readable name of the ADM.   |STR    |ion_ipn_admin           |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |namespace            |The namespace of the ADM              |STR    |DTN/ION/ipnadmin        |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |version              |The version of the ADM                |STR    |v0.0                    |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |organization         |The name of the issuing organization o|       |                        |
- * |                     |f the ADM                             |STR    |JHUAPL                  |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-// "name"
-#define DTN_ION_IPNADMIN_META_NAME 0x00
-// "namespace"
-#define DTN_ION_IPNADMIN_META_NAMESPACE 0x01
-// "version"
-#define DTN_ION_IPNADMIN_META_VERSION 0x02
-// "organization"
-#define DTN_ION_IPNADMIN_META_ORGANIZATION 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                    DTN_ION_IPNADMIN EXTERNALLY DEFINED DATA DEFINITIONS                     +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |ion_version          |This is the version of ion is that cur|       |
- * |                     |rently installed.                     |STR    |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_IPNADMIN_EDD_ION_VERSION 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IPNADMIN VARIABLE DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_IPNADMIN REPORT DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_IPNADMIN TABLE DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |exits                |This table lists all of the exits that|       |
- * |                     | are defined in the IPN database for t|       |
- * |                     |he local node.                        |       |
- * +---------------------+--------------------------------------+-------+
- * |plans                |This table lists all of the egress pla|       |
- * |                     |ns that are established in the IPN dat|       |
- * |                     |abase for the local node.             |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_IPNADMIN_TBLT_EXITS 0x00
-#define DTN_ION_IPNADMIN_TBLT_PLANS 0x01
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IPNADMIN CONTROL DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |exit_add             |This control establishes an exit for s|       |
- * |                     |tatic default routing.                |       |
- * +---------------------+--------------------------------------+-------+
- * |exit_change          |This control changes the gateway node |       |
- * |                     |number for the exit identified by firs|       |
- * |                     |tNodeNbr and lastNodeNbr.             |       |
- * +---------------------+--------------------------------------+-------+
- * |exit_del             |This control deletes the exit identifi|       |
- * |                     |ed by firstNodeNbr and lastNodeNbr.   |       |
- * +---------------------+--------------------------------------+-------+
- * |plan_add             |This control establishes an egress pla|       |
- * |                     |n for the bundles that must be transmi|       |
- * |                     |tted to the neighboring node that is i|       |
- * |                     |dentified by it's nodeNbr.            |       |
- * +---------------------+--------------------------------------+-------+
- * |plan_change          |This control changes the duct expressi|       |
- * |                     |on for the indicated plan.            |       |
- * +---------------------+--------------------------------------+-------+
- * |plan_del             |This control deletes the egress plan f|       |
- * |                     |or the node that is identified by it's|       |
- * |                     | nodeNbr.                             |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_IPNADMIN_CTRL_EXIT_ADD 0x00
-#define DTN_ION_IPNADMIN_CTRL_EXIT_CHANGE 0x01
-#define DTN_ION_IPNADMIN_CTRL_EXIT_DEL 0x02
-#define DTN_ION_IPNADMIN_CTRL_PLAN_ADD 0x03
-#define DTN_ION_IPNADMIN_CTRL_PLAN_CHANGE 0x04
-#define DTN_ION_IPNADMIN_CTRL_PLAN_DEL 0x05
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IPNADMIN CONSTANT DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_IPNADMIN MACRO DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IPNADMIN OPERATOR DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-/* Initialization functions. */
-void dtn_ion_ipnadmin_init();
-void dtn_ion_ipnadmin_init_meta();
-void dtn_ion_ipnadmin_init_cnst();
-void dtn_ion_ipnadmin_init_edd();
-void dtn_ion_ipnadmin_init_op();
-void dtn_ion_ipnadmin_init_var();
-void dtn_ion_ipnadmin_init_ctrl();
-void dtn_ion_ipnadmin_init_mac();
-void dtn_ion_ipnadmin_init_rpttpl();
-void dtn_ion_ipnadmin_init_tblt();
-#endif /* _HAVE_DTN_ION_IPNADMIN_ADM_ */
-#endif //ADM_ION_IPN_ADMIN_H_
\ No newline at end of file
diff --git a/nm/shared/adm/adm_ion_ltp_admin.h b/nm/shared/adm/adm_ion_ltp_admin.h
deleted file mode 100644
index 62730f8b..00000000
--- a/nm/shared/adm/adm_ion_ltp_admin.h
+++ /dev/null
@@ -1,269 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ion_ltp_admin.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-
-#ifndef ADM_ION_LTP_ADMIN_H_
-#define ADM_ION_LTP_ADMIN_H_
-#define _HAVE_DTN_ION_LTPADMIN_ADM_
-#ifdef _HAVE_DTN_ION_LTPADMIN_ADM_
-
-#include "shared/utils/nm_types.h"
-#include "shared/adm/adm.h"
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 ADM TEMPLATE DOCUMENTATION                                  +
- * +---------------------------------------------------------------------------------------------+
- *
- * ADM ROOT STRING:DTN/ION/ltpadmin
- */
-#define ADM_ENUM_DTN_ION_LTPADMIN 9
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AGENT NICKNAME DEFINITIONS                                  +
- * +---------------------------------------------------------------------------------------------+
- */
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                           DTN_ION_LTPADMIN META-DATA DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |name                 |The human-readable name of the ADM.   |STR    |ion_ltp_admin           |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |namespace            |The namespace of the ADM.             |STR    |DTN/ION/ltpadmin        |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |version              |The version of the ADM.               |STR    |v0.0                    |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |organization         |The name of the issuing organization o|       |                        |
- * |                     |f the ADM.                            |STR    |JHUAPL                  |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-// "name"
-#define DTN_ION_LTPADMIN_META_NAME 0x00
-// "namespace"
-#define DTN_ION_LTPADMIN_META_NAMESPACE 0x01
-// "version"
-#define DTN_ION_LTPADMIN_META_VERSION 0x02
-// "organization"
-#define DTN_ION_LTPADMIN_META_ORGANIZATION 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                    DTN_ION_LTPADMIN EXTERNALLY DEFINED DATA DEFINITIONS                     +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |ion_version          |This is the version of ION that is cur|       |
- * |                     |rently installed.                     |STR    |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_LTPADMIN_EDD_ION_VERSION 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_LTPADMIN VARIABLE DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_LTPADMIN REPORT DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_LTPADMIN TABLE DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |spans                |This table lists all spans of potentia|       |
- * |                     |l LTP data interchange that exists bet|       |
- * |                     |ween the local LTP engine and the indi|       |
- * |                     |cated (neighboring) LTP engine.       |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_LTPADMIN_TBLT_SPANS 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_LTPADMIN CONTROL DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |manage_heap          |This control declares the maximum numb|       |
- * |                     |er of bytes of SDR heap space that wil|       |
- * |                     |l be occupied by the acquisition of an|       |
- * |                     |y single LTP block. All data acquired |       |
- * |                     |in excess of this limit will be writte|       |
- * |                     |n to a temporary file pending extracti|       |
- * |                     |on and dispatching of the acquired blo|       |
- * |                     |ck. Default is the minimum allowed val|       |
- * |                     |ue (560 bytes), which is the approxima|       |
- * |                     |te size of a ZCO file reference object|       |
- * |                     |; this is the minimum SDR heap space o|       |
- * |                     |ccupancy in the event that all acquisi|       |
- * |                     |tion is into a file.                  |       |
- * +---------------------+--------------------------------------+-------+
- * |manage_max_ber       |This control sets the expected maximum|       |
- * |                     | bit error rate(BER) that LTP should p|       |
- * |                     |rovide for in computing the maximum nu|       |
- * |                     |mber of transmission efforts to initia|       |
- * |                     |te in the transmission of a given bloc|       |
- * |                     |k.(Note that this computation is also |       |
- * |                     |sensitive to data segment size and to |       |
- * |                     |the size of the block that is to be tr|       |
- * |                     |ansmitted.) The default value is .0001|       |
- * |                     | (10^-4).                             |       |
- * +---------------------+--------------------------------------+-------+
- * |manage_own_queue_time|This control sets the number of second|       |
- * |                     |s of predicted additional latency attr|       |
- * |                     |ibutable to processing delay within th|       |
- * |                     |e local engine itself that should be i|       |
- * |                     |ncluded whenever LTP computes the nomi|       |
- * |                     |nal round-trip time for an exchange of|       |
- * |                     | data with any remote engine.The defau|       |
- * |                     |lt value is 1.                        |       |
- * +---------------------+--------------------------------------+-------+
- * |manage_screening     |This control enables or disables the s|       |
- * |                     |creening of received LTP segments per |       |
- * |                     |the periods of scheduled reception in |       |
- * |                     |the node's contact graph. By default, |       |
- * |                     |screening is disabled. When screening |       |
- * |                     |is enabled, such segments are silently|       |
- * |                     | discarded. Note that when screening i|       |
- * |                     |s enabled the ranges declared in the c|       |
- * |                     |ontact graph must be accurate and cloc|       |
- * |                     |ks must be synchronized; otherwise, se|       |
- * |                     |gments will be arriving at times other|       |
- * |                     | than the scheduled contact intervals |       |
- * |                     |and will be discarded.                |       |
- * +---------------------+--------------------------------------+-------+
- * |span_add             |This control declares that a span of p|       |
- * |                     |otential LTP data interchange exists b|       |
- * |                     |etween the local LTP engine and the in|       |
- * |                     |dicated (neighboring) LTP engine.     |       |
- * +---------------------+--------------------------------------+-------+
- * |span_change          |This control sets the indicated span's|       |
- * |                     | configuration parameters to the value|       |
- * |                     |s provided as arguments               |       |
- * +---------------------+--------------------------------------+-------+
- * |span_del             |This control deletes the span identifi|       |
- * |                     |ed by peerEngineNumber. The control wi|       |
- * |                     |ll fail if any outbound segments for t|       |
- * |                     |his span are pending transmission or a|       |
- * |                     |ny inbound blocks from the peer engine|       |
- * |                     | are incomplete.                      |       |
- * +---------------------+--------------------------------------+-------+
- * |stop                 |This control stops all link service in|       |
- * |                     |put and output tasks for the local LTP|       |
- * |                     | engine.                              |       |
- * +---------------------+--------------------------------------+-------+
- * |watch_set            |This control enables and disables prod|       |
- * |                     |uction of a continuous stream of user-|       |
- * |                     | selected LTP activity indication char|       |
- * |                     |acters. Activity parameter of 1 select|       |
- * |                     |s all LTP activity indication characte|       |
- * |                     |rs; 0 de-selects all LTP activity indi|       |
- * |                     |cation characters; any other activityS|       |
- * |                     |pec such as df{] selects all activity |       |
- * |                     |indication characters in the string, d|       |
- * |                     |e-selecting all others. LTP will print|       |
- * |                     | each selected activity indication cha|       |
- * |                     |racter to stdout every time a processi|       |
- * |                     |ng event of the associated type occurs|       |
- * |                     |: d bundle appended to block for next |       |
- * |                     |session, e segment of block is queued |       |
- * |                     |for transmission, f block has been ful|       |
- * |                     |ly segmented for transmission, g segme|       |
- * |                     |nt popped from transmission queue, h p|       |
- * |                     |ositive ACK received for block and ses|       |
- * |                     |sion ended, s segment received, t bloc|       |
- * |                     |k has been fully received, @ negative |       |
- * |                     |ACK received for block and segments re|       |
- * |                     |transmitted, = unacknowledged checkpoi|       |
- * |                     |nt was retransmitted, + unacknowledged|       |
- * |                     | report segment was retransmitted, { e|       |
- * |                     |xport session canceled locally (by sen|       |
- * |                     |der), } import session canceled by rem|       |
- * |                     |ote sender, [ import session canceled |       |
- * |                     |locally (by receiver), ] export sessio|       |
- * |                     |n canceled by remote receiver         |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_LTPADMIN_CTRL_MANAGE_HEAP 0x00
-#define DTN_ION_LTPADMIN_CTRL_MANAGE_MAX_BER 0x01
-#define DTN_ION_LTPADMIN_CTRL_MANAGE_OWN_QUEUE_TIME 0x02
-#define DTN_ION_LTPADMIN_CTRL_MANAGE_SCREENING 0x03
-#define DTN_ION_LTPADMIN_CTRL_SPAN_ADD 0x04
-#define DTN_ION_LTPADMIN_CTRL_SPAN_CHANGE 0x05
-#define DTN_ION_LTPADMIN_CTRL_SPAN_DEL 0x06
-#define DTN_ION_LTPADMIN_CTRL_STOP 0x07
-#define DTN_ION_LTPADMIN_CTRL_WATCH_SET 0x08
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_LTPADMIN CONSTANT DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_ION_LTPADMIN MACRO DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_LTPADMIN OPERATOR DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-/* Initialization functions. */
-void dtn_ion_ltpadmin_init();
-void dtn_ion_ltpadmin_init_meta();
-void dtn_ion_ltpadmin_init_cnst();
-void dtn_ion_ltpadmin_init_edd();
-void dtn_ion_ltpadmin_init_op();
-void dtn_ion_ltpadmin_init_var();
-void dtn_ion_ltpadmin_init_ctrl();
-void dtn_ion_ltpadmin_init_mac();
-void dtn_ion_ltpadmin_init_rpttpl();
-void dtn_ion_ltpadmin_init_tblt();
-#endif /* _HAVE_DTN_ION_LTPADMIN_ADM_ */
-#endif //ADM_ION_LTP_ADMIN_H_
\ No newline at end of file
diff --git a/nm/shared/adm/adm_ionsec_admin.h b/nm/shared/adm/adm_ionsec_admin.h
deleted file mode 100644
index 4650154d..00000000
--- a/nm/shared/adm/adm_ionsec_admin.h
+++ /dev/null
@@ -1,252 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ionsec_admin.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-
-#ifndef ADM_IONSEC_ADMIN_H_
-#define ADM_IONSEC_ADMIN_H_
-#define _HAVE_DTN_ION_IONSECADMIN_ADM_
-#ifdef _HAVE_DTN_ION_IONSECADMIN_ADM_
-
-#include "shared/utils/nm_types.h"
-#include "shared/adm/adm.h"
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 ADM TEMPLATE DOCUMENTATION                                  +
- * +---------------------------------------------------------------------------------------------+
- *
- * ADM ROOT STRING:DTN/ION/ionsecadmin
- */
-#define ADM_ENUM_DTN_ION_IONSECADMIN 8
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AGENT NICKNAME DEFINITIONS                                  +
- * +---------------------------------------------------------------------------------------------+
- */
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                          DTN_ION_IONSECADMIN META-DATA DEFINITIONS                          +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |name                 |The human-readable name of the ADM.   |STR    |ionsec_admin            |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |namespace            |The namespace of the ADM.             |STR    |DTN/ION/ionsecadmin     |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |version              |The version of the ADM.               |STR    |v0.0                    |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |organization         |The name of the issuing organization o|       |                        |
- * |                     |f the ADM.                            |STR    |JHUAPL                  |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-// "name"
-#define DTN_ION_IONSECADMIN_META_NAME 0x00
-// "namespace"
-#define DTN_ION_IONSECADMIN_META_NAMESPACE 0x01
-// "version"
-#define DTN_ION_IONSECADMIN_META_VERSION 0x02
-// "organization"
-#define DTN_ION_IONSECADMIN_META_ORGANIZATION 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                   DTN_ION_IONSECADMIN EXTERNALLY DEFINED DATA DEFINITIONS                   +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                          DTN_ION_IONSECADMIN VARIABLE DEFINITIONS                           +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                           DTN_ION_IONSECADMIN REPORT DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IONSECADMIN TABLE DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |ltp_rx_rules         |This table lists all LTP segment authe|       |
- * |                     |ntication rulesin the security policy |       |
- * |                     |database.                             |       |
- * +---------------------+--------------------------------------+-------+
- * |ltp_tx_rules         |This table lists all LTP segment signi|       |
- * |                     |ng rules in the security policy databa|       |
- * |                     |se.                                   |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_IONSECADMIN_TBLT_LTP_RX_RULES 0x00
-#define DTN_ION_IONSECADMIN_TBLT_LTP_TX_RULES 0x01
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                           DTN_ION_IONSECADMIN CONTROL DEFINITIONS                           +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |key_add              |This control adds a named key value to|       |
- * |                     | the security policy database. The con|       |
- * |                     |tent of file_name is taken as the valu|       |
- * |                     |e of the key.Named keys can be referen|       |
- * |                     |ced by other elements of thesecurity p|       |
- * |                     |olicy database.                       |       |
- * +---------------------+--------------------------------------+-------+
- * |key_change           |This control changes the value of the |       |
- * |                     |named key, obtaining the new key value|       |
- * |                     | from the content of file_name.       |       |
- * +---------------------+--------------------------------------+-------+
- * |key_del              |This control deletes the key identifie|       |
- * |                     |d by name.                            |       |
- * +---------------------+--------------------------------------+-------+
- * |ltp_rx_rule_add      |This control adds a rule specifying th|       |
- * |                     |e manner in which LTP segment authenti|       |
- * |                     |cation will be applied to LTP segments|       |
- * |                     |recieved from the indicated LTP engine|       |
- * |                     |. A segment from the indicated LTP eng|       |
- * |                     |ine will only be deemed authentic if i|       |
- * |                     |t contains an authentication extension|       |
- * |                     | computed via the ciphersuite identifi|       |
- * |                     |ed by ciphersuite_nbr using the applic|       |
- * |                     |able key value. If ciphersuite_nbr is |       |
- * |                     |255 then the applicable key value is a|       |
- * |                     | hard-coded constant and key_name must|       |
- * |                     | be omitted; otherwise key_nameis requ|       |
- * |                     |ired and the applicable key value is t|       |
- * |                     |he current value of the key named key_|       |
- * |                     |name in the local security policy data|       |
- * |                     |base. Valid values of ciphersuite_nbr |       |
- * |                     |are: 0: HMAC-SHA1-80 1: RSA-SHA256 255|       |
- * |                     |: NULL                                |       |
- * +---------------------+--------------------------------------+-------+
- * |ltp_rx_rule_change   |This control changes the parameters of|       |
- * |                     | the LTP segment authentication rule f|       |
- * |                     |or the indicated LTP engine.          |       |
- * +---------------------+--------------------------------------+-------+
- * |ltp_rx_rule_del      |This control deletes the LTP segment a|       |
- * |                     |uthentication rule for the indicated L|       |
- * |                     |TP engine.                            |       |
- * +---------------------+--------------------------------------+-------+
- * |ltp_tx_rule_add      |This control adds a rule specifying th|       |
- * |                     |e manner in which LTP segments transmi|       |
- * |                     |tted to the indicated LTP engine mustb|       |
- * |                     |e signed. Signing a segment destined f|       |
- * |                     |or the indicated LTP engineentails com|       |
- * |                     |puting an authentication extension via|       |
- * |                     | the ciphersuite identified by ciphers|       |
- * |                     |uite_nbr using the applicable key valu|       |
- * |                     |e. If ciphersuite_nbr is 255 then the |       |
- * |                     |applicable key value is a hard-coded c|       |
- * |                     |onstant and key_name must be omitted; |       |
- * |                     |otherwise key_nameis required and the |       |
- * |                     |applicable key value is the current va|       |
- * |                     |lue of the key named key_name in the l|       |
- * |                     |ocal security policy database.Valid va|       |
- * |                     |lues of ciphersuite_nbr are: 0:HMAC_SH|       |
- * |                     |A1-80 1: RSA_SHA256 255: NULL         |       |
- * +---------------------+--------------------------------------+-------+
- * |ltp_tx_rule_change   |This control changes the parameters of|       |
- * |                     | the LTP segment signing rule for the |       |
- * |                     |indicated LTP engine.                 |       |
- * +---------------------+--------------------------------------+-------+
- * |ltp_tx_rule_del      |This control deletes the LTP segment s|       |
- * |                     |igning rule forthe indicated LTP engin|       |
- * |                     |e.                                    |       |
- * +---------------------+--------------------------------------+-------+
- * |list_keys            |This control lists the names of keys a|       |
- * |                     |vailable in the key policy database.  |       |
- * +---------------------+--------------------------------------+-------+
- * |list_ltp_rx_rules    |This control lists all LTP segment aut|       |
- * |                     |hentication rules in the security poli|       |
- * |                     |cy database.                          |       |
- * +---------------------+--------------------------------------+-------+
- * |list_ltp_tx_rules    |This control lists all LTP segment sig|       |
- * |                     |ning rules in the security policy data|       |
- * |                     |base.                                 |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_ION_IONSECADMIN_CTRL_KEY_ADD 0x00
-#define DTN_ION_IONSECADMIN_CTRL_KEY_CHANGE 0x01
-#define DTN_ION_IONSECADMIN_CTRL_KEY_DEL 0x02
-#define DTN_ION_IONSECADMIN_CTRL_LTP_RX_RULE_ADD 0x03
-#define DTN_ION_IONSECADMIN_CTRL_LTP_RX_RULE_CHANGE 0x04
-#define DTN_ION_IONSECADMIN_CTRL_LTP_RX_RULE_DEL 0x05
-#define DTN_ION_IONSECADMIN_CTRL_LTP_TX_RULE_ADD 0x06
-#define DTN_ION_IONSECADMIN_CTRL_LTP_TX_RULE_CHANGE 0x07
-#define DTN_ION_IONSECADMIN_CTRL_LTP_TX_RULE_DEL 0x08
-#define DTN_ION_IONSECADMIN_CTRL_LIST_KEYS 0x09
-#define DTN_ION_IONSECADMIN_CTRL_LIST_LTP_RX_RULES 0x0a
-#define DTN_ION_IONSECADMIN_CTRL_LIST_LTP_TX_RULES 0x0b
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                          DTN_ION_IONSECADMIN CONSTANT DEFINITIONS                           +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                            DTN_ION_IONSECADMIN MACRO DEFINITIONS                            +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                          DTN_ION_IONSECADMIN OPERATOR DEFINITIONS                           +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-/* Initialization functions. */
-void dtn_ion_ionsecadmin_init();
-void dtn_ion_ionsecadmin_init_meta();
-void dtn_ion_ionsecadmin_init_cnst();
-void dtn_ion_ionsecadmin_init_edd();
-void dtn_ion_ionsecadmin_init_op();
-void dtn_ion_ionsecadmin_init_var();
-void dtn_ion_ionsecadmin_init_ctrl();
-void dtn_ion_ionsecadmin_init_mac();
-void dtn_ion_ionsecadmin_init_rpttpl();
-void dtn_ion_ionsecadmin_init_tblt();
-#endif /* _HAVE_DTN_ION_IONSECADMIN_ADM_ */
-#endif //ADM_IONSEC_ADMIN_H_
\ No newline at end of file
diff --git a/nm/shared/adm/adm_ltp_agent.h b/nm/shared/adm/adm_ltp_agent.h
deleted file mode 100644
index 04bedc99..00000000
--- a/nm/shared/adm/adm_ltp_agent.h
+++ /dev/null
@@ -1,330 +0,0 @@
-/****************************************************************************
- **
- ** File Name: adm_ltp_agent.h
- **
- ** Description: TODO
- **
- ** Notes: TODO
- **
- ** Assumptions: TODO
- **
- ** Modification History: 
- **  YYYY-MM-DD  AUTHOR           DESCRIPTION
- **  ----------  --------------   --------------------------------------------
- **  2020-04-13  AUTO             Auto-generated header file 
- **
- ****************************************************************************/
-
-
-#ifndef ADM_LTP_AGENT_H_
-#define ADM_LTP_AGENT_H_
-#define _HAVE_DTN_LTP_AGENT_ADM_
-#ifdef _HAVE_DTN_LTP_AGENT_ADM_
-
-#include "shared/utils/nm_types.h"
-#include "shared/adm/adm.h"
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 ADM TEMPLATE DOCUMENTATION                                  +
- * +---------------------------------------------------------------------------------------------+
- *
- * ADM ROOT STRING:DTN/ltp_agent
- */
-#define ADM_ENUM_DTN_LTP_AGENT 3
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                                 AGENT NICKNAME DEFINITIONS                                  +
- * +---------------------------------------------------------------------------------------------+
- */
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_LTP_AGENT META-DATA DEFINITIONS                             +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |name                 |The human-readable name of the ADM.   |STR    |ltp_agent               |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |namespace            |The namespace of the ADM.             |STR    |DTN/ltp_agent           |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |version              |The version of the ADM.               |STR    |v0.0                    |
- * +---------------------+--------------------------------------+-------+------------------------+
- * |organization         |The name of the issuing organization o|       |                        |
- * |                     |f the ADM.                            |STR    |JHUAPL                  |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-// "name"
-#define DTN_LTP_AGENT_META_NAME 0x00
-// "namespace"
-#define DTN_LTP_AGENT_META_NAMESPACE 0x01
-// "version"
-#define DTN_LTP_AGENT_META_VERSION 0x02
-// "organization"
-#define DTN_LTP_AGENT_META_ORGANIZATION 0x03
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                      DTN_LTP_AGENT EXTERNALLY DEFINED DATA DEFINITIONS                      +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |span_remote_engine_nb|The remote engine number of this span.|UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_cur_expt_sess   |Expected sessions on this span.       |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_cur_out_seg     |The current number of outbound segment|       |
- * |                     |s for this span.                      |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_cur_imp_sess    |The current number of import segments |       |
- * |                     |for this span.                        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_cur_in_seg      |The current number of inbound segments|       |
- * |                     | for this span.                       |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_reset_time      |The last time the span counters were r|       |
- * |                     |eset.                                 |UVAST  |
- * +---------------------+--------------------------------------+-------+
- * |span_out_seg_q_cnt   |The output segment queued count for th|       |
- * |                     |e span.                               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_seg_q_bytes |The output segment queued bytes for th|       |
- * |                     |e span.                               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_seg_pop_cnt |The output segment popped count for th|       |
- * |                     |e span.                               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_seg_pop_byte|The output segment popped bytes for th|       |
- * |                     |e span.                               |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_ckpt_xmit_cn|The output checkpoint transmit count f|       |
- * |                     |or the span.                          |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_pos_ack_rx_c|The output positive acknowledgement re|       |
- * |                     |ceived count for the span.            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_neg_ack_rx_c|The output negative acknowledgement re|       |
- * |                     |ceived count for the span.            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_cancel_rx_cn|The output cancelled received count fo|       |
- * |                     |r the span.                           |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_ckpt_rexmit_|The output checkpoint retransmit count|       |
- * |                     | for the span.                        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_cancel_xmit_|The output cancel retransmit count for|       |
- * |                     | the span.                            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_out_complete_cnt|The output completed count for the spa|       |
- * |                     |n.                                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_red_cn|The input segment received red count f|       |
- * |                     |or the span.                          |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_red_by|The input segment received red bytes f|       |
- * |                     |or the span.                          |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_green_|The input segment received green count|       |
- * |                     | for the span.                        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_green_|The input segment received green bytes|       |
- * |                     | for the span.                        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_redund|The input segment received redundant c|       |
- * |                     |ount for the span.                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_redund|The input segment received redundant b|       |
- * |                     |ytes for the span.                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_mal_cn|The input segment malformed count for |       |
- * |                     |the span.                             |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_mal_by|The input segment malformed bytes for |       |
- * |                     |the span.                             |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_unk_se|The input segment unknown sender count|       |
- * |                     | for the span.                        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_unk_se|The input segment unknown sender bytes|       |
- * |                     | for the span.                        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_unk_cl|The input segment unknown client count|       |
- * |                     | for the span.                        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_rx_unk_cl|The input segment unknown client bytes|       |
- * |                     | for the span.                        |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_stray_cnt|The input segment stray count for the |       |
- * |                     |span.                                 |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_stray_byt|The input segment stray bytes for the |       |
- * |                     |span.                                 |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_miscolor_|The input segment miscolored count for|       |
- * |                     | the span.                            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_miscolor_|The input segment miscolored bytes for|       |
- * |                     | the span.                            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_closed_cn|The input segment closed count for the|       |
- * |                     | span.                                |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_seg_closed_by|The input segment closed bytes for the|       |
- * |                     | span.                                |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_ckpt_rx_cnt  |The input checkpoint receive count for|       |
- * |                     | the span.                            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_pos_ack_tx_cn|The input positive acknolwedgement tra|       |
- * |                     |nsmitted count for the span.          |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_neg_ack_tx_cn|The input negative acknolwedgement tra|       |
- * |                     |nsmitted count for the span.          |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_cancel_tx_cnt|The input cancel transmitted count for|       |
- * |                     | the span.                            |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_ack_retx_cnt |The input acknolwedgement retransmit c|       |
- * |                     |ount for the span.                    |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_cancel_rx_cnt|The input cancel receive count for the|       |
- * |                     | span.                                |UINT   |
- * +---------------------+--------------------------------------+-------+
- * |span_in_complete_cnt |The input completed count for the span|       |
- * |                     |.                                     |UINT   |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_LTP_AGENT_EDD_SPAN_REMOTE_ENGINE_NBR 0x00
-#define DTN_LTP_AGENT_EDD_SPAN_CUR_EXPT_SESS 0x01
-#define DTN_LTP_AGENT_EDD_SPAN_CUR_OUT_SEG 0x02
-#define DTN_LTP_AGENT_EDD_SPAN_CUR_IMP_SESS 0x03
-#define DTN_LTP_AGENT_EDD_SPAN_CUR_IN_SEG 0x04
-#define DTN_LTP_AGENT_EDD_SPAN_RESET_TIME 0x05
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_CNT 0x06
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_Q_BYTES 0x07
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_CNT 0x08
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_SEG_POP_BYTES 0x09
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_XMIT_CNT 0x0a
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_POS_ACK_RX_CNT 0x0b
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_NEG_ACK_RX_CNT 0x0c
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_RX_CNT 0x0d
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_CKPT_REXMIT_CNT 0x0e
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_CANCEL_XMIT_CNT 0x0f
-#define DTN_LTP_AGENT_EDD_SPAN_OUT_COMPLETE_CNT 0x10
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_CNT 0x11
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_RED_BYTES 0x12
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_CNT 0x13
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_GREEN_BYTES 0x14
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_CNT 0x15
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_REDUNDANT_BYTES 0x16
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_CNT 0x17
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_MAL_BYTES 0x18
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_CNT 0x19
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_SENDER_BYTES 0x1a
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_CNT 0x1b
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_RX_UNK_CLIENT_BYTES 0x1c
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_CNT 0x1d
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_STRAY_BYTES 0x1e
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_CNT 0x1f
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_MISCOLOR_BYTES 0x20
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_CNT 0x21
-#define DTN_LTP_AGENT_EDD_SPAN_IN_SEG_CLOSED_BYTES 0x22
-#define DTN_LTP_AGENT_EDD_SPAN_IN_CKPT_RX_CNT 0x23
-#define DTN_LTP_AGENT_EDD_SPAN_IN_POS_ACK_TX_CNT 0x24
-#define DTN_LTP_AGENT_EDD_SPAN_IN_NEG_ACK_TX_CNT 0x25
-#define DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_TX_CNT 0x26
-#define DTN_LTP_AGENT_EDD_SPAN_IN_ACK_RETX_CNT 0x27
-#define DTN_LTP_AGENT_EDD_SPAN_IN_CANCEL_RX_CNT 0x28
-#define DTN_LTP_AGENT_EDD_SPAN_IN_COMPLETE_CNT 0x29
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_LTP_AGENT VARIABLE DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                              DTN_LTP_AGENT REPORT DEFINITIONS                               +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |endpointReport       |This is all known endpoint information|TNVC   |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_LTP_AGENT_RPTTPL_ENDPOINTREPORT 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               DTN_LTP_AGENT TABLE DEFINITIONS                               +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |engines              |This table lists all known remote engi|       |
- * |                     |ne ids.                               |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_LTP_AGENT_TBLT_ENGINES 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                              DTN_LTP_AGENT CONTROL DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- * |reset                |Resets the counters associated with th|       |
- * |                     |e engine and updates the last reset ti|       |
- * |                     |me for the span to be the time when th|       |
- * |                     |is control was run.                   |       |
- * +---------------------+--------------------------------------+-------+
- */
-#define DTN_LTP_AGENT_CTRL_RESET 0x00
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_LTP_AGENT CONSTANT DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |         VALUE          |
- * +---------------------+--------------------------------------+-------+------------------------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                               DTN_LTP_AGENT MACRO DEFINITIONS                               +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-
-/*
- * +---------------------------------------------------------------------------------------------+
- * |                             DTN_LTP_AGENT OPERATOR DEFINITIONS                              +
- * +---------------------------------------------------------------------------------------------+
- * |        NAME         |             DESCRIPTION              | TYPE  |
- * +---------------------+--------------------------------------+-------+
- */
-
-/* Initialization functions. */
-void dtn_ltp_agent_init();
-void dtn_ltp_agent_init_meta();
-void dtn_ltp_agent_init_cnst();
-void dtn_ltp_agent_init_edd();
-void dtn_ltp_agent_init_op();
-void dtn_ltp_agent_init_var();
-void dtn_ltp_agent_init_ctrl();
-void dtn_ltp_agent_init_mac();
-void dtn_ltp_agent_init_rpttpl();
-void dtn_ltp_agent_init_tblt();
-#endif /* _HAVE_DTN_LTP_AGENT_ADM_ */
-#endif //ADM_LTP_AGENT_H_
\ No newline at end of file
diff --git a/nm/shared/msg/ion_if.c b/nm/shared/msg/ion_if.c
deleted file mode 100644
index 27f93003..00000000
--- a/nm/shared/msg/ion_if.c
+++ /dev/null
@@ -1,516 +0,0 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
-
-/*****************************************************************************
- **
- ** File Name: ion_if.c
- **
- ** Description: This file contains the definitions, prototypes, constants, and
- **              other information necessary for DTNMP actors to connect to
- **              the local BPA.
- **
- ** Notes:
- **
- ** Assumptions:
- **
- **
- ** Modification History:
- **  MM/DD/YY  AUTHOR         DESCRIPTION
- **  --------  ------------   ---------------------------------------------
- **  08/10/11  V.Ramachandran Initial Implementation (JHU/APL)
- **  11/13/12  E. Birrane     Technical review, comment updates. (JHU/APL)
- **  06/25/13  E. Birrane     Renamed message "bundle" message "group". (JHU/APL)
- **  06/30/16  E. Birrane     Doc. Updates and Bug Fixes (Secure DTN - NASA: NNX14CS58P)
- **  10/02/18  E. Birrane     Update to AMP v0.5 (JHUAPL)
- *****************************************************************************/
-
-#include "bp.h"
-
-#include "../utils/nm_types.h"
-#include "ion_if.h"
-#include "../utils/utils.h"
-
-#include "msg.h"
-
-
-
-/******************************************************************************
- *
- * \par Function Name: iif_deregister_node
- *
- * \par Deregisters the current application with the DTN network.
- *
- * \retval 0 - Could not Register
- * 		   1 - Registered.
- *
- * \param[in,out] iif  The Interface being deregistered.
- *
- * \par Notes:
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- *  08/10/11  V.Ramachandran Initial implementation, (JHU/APL)
- *  06/30/16  E. Birrane     Fix EID init. (Secure DTN - NASA: NNX14CS58P)
- *****************************************************************************/
-
-int iif_deregister_node(iif_t *iif)
-{
-    AMP_DEBUG_ENTRY("iif_deregister_node","(%#llx)", (size_t)iif);
-
-    /* Step 0: Sanity Check */
-    if(iif == NULL)
-    {
-    	AMP_DEBUG_ERR("iif_deregister_node","Null IIF.", NULL);
-        AMP_DEBUG_EXIT("iif_deregister_node","-> %d", 0);
-    	return 0;
-    }
-
-    bp_close(iif->sap);
-    bp_detach();
-    memset(iif->local_eid.name,0, AMP_MAX_EID_LEN);
-
-    AMP_DEBUG_EXIT("iif_deregister_node","-> %d", 1);
-    return 1;
-}
-
-
-
-/******************************************************************************
- *
- * \par Function Name: iif_get_local_eid
- *
- * \par Returns the EID of the local node.
- *
- * \retval The EID associated with the IIF.
- *
- * \param[in] iif  The Interface whose local EID is being queried.
- *
- * \par Notes:
- *         1. Assumes the IIF exists at this point.
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- *  08/10/11  V.Ramachandran Initial implementation. (JHU/APL)
- *****************************************************************************/
-
-eid_t iif_get_local_eid(iif_t *iif)
-{
-	AMP_DEBUG_ENTRY("iif_get_local_eid","(%#llx)", iif);
-
-	if(iif == NULL)
-	{
-		eid_t result;
-		AMP_DEBUG_ERR("iif_get_local_eid","Bad args.",NULL);
-		memset(&result,0,sizeof(eid_t));
-		AMP_DEBUG_EXIT("iif_get_local_eid","->0.",NULL);
-		return result;
-	}
-
-	AMP_DEBUG_EXIT("iif_get_local_eid","->1.",NULL);
-    return iif->local_eid;
-}
-
-
-
-/******************************************************************************
- *
- * \par Function Name: iif_is_registered
- *
- * \par Returns 1 if the DTN connection is active, 0 otherwise.
- *
- * \retval 1 - IIF is registered
- *         0 - IIF is not registered.
- *
- * \param[in] iif  The Interface whose registration status is being queried.
- *
- * \par Notes:
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- *  08/10/11  V.Ramachandran Initial implementation. (JHU/APL)
- *****************************************************************************/
-
-int iif_is_registered(iif_t *iif)
-{
-	uint8_t result = 0;
-
-	AMP_DEBUG_ENTRY("iif_is_registered","(%#llx)", iif);
-
-	if(iif == NULL)
-	{
-		AMP_DEBUG_ERR("iif_is_registered","Bad args.",NULL);
-		AMP_DEBUG_EXIT("iif_is_registered","->0.",NULL);
-		return result;
-	}
-
-	result = (iif->local_eid.name[0] != 0) ? 1 : 0;
-
-	AMP_DEBUG_EXIT("iif_is_registered","->%d.",NULL);
-    return result;
-}
-
-
-
-/******************************************************************************
- *
- * \par Function Name: iif_receive
- *
- * \par Blocking receive. Receives a message from the BPA.
- *
- * \retval NULL - Error
- *         !NULL - The received serialized payload.
- *
- * \param[in]  iif     The registered interface.
- * \param[out] size    The size of the msg bundle.
- * \param[out] meta    The sender information from the convergence layer for all msgs.
- * \param[in]  timeout The # seconds to wait on a receive before timing out
- *
- * \par Notes:
- *   - The returned data must be freed via zco_destroy_reference()
- *
- * \todo
- *   - Use ZCOs and handle large message sizes.
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- *  08/10/11  V.Ramachandran Initial implementation (JHU/APL)
- *  10/04/18  E. Birrane     Updated to AMP v0.5 (JHU/APL)
- *****************************************************************************/
-
-blob_t *iif_receive(iif_t *iif, msg_metadata_t *meta, int timeout, int *success)
-{
-    BpDelivery dlv;
-    ZcoReader reader;
-    int content_len;
-    Sdr sdr = bp_get_sdr();
-    blob_t *result;
-    int status;
-
-
-    AMP_DEBUG_ENTRY("iif_receive", "("ADDR_FIELDSPEC", %d)",
-    		         (uaddr) iif, timeout);
-
-    AMP_DEBUG_INFO("iif_receive", "Received bundle.", NULL);
-
-	*success = AMP_SYSERR;
-
-    CHKNULL(iif);
-    CHKNULL(meta);
-
-	*success = AMP_OK;
-
-	memset(&dlv, 0, sizeof(BpDelivery));
-
-    /* Step 1: Receive the bundle.*/
-    if((status = bp_receive(iif->sap, &dlv, timeout)) < 0)
-    {
-    	AMP_DEBUG_INFO("iif_receive","bp_receive failed. Result: %d.", result);
-    	*success = AMP_SYSERR;
-    	return NULL;
-    }
-    else
-    {
-    	switch(dlv.result)
-    	{
-    		case BpEndpointStopped:
-    			/* The endpoint stopped? Panic.*/
-//    			AMP_DEBUG_INFO("iif_receive","Endpoint stopped.", NULL);
-    			return NULL;
-
-    		case BpPayloadPresent:
-    			/* Clear to process the payload. */
- //   			AMP_DEBUG_INFO("iif_receive", "Payload present.", NULL);
-    			break;
-
-    		default:
-    			/* No message. Return NULL. */
-    			return NULL;
-    			break;
-    	}
-    }
-    content_len = zco_source_data_length(sdr, dlv.adu);
-
-    /* Step 2: Allocate result space. */
-    if((result = blob_create(NULL, 0, content_len)) == NULL)
-    {
-    	*success = AMP_SYSERR;
-
-    	AMP_DEBUG_ERR("iif_receive","Can't alloc %d of msg.", content_len);
-    	AMP_DEBUG_ERR("iif_receive","Timeout is %d.", timeout);
-        bp_release_delivery(&dlv, 1);
-    	return NULL;
-    }
-
-    /* Step 3: Read the bundle in from the ZCO. */
-    if (sdr_begin_xn(sdr) < 0)
-    {
-    	*success = AMP_SYSERR;
-
-    	blob_release(result, 1);
-    	AMP_DEBUG_ERR("iif_receive","Can't start transaction.", NULL);
-        bp_release_delivery(&dlv, 1);
-        return NULL;
-    }
-
-    zco_start_receiving(dlv.adu, &reader);
-    result->length = zco_receive_source(sdr, &reader, result->alloc, (char*)result->value);
-
-    if((sdr_end_xn(sdr) < 0) || (result->length == 0))
-    {
-    	*success = AMP_SYSERR;
-
-        AMP_DEBUG_ERR("iif_receive", "Unable to process received bundle.", NULL);
-        blob_release(result, 1);
-        bp_release_delivery(&dlv, 1);
-        return NULL;
-    }
-
-    /* Step 5: Set up the metadata. */
-
-    istrcpy(meta->senderEid.name, dlv.bundleSourceEid,
-		    sizeof meta->senderEid.name);
-    istrcpy(meta->originatorEid.name, dlv.bundleSourceEid,
-		    sizeof meta->originatorEid.name);
-    istrcpy(meta->recipientEid.name, iif->local_eid.name,
-		    sizeof meta->recipientEid.name);
-
-    bp_release_delivery(&dlv, 1);
-    
-    AMP_DEBUG_EXIT("iif_receive", "->"ADDR_FIELDSPEC, (uaddr) result);
-    return result;
-}
-
-
-
-/******************************************************************************
- *
- * \par Function Name: iif_register_node
- *
- * \par Registers the current application with the DTN network.
- *
- * \retval 0 - Could not Register
- * 		   1 - Registered.
- *
- * \param[out] iif  Updated IIF structure.
- * \param[in]  eid  EID of the node we are registering.
- *
- * \par Notes:
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- *  08/10/11  V.Ramachandran Initial implementation . (JHU/APL)
- *****************************************************************************/
-
-int iif_register_node(iif_t *iif, eid_t eid)
-{
-    AMP_DEBUG_ENTRY("iif_register_node","(%s)", eid.name);
-    
-    /* Step 0: Sanity Check */
-    if(iif == NULL)
-    {
-    	AMP_DEBUG_ERR("iif_register_node","Null IIF.", NULL);
-        AMP_DEBUG_EXIT("iif_register_node","-> %d", 0);
-    	return 0;
-    }
-
-    memset((char*)iif, 0, sizeof(iif_t));
-    iif->local_eid = eid;
-
-    if(bp_attach() < 0)
-    {
-        AMP_DEBUG_ERR("iif_register_node","Failed to attach.", NULL);
-        AMP_DEBUG_EXIT("iif_register_node","-> %d", 0);
-        return 0;
-    }
-    
-    if(bp_open((char *)eid.name, &(iif->sap)) < 0)
-    {
-        AMP_DEBUG_ERR("iif_register_node","Failed to open %s.", eid.name);
-        AMP_DEBUG_EXIT("iif_register_node","-> %d", 0);
-        return 0;
-    }
-
-    AMP_DEBUG_INFO("iif_register_node","Registered Agent as %s.", eid.name);
-
-    
-    AMP_DEBUG_EXIT("iif_register_node","-> %d", 1);
-    return 1;
-}
-
-
-
-/******************************************************************************
- *
- * \par Function Name: iif_send
- *
- * \par Sends a text string to the recipient node.
- *
- * \retval Whether the send succeeded (1) or failed (0)
- *
- * \param[in] iif     The registered interface
- * \param[in] data    The data to send.
- * \param[in] len     The length of data to send, in bytes.
- * \param[in] rx_eid  The EID of the recipient of the data.
- *
- * \par Notes:
- *
- * Modification History:
- *  MM/DD/YY  AUTHOR         DESCRIPTION
- *  --------  ------------   ---------------------------------------------
- *  08/10/11  V.Ramachandran Initial implementation. (JHU/APL)
- *  06/25/13  E. Birrane     Renamed message "bundle" message "group". (JHU/APL)
- *  03/??/16  E. Birrane     Fix BP Send to latest ION version. (Secure DTN - NASA: NNX14CS58P)
- *  10/02/18  E. Birrane     Update to AMP v0.5 (JHU/APL)
- *****************************************************************************/
-
-int iif_send_grp(iif_t *iif, msg_grp_t *group, char *rx)
-{
-    Object extent = 0;
-    Object newBundle = 0;
-    blob_t *data = NULL;
-
-    AMP_DEBUG_ENTRY("iif_send","("ADDR_FIELDSPEC","ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-    		(uaddr)iif, (uaddr)group, (uaddr)rx);
-
-    CHKZERO(iif);
-    CHKZERO(group);
-    CHKZERO(rx);
-
-    /* Step 1 - Serialize the bundle. */
-    if((data = msg_grp_serialize_wrapper(group)) == NULL)
-    {
-    	AMP_DEBUG_ERR("iif_send","Bad message of length 0.", NULL);
-    	AMP_DEBUG_EXIT("iif_send", "->0.", NULL);
-    	return 0;
-    }
-
-    if(data->length == 0)
-    {
-    	AMP_DEBUG_ERR("iif_send","Cannot send empty data.", NULL);
-    	blob_release(data, 1);
-    	return AMP_FAIL;
-    }
-
-    /* Information on bitstream we are sending. */
-    char *msg_str = utils_hex_to_string(data->value, data->length);
-    AMP_DEBUG_ALWAYS("iif_send","Sending msgs:%s to %s:", msg_str, rx);
-    SRELEASE(msg_str);
-
-
-    /* Step 2 - Get the SDR, insert the message as an SDR transaction.*/
-    Sdr sdr = bp_get_sdr();
-
-    if (sdr_begin_xn(sdr) < 0)
-    {
-    	blob_release(data, 1);
-	    AMP_DEBUG_ERR("iif_send","Unable to start transaction.", NULL);
-	    return 0;
-    }
-
-    extent = sdr_malloc(sdr, data->length);
-    if(extent)
-    {
-       sdr_write(sdr, extent, (char *) data->value, data->length);
-    }
-    else
-    {
-    	blob_release(data, 1);
-    	AMP_DEBUG_ERR("iif_send","Can't write to NULL extent.", NULL);
-    	sdr_cancel_xn(sdr);
-    	return 0;
-    }
-
-    if (sdr_end_xn(sdr) < 0)
-    {
-    	AMP_DEBUG_ERR("iif_send","Can't close transaction?", NULL);
-    }
-        
-    /* Step 3 - Create ZCO.*/
-    Object content = ionCreateZco(ZcoSdrSource, extent, 0, data->length, BP_STD_PRIORITY, 0, ZcoOutbound, NULL);
-
-    if(content == 0 || content == (Object) ERROR)
-    {
-    	blob_release(data, 1);
-        AMP_DEBUG_ERR("iif_send","Zero-Copy Object creation failed.", NULL);
-        AMP_DEBUG_EXIT("iif_send", "->0.", NULL);
-    	return 0;
-    }
-
-    /* Step 4 - Pass on to the BPA to send.*/
-    int res = 0;
-    if((res = bp_send(
-				iif->sap, 		// BpSAP reference
-				rx,              // recipient
-				NULL,			// report-to
-				300,			// lifespan (?)
-				BP_STD_PRIORITY,	// Class-of-Service / Priority
-				NoCustodyRequested,	// Custody Switch
-				0,			// SRR Flags
-				0,			// ACK Requested
-				NULL,		// Extended COS
-				content,		// ADU
-				&newBundle		// New Bundle
-				)) != 1)
-    {
-        AMP_DEBUG_ERR("iif_send","Send failed (%d) to %s.", res, rx);
-        blob_release(data, 1);
-        AMP_DEBUG_EXIT("iif_send", "->0.", NULL);
-    	return 0;
-
-    }
-
-    blob_release(data, 1);
-    AMP_DEBUG_EXIT("iif_send", "->1.", NULL);
-    return 1;
-}
-
-// Caller MUST release msg.
-int iif_send_msg(iif_t *iif, int msg_type, void *msg, char *recipient)
-{
-	msg_grp_t *grp = msg_grp_create(1);
-	int success;
-
-	CHKERR(msg);
-	CHKERR(grp);
-
-	switch(msg_type)
-	{
-		case MSG_TYPE_REG_AGENT:
-			success = msg_grp_add_msg_agent(grp, msg);
-			break;
-		case MSG_TYPE_RPT_SET:
-			success = msg_grp_add_msg_rpt(grp, msg);
-			break;
-		case MSG_TYPE_PERF_CTRL:
-			success = msg_grp_add_msg_ctrl(grp, msg);
-			break;
-		case MSG_TYPE_TBL_SET:
-            success = msg_grp_add_msg_tbl(grp, msg);
-            break;
-		default:
-			success = AMP_FAIL;
-			break;
-	}
-
-	if(success == AMP_OK)
-	{
-		success = iif_send_grp(iif, grp, recipient);
-	}
-
-	msg_grp_release(grp, 1);
-	return success;
-}
- 
-
-
-
-
-
diff --git a/nm/shared/msg/ion_if.h b/nm/shared/msg/ion_if.h
deleted file mode 100644
index 72d6c6b2..00000000
--- a/nm/shared/msg/ion_if.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
-
-/*****************************************************************************
- **
- ** File Name: ion_if.h
- **
- ** Description: This file contains the definitions, prototypes, constants, and
- **              other information necessary for DTNMP actors to connect to
- **              the local BPA.
- **
- ** Notes:
- **
- ** Assumptions:
- **
- **
- ** Modification History:
- **  MM/DD/YY  AUTHOR         DESCRIPTION
- **  --------  ------------   ---------------------------------------------
- **  08/10/11  V.Ramachandran Initial Implementation (JHU/APL)
- **  11/13/12  E. Birrane     Technical review, comment updates. (JHU/APL)
- **  06/25/13  E. Birrane     Renamed message "bundle" message "group". (JHU/APL)
- **  06/30/16  E. Birrane     Doc. Updates (Secure DTN - NASA: NNX14CS58P)
- **  10/02/18  E. Birrane     Update to AMP v0.5 (JHUAPL)
- *****************************************************************************/
-#ifndef ION_IF_H_
-#define ION_IF_H_
-
-#include "bp.h"
-#include "msg.h"
-
-/*
- * +--------------------------------------------------------------------------+
- * |							  CONSTANTS  								  +
- * +--------------------------------------------------------------------------+
- */
-
-
-/*
- * +--------------------------------------------------------------------------+
- * |							  DATA TYPES  								  +
- * +--------------------------------------------------------------------------+
- */
-
-/**
- * The ION Interface structure captures state necessary to communicate with
- * the local Bundle Protocol Agent (BPA).
- */
-typedef struct
-{
-	eid_t local_eid;
-	BpSAP sap;
-} iif_t;
-
-
-/*
- * +--------------------------------------------------------------------------+
- * |						  DATA DEFINITIONS  							  +
- * +--------------------------------------------------------------------------+
- */
-
-
-/*
- * +--------------------------------------------------------------------------+
- * |						  FUNCTION PROTOTYPES  							  +
- * +--------------------------------------------------------------------------+
- */
-
-
-int     iif_deregister_node(iif_t *iif);
-eid_t   iif_get_local_eid(iif_t *iif);
-int     iif_is_registered(iif_t *iif);
-blob_t *iif_receive(iif_t *iif, msg_metadata_t *meta, int timeout, int *success);
-int     iif_register_node(iif_t *iif, eid_t eid);
-int     iif_send_grp(iif_t *iif, msg_grp_t *group, char *recipient);
-int     iif_send_msg(iif_t *iif, int msg_type, void *msg, char *recipient);
-
-#endif /* ION_IF_H_ */
diff --git a/nm/shared/msg/msg.c b/nm/shared/msg/msg.c
index 4af02e65..c60742ab 100644
--- a/nm/shared/msg/msg.c
+++ b/nm/shared/msg/msg.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -25,9 +37,7 @@
  **  10/01/18  E. Birrane     Updated to AMP v0.5. Migrate from pdu.h. (JHU/APL)
  *****************************************************************************/
 
-#include "platform.h"
-#include "ion.h"
-
+#include "shared/platform.h"
 #include "../adm/adm.h"
 #include "../msg/msg.h"
 #include "../utils/utils.h"
@@ -254,7 +264,7 @@ int msg_ctrl_serialize(QCBOREncodeContext *encoder, void *item)
 	}
 
 
-	QCBOREncode_AddUInt64(encoder, msg->start);
+        amp_tv_serialize(encoder, &(msg->start));
 
 	return ac_serialize(encoder, msg->ac);
 }
@@ -735,7 +745,7 @@ msg_grp_t* msg_grp_deserialize(blob_t *data, int *success)
 	result = msg_grp_create(length-1);
 	CHKNULL(result);
 
-	if((*success = cut_get_cbor_numeric(&decoder, AMP_TYPE_TS, &(result->time))) != AMP_OK)
+	if((*success = cut_get_cbor_numeric(&decoder, AMP_TYPE_TS, &(result->timestamp))) != AMP_OK)
 	{
 		msg_grp_release(result, 1);
 		return NULL;
@@ -744,10 +754,16 @@ msg_grp_t* msg_grp_deserialize(blob_t *data, int *success)
 	for(i = 1; i < length; i++)
 	{
 		blob_t *cur_item = blob_deserialize_ptr(&decoder, success);
-		int msg_type;
+		if ((*success != AMP_OK) || !cur_item)
+		{
+			AMP_DEBUG_ERR("msg_grp_deserialize",
+                                      "Message index %d is not a BLOB, code %d", i, *success);
+			msg_grp_release(result, 1);
+			return NULL;
+		}
 
 		/* Get the type of the message.*/
-		msg_type = MSG_HDR_GET_OPCODE(cur_item->value[0]);
+		int msg_type = MSG_HDR_GET_OPCODE(cur_item->value[0]);
 
 		if((*success = msg_grp_add_msg(result, cur_item, msg_type)) != AMP_OK)
 		{
@@ -764,7 +780,7 @@ msg_grp_t* msg_grp_deserialize(blob_t *data, int *success)
 }
 
 
-int msg_grp_get_type(msg_grp_t *grp, int idx)
+int msg_grp_get_type(msg_grp_t *grp, size_t idx)
 {
 	CHKUSR(grp, MSG_TYPE_UNK);
 	CHKUSR(idx < grp->types.length, MSG_TYPE_UNK);
@@ -798,7 +814,7 @@ int msg_grp_serialize(QCBOREncodeContext *encoder, void *item)
 
 	max = vec_num_entries(msg_grp->msgs);
 
-	QCBOREncode_AddUInt64(encoder, msg_grp->time);
+	amp_tv_serialize(encoder, &(msg_grp->timestamp));
 
 	for(i = 0; i < max; i++)
 	{
diff --git a/nm/shared/msg/msg.h b/nm/shared/msg/msg.h
index d3d5a558..d6258f07 100644
--- a/nm/shared/msg/msg.h
+++ b/nm/shared/msg/msg.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -28,12 +40,18 @@
 #ifndef _PDU_H_
 #define _PDU_H_
 
-#include "stdint.h"
+#include <stdint.h>
 #include "../utils/nm_types.h"
 #include "../utils/vector.h"
 #include "../primitives/ari.h"
 #include "../primitives/report.h"
 #include "../primitives/table.h"
+#include "../primitives/time.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 
 #define MSG_DEFAULT_ENC_SIZE 1024
@@ -74,7 +92,7 @@ typedef struct
 typedef struct
 {
 	msg_hdr_t hdr;
-	time_t start;
+	amp_tv_t start;
 	ac_t *ac;
 } msg_ctrl_t;
 
@@ -108,15 +126,14 @@ typedef struct
 {
 	vector_t msgs;  /* (blob_t *) - serialized messages. */
 	blob_t types;
-	time_t time;
+	amp_tv_t timestamp;
 } msg_grp_t;
 
 
 typedef struct
 {
-	eid_t senderEid;
-	eid_t originatorEid;
-	eid_t recipientEid;
+	eid_t source;
+	eid_t destination;
 } msg_metadata_t;
 
 msg_hdr_t msg_hdr_deserialize(QCBORDecodeContext *it, int *success);
@@ -192,7 +209,7 @@ msg_grp_t* msg_grp_create(uint8_t length);
 
 msg_grp_t* msg_grp_deserialize(blob_t *data, int *success);
 
-int        msg_grp_get_type(msg_grp_t *grp, int idx);
+int        msg_grp_get_type(msg_grp_t *grp, size_t idx);
 
 void       msg_grp_release(msg_grp_t *group, int destroy);
 
@@ -201,11 +218,8 @@ int msg_grp_serialize(QCBOREncodeContext *encoder, void *item);
 blob_t*    msg_grp_serialize_wrapper(msg_grp_t *msg_grp);
 
 
+#ifdef __cplusplus
+}
+#endif
 
-
-
-
-
-
-
-#endif /* _PDU_H_ */
+#endif  /* _MSG_H_ */
diff --git a/nm/shared/nm.h b/nm/shared/nm.h
index f4cab04c..e0a7fffb 100644
--- a/nm/shared/nm.h
+++ b/nm/shared/nm.h
@@ -1,6 +1,27 @@
+/*
+ * Copyright (c) 2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 #ifndef __NM__
 #define __NM__
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 // Preprocessor magic helper
 #define STR_HELPER(x) #x
 #define STR(x) STR_HELPER(x)
@@ -24,4 +45,8 @@
 #define AMP_VERSION_STR       STR(AMP_VERSION) " - " AMP_PROTOCOL_URL
 
 
+#ifdef __cplusplus
+}
 #endif
+
+#endif  /* _NM_H_ */
diff --git a/nm/shared/primitives/ari.c b/nm/shared/primitives/ari.c
index ecab5e51..169a6ae9 100644
--- a/nm/shared/primitives/ari.c
+++ b/nm/shared/primitives/ari.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
-  ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: ari.c
@@ -23,12 +35,11 @@
  **                           implementation of MIDs for earlier AMP spec (JHU/APL)
  *****************************************************************************/
 
-#include "platform.h"
-
-#include "../utils/utils.h"
-#include "../utils/nm_types.h"
-#include "../utils/db.h"
-
+#include <inttypes.h>
+#include "shared/platform.h"
+#include "shared/utils/utils.h"
+#include "shared/utils/nm_types.h"
+#include "shared/utils/db.h"
 #include "ari.h"
 #include "tnv.h"
 
@@ -87,7 +98,7 @@ static ari_t p_ari_deserialize_lit(QCBORDecodeContext *it, uint8_t byte, int *su
 static ari_t p_ari_deserialize_reg(QCBORDecodeContext *it, uint8_t flags, int *success)
 {
 	ari_t result;
-	uvast temp;
+	amp_uvast temp;
 
 	ari_init(&result);
 
@@ -239,7 +250,7 @@ static int p_ari_serialize_reg(QCBOREncodeContext *encoder, ari_t *ari)
 	// Encode Nickname (if defined)
 	if(ARI_GET_FLAG_NN(ari->as_reg.flags))
 	{
-		uvast *nn = (uvast *) VDB_FINDIDX_NN(ari->as_reg.nn_idx);
+		amp_uvast *nn = (amp_uvast *) VDB_FINDIDX_NN(ari->as_reg.nn_idx);
 
 		if (nn != NULL)
 		{
@@ -272,7 +283,7 @@ static int p_ari_serialize_reg(QCBOREncodeContext *encoder, ari_t *ari)
 	if(ARI_GET_FLAG_ISS(ari->as_reg.flags))
 	{
 #if AMP_VERSION < 8
-		uvast *iss = (uvast *)VDB_FINDIDX_ISS(ari->as_reg.iss_idx);
+		amp_uvast *iss = (amp_uvast *)VDB_FINDIDX_ISS(ari->as_reg.iss_idx);
 
 		if (iss != NULL)
 		{
@@ -497,8 +508,8 @@ void ari_cb_ht_del(rh_elt_t *elt)
 
 int ari_compare(ari_t *ari1, ari_t *ari2, int parms)
 {
-    AMP_DEBUG_ENTRY("ari_compare","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-    		         (uaddr) ari1, (uaddr) ari2);
+    AMP_DEBUG_ENTRY("ari_compare","(%"PRIxPTR",%"PRIxPTR")",
+    		         ari1, ari2);
 
     if((ari1 == NULL) || (ari2 == NULL))
     {
@@ -684,7 +695,7 @@ ari_t ari_deserialize(QCBORDecodeContext *it, int *success)
 {
 	uint8_t flag;
 
-    AMP_DEBUG_ENTRY("ari_deserialize","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")", (uaddr)it, (uaddr)success);
+    AMP_DEBUG_ENTRY("ari_deserialize","(%"PRIxPTR",%"PRIxPTR")", it, success);
 
     CHKUSR(it, ari_null());
     CHKUSR(success, ari_null());
@@ -758,14 +769,14 @@ ari_t* ari_deserialize_raw(blob_t *data, int *success)
  *to ARI 9/19/18
  */
 
-ari_t*   ari_from_uvast(uvast val)
+ari_t*   ari_from_uvast(amp_uvast val)
 {
 	QCBORDecodeContext it;
 	int success = AMP_FAIL;
 	ari_t *result = NULL;
     
 	QCBORDecode_Init(&it,
-					 (UsefulBufC){&val,sizeof(uvast)},
+					 (UsefulBufC){&val,sizeof(amp_uvast)},
 					 QCBOR_DECODE_MODE_NORMAL);
 
 	result = ari_deserialize_ptr(&it, &success);
@@ -1093,7 +1104,7 @@ ac_t ac_deserialize(QCBORDecodeContext *it, int *success)
 	size_t length;
 	size_t i;
 
-	AMP_DEBUG_ENTRY("ac_deserialize","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")", (uaddr)it, (uaddr)success);
+	AMP_DEBUG_ENTRY("ac_deserialize","(%"PRIxPTR",%"PRIxPTR")", it, success);
 
 	memset(&result, 0, sizeof(ac_t));
 
diff --git a/nm/shared/primitives/ari.h b/nm/shared/primitives/ari.h
index e58d6521..dafb11a4 100644
--- a/nm/shared/primitives/ari.h
+++ b/nm/shared/primitives/ari.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: ari.h
@@ -26,16 +38,15 @@
 #ifndef ARI_H_
 #define ARI_H_
 
-#include "stdint.h"
-
-#include "ion.h"
-
-#include "../utils/debug.h"
-#include "../utils/rhht.h"
-#include "../utils/vector.h"
-#include "../primitives/tnv.h"
-
+#include <stdint.h>
+#include "shared/utils/debug.h"
+#include "shared/utils/rhht.h"
+#include "shared/utils/vector.h"
+#include "tnv.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /*
  * +--------------------------------------------------------------------------+
@@ -194,8 +205,8 @@ ari_t*    ari_create(amp_type_e type);
 ari_t     ari_deserialize(QCBORDecodeContext *it, int *success);
 ari_t*    ari_deserialize_ptr(QCBORDecodeContext *it, int *success);
 ari_t*    ari_deserialize_raw(blob_t *data, int *success);
-ari_t*    ari_from_uvast(uvast val);
-ari_t*    ari_from_parm_reg(uint8_t flags, uvast nn, uvast iss, blob_t *tag, blob_t *name, tnvc_t *parms);
+ari_t*    ari_from_uvast(amp_uvast val);
+ari_t*    ari_from_parm_reg(uint8_t flags, amp_uvast nn, amp_uvast iss, blob_t *tag, blob_t *name, tnvc_t *parms);
 tnv_t*    ari_get_param(ari_t *id, int i);
 uint8_t   ari_get_num_parms(ari_t *ari);
 void      ari_init(ari_t *ari);
@@ -225,4 +236,9 @@ void      ac_release(ac_t *ac, int destroy);
 int        ac_serialize(QCBOREncodeContext *encoder, void *item);
 blob_t*   ac_serialize_wrapper(ac_t *ac);
 
+
+#ifdef __cplusplus
+}
 #endif
+
+#endif  /* _ARI_H_ */
diff --git a/nm/shared/primitives/blob.c b/nm/shared/primitives/blob.c
index f78e6df2..dc45b2c0 100644
--- a/nm/shared/primitives/blob.c
+++ b/nm/shared/primitives/blob.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: blob.c
@@ -27,7 +39,9 @@
  **  04/14/16  E. Birrane     Initial Implementation (Secure DTN - NASA: NNX14CS58P)
  **  08/30/18  E. Birrane     CBOR Updates and Structure Optimization (JHU/APL)
  *****************************************************************************/
-#include "platform.h"
+
+#include <inttypes.h>
+#include "shared/platform.h"
 #include "../nm.h"
 #include "../adm/adm.h"
 
@@ -229,7 +243,7 @@ blob_t blob_deserialize(QCBORDecodeContext *it, int *success)
 	QCBORItem item;
 	int status;
 
-	AMP_DEBUG_ENTRY("blob_deserialize","(0x"ADDR_FIELDSPEC",0x"ADDR_FIELDSPEC")", (uaddr) it, (uaddr) success);
+	AMP_DEBUG_ENTRY("blob_deserialize","(0x%"PRIxPTR",0x%"PRIxPTR")", it, success);
 
 	memset(&result, 0, sizeof(blob_t));
 	*success = AMP_FAIL;
@@ -294,7 +308,7 @@ blob_t blob_deserialize_as_bytes(QCBORDecodeContext *it, int *success, size_t le
 {
 	blob_t result;
 
-    AMP_DEBUG_ENTRY("blob_deserialize_as_bytes","(0x"ADDR_FIELDSPEC",0x"ADDR_FIELDSPEC"), %d", (uaddr) it, (uaddr) success, len);
+    AMP_DEBUG_ENTRY("blob_deserialize_as_bytes","(0x%"PRIxPTR",0x%"PRIxPTR"), %d", it, success, len);
     
     memset(&result, 0, sizeof(blob_t));
 	*success = AMP_FAIL;
@@ -536,7 +550,7 @@ int blob_serialize(QCBOREncodeContext *it, blob_t *blob)
  */
 int blob_serialize_as_bytes(QCBOREncodeContext *it, blob_t *blob)
 {
-   int i = 0;
+  size_t i;
    int err;
    
 	if(blob == NULL || it == NULL)
diff --git a/nm/shared/primitives/blob.h b/nm/shared/primitives/blob.h
index d7ad3646..fdc048ed 100644
--- a/nm/shared/primitives/blob.h
+++ b/nm/shared/primitives/blob.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -30,9 +42,13 @@
 #ifndef BLOB_H_
 #define BLOB_H_
 
-#include "stdint.h"
-#include "qcbor.h"
+#include <stdint.h>
+#include <qcbor/qcbor.h>
+
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /*
  * +--------------------------------------------------------------------------+
@@ -47,6 +63,12 @@
  * +--------------------------------------------------------------------------+
  */
 
+#ifndef SMALL_SIZES
+#define SMALL_SIZES 100
+#endif
+#ifndef WORD_SIZE
+#define WORD_SIZE 8
+#endif
 #define BLOB_DEFAULT_ENC_SIZE (SMALL_SIZES * WORD_SIZE)
 
 /*
@@ -92,4 +114,9 @@ void      blob_release(blob_t *blob, int destroy);
 blob_t*   blob_serialize_wrapper(blob_t *blob);
 int8_t    blob_trim(blob_t *blob, uint32_t length);
 
-#endif // BLOB_H
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _BLOB_H_ */
diff --git a/nm/shared/primitives/ctrl.c b/nm/shared/primitives/ctrl.c
index c465a942..2ba21b7a 100644
--- a/nm/shared/primitives/ctrl.c
+++ b/nm/shared/primitives/ctrl.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -23,6 +35,7 @@
  **  09/01/18  E. Birrane     Updated to encoding and data structures (JHU/APL)
  *****************************************************************************/
 
+#include <inttypes.h>
 #include "ctrl.h"
 
 #include "../primitives/ari.h"
@@ -188,7 +201,7 @@ ctrl_t *ctrl_create(ari_t *ari)
     	result->parms = NULL;
     }
 
-  	AMP_DEBUG_EXIT("ctrl_create","->"ADDR_FIELDSPEC".",(uaddr)result);
+  	AMP_DEBUG_EXIT("ctrl_create","->%"PRIxPTR".", result);
 	return result;
 }
 
@@ -197,7 +210,7 @@ ctrl_t *ctrl_db_deserialize(blob_t *data)
 {
 	QCBORDecodeContext it;
 	ctrl_t *result;
-	uvast start;
+	amp_tv_t start;
 	eid_t caller;
 	int success;
 
@@ -213,7 +226,7 @@ ctrl_t *ctrl_db_deserialize(blob_t *data)
 		return NULL;
 	}
 
-	if (cut_get_cbor_numeric(&it, AMP_TYPE_TV, &start) != AMP_OK)
+	if (amp_tv_deserialize(&it, &start) != AMP_OK)
 	{
 		ctrl_release(result, 1);
 		return NULL;
@@ -228,7 +241,7 @@ ctrl_t *ctrl_db_deserialize(blob_t *data)
 }
 
 
-ari_t *ctrl_get_id(ctrl_t *ctrl)
+ari_t *ctrl_get_id(const ctrl_t *ctrl)
 {
 	CHKNULL(ctrl);
 	return (ctrl->type == AMP_TYPE_CTRL) ? ctrl->def.as_ctrl->ari : ctrl->def.as_mac->ari;
@@ -236,7 +249,7 @@ ari_t *ctrl_get_id(ctrl_t *ctrl)
 
 /*
  * 16 bytes for bytestring encoding.
- * 8 bytes for uvast time
+ * 8 bytes for amp_uvast time
  * AMP_MAX_EID_LEN for caller
  * 1 for null terminator.
  */
@@ -253,7 +266,8 @@ blob_t *ctrl_db_serialize(ctrl_t *ctrl)
 	CHKNULL(result);
 
 	QCBOREncode_Init(&encoder, (UsefulBuf){data,length});
-	QCBOREncode_AddUInt64(&encoder, ctrl->start);
+	amp_tv_t tv = amp_tv_from_ctime(ctrl->start, NULL);
+	amp_tv_serialize(&encoder, &tv);
 	QCBOREncode_AddSZString(&encoder, ctrl->caller.name);
 
 	err = QCBOREncode_Finish(&encoder, &Encoded);
@@ -335,9 +349,8 @@ void ctrl_release(ctrl_t *ctrl, int destroy)
 	}
 }
 
-int ctrl_serialize(QCBOREncodeContext *encoder, void *item)
+int ctrl_serialize(QCBOREncodeContext *encoder, const ctrl_t *ctrl)
 {
-	ctrl_t *ctrl = (ctrl_t *) item;
 	ari_t *ctrl_id = NULL;
 	tnvc_t parms;
 	int err = AMP_FAIL;
@@ -453,18 +466,13 @@ blob_t*   ctrl_serialize_wrapper(ctrl_t *ctrl)
  *  --------  ------------   ---------------------------------------------
  *  10/03/18  E. Birrane     Initial implementation. (JHU/APL)
  *****************************************************************************/
-void ctrl_set_exec(ctrl_t *ctrl, time_t start, eid_t caller)
+void ctrl_set_exec(ctrl_t *ctrl, amp_tv_t start, eid_t caller)
 {
 	CHKVOID(ctrl);
 
-	if(start < AMP_RELATIVE_TIME_EPOCH && start != 0)
-	{
-		ctrl->start = getCtime() + start;
-	}
-	else
-	{
-		ctrl->start = start;
-	}
+	OS_time_t nowtime;
+        OS_GetLocalTime(&nowtime);
+	ctrl->start = amp_tv_to_ctime(start, &nowtime);
 
 	ctrl->caller = caller;
 }
diff --git a/nm/shared/primitives/ctrl.h b/nm/shared/primitives/ctrl.h
index 0f9de3cd..db868035 100644
--- a/nm/shared/primitives/ctrl.h
+++ b/nm/shared/primitives/ctrl.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -28,9 +40,15 @@
 #include "../utils/nm_types.h"
 #include "../utils/db.h"
 #include "tnv.h"
+#include "time.h"
 #include "ari.h"
 
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
@@ -89,7 +107,7 @@ typedef struct
 
 typedef struct
 {
-	time_t start;   /**> ALways kept as an absolute time once rx.*/
+	OS_time_t start;   /**> ALways kept as an absolute time once rx.*/
 	eid_t caller;   /**> EID of entity that created the control. */
 	tnvc_t *parms;
 	amp_type_e type;
@@ -126,12 +144,12 @@ blob_t *ctrl_db_serialize(ctrl_t *ctrl);
 
 void*   ctrl_deserialize_ptr(QCBORDecodeContext *it, int *success);
 ctrl_t* ctrl_deserialize_raw(blob_t *data, int *success);
-ari_t*  ctrl_get_id(ctrl_t *ctrl);
+ari_t*  ctrl_get_id(const ctrl_t *ctrl);
 
 void    ctrl_release(ctrl_t *ctrl, int destroy);
-int     ctrl_serialize(QCBOREncodeContext *encoder, void *item);
+int     ctrl_serialize(QCBOREncodeContext *encoder, const ctrl_t *ctrl);
 blob_t* ctrl_serialize_wrapper(ctrl_t *ctrl);
-void    ctrl_set_exec(ctrl_t *ctrl, time_t start, eid_t caller);
+void    ctrl_set_exec(ctrl_t *ctrl, amp_tv_t start, eid_t caller);
 
 ctrldef_t *ctrldef_create(ari_t *ari, uint8_t num, ctrldef_run_fn run);
 void       ctrldef_del_fn(rh_elt_t *elt);
@@ -168,5 +186,8 @@ int       macdef_serialize(QCBOREncodeContext *encoder, void *item);
 blob_t*   macdef_serialize_wrapper(macdef_t *mac);
 
 
+#ifdef __cplusplus
+}
+#endif
 
-#endif // _CTRL_H
+#endif  /* _CTRL_H_ */
diff --git a/nm/shared/primitives/edd_var.c b/nm/shared/primitives/edd_var.c
index 693258be..741f7194 100644
--- a/nm/shared/primitives/edd_var.c
+++ b/nm/shared/primitives/edd_var.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file var.c
@@ -23,14 +35,14 @@
  **  09/21/18  E. Birrane     Updated to AMP v5. Added EDDs. (JHU/APL)
  *****************************************************************************/
 
-#include "platform.h"
-
-#include "edd_var.h"
+#include <inttypes.h>
+#include "shared/platform.h"
 #include "../utils/utils.h"
 #include "../utils/nm_types.h"
+#include "../utils/db.h"
+#include "edd_var.h"
 
 
-#include "../utils/db.h"
 
 int       edd_cb_comp_fn(void *i1, void *i2)
 {
@@ -233,6 +245,14 @@ var_t* var_create(ari_t *id, amp_type_e type, expr_t *expr)
 	{
 		result->value = expr_eval(expr);
 		expr_release(expr, 1);
+		if(result->value == NULL)
+		{
+			AMP_DEBUG_ERR("var_create", "Cannot eval var expr.", NULL);
+
+			ari_release(id, 1);
+			SRELEASE(result);
+			result = NULL;
+		}
 	}
 	/* If var/expr types differ, calc value and then cast. */
 	else
@@ -312,7 +332,7 @@ var_t *var_deserialize_ptr(QCBORDecodeContext *it, int *success)
 {
 	var_t *result = NULL;
 
-    AMP_DEBUG_ENTRY("var_deserialize","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")", (uaddr)it, (uaddr)success);
+    AMP_DEBUG_ENTRY("var_deserialize","(%"PRIxPTR",%"PRIxPTR")", it, success);
 
     CHKNULL(success);
     *success = AMP_FAIL;
@@ -492,7 +512,7 @@ var_def_t  vardef_deserialize(QCBORDecodeContext *it, int *success)
 {
 	var_def_t result;
 
-	AMP_DEBUG_ENTRY("vardef_deserialize","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")", (uaddr)it, (uaddr)success);
+	AMP_DEBUG_ENTRY("vardef_deserialize","(%"PRIxPTR",%"PRIxPTR")", it, success);
 	memset(&result,0,sizeof(var_def_t));
 	result.type = AMP_TYPE_UNK;
 
diff --git a/nm/shared/primitives/edd_var.h b/nm/shared/primitives/edd_var.h
index 0a1b7e06..e8567abc 100644
--- a/nm/shared/primitives/edd_var.h
+++ b/nm/shared/primitives/edd_var.h
@@ -1,11 +1,23 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
- ** \file var.h
+ ** \file edd_var.h
  **
  **
  ** Description: Structures that capture AMP EDD and Variable definitions.
@@ -34,6 +46,11 @@
 #include "expr.h"
 
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
@@ -151,5 +168,8 @@ int        vardef_serialize(QCBOREncodeContext *encoder, void *item);
 blob_t*    vardef_serialize_wrapper(var_def_t *def);
 
 
+#ifdef __cplusplus
+}
+#endif
 
-#endif /* _VAR_H_ */
+#endif  /* _VAR_H_ */
diff --git a/nm/shared/primitives/expr.c b/nm/shared/primitives/expr.c
index 4a078ab9..a13ab308 100644
--- a/nm/shared/primitives/expr.c
+++ b/nm/shared/primitives/expr.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -24,6 +36,8 @@
  **  08/21/16  E. Birrane     Update to AMP v02 (Secure DTN - NASA: NNX14CS58P)
  **  09/21/18  E. Birrane     Update to AMP v03 (JHU/APL).
  *****************************************************************************/
+
+#include <inttypes.h>
 #include "../nm.h"
 #include "expr.h"
 #include "../adm/adm.h"
@@ -59,8 +73,7 @@ tnv_t *expr_apply_op(ari_t *id, vector_t *stack)
 	op_t *op = NULL;
 	tnv_t *result = NULL;
 
-	AMP_DEBUG_ENTRY("expr_apply_op","("ADDR_FIELDSPEC", "ADDR_FIELDSPEC")",
-			        (uaddr) id, (uaddr) stack);
+	AMP_DEBUG_ENTRY("expr_apply_op","(%"PRIxPTR", %"PRIxPTR")", id, stack);
 
 	if((id == NULL) || (stack == NULL))
 	{
@@ -175,9 +188,11 @@ expr_t expr_deserialize(QCBORDecodeContext *it, int *success)
 	expr_t result;
 #if AMP_VERSION < 7
 	blob_t *data = NULL;
+#else
+	uint8_t expr_type;
 #endif
 
-	AMP_DEBUG_ENTRY("expr_deserialize","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")", (uaddr)it, (uaddr)success);
+	AMP_DEBUG_ENTRY("expr_deserialize","(%"PRIxPTR",%"PRIxPTR")", it, success);
 
 	result.type = AMP_TYPE_UNK;
 	CHKUSR(success, result);
@@ -192,7 +207,8 @@ expr_t expr_deserialize(QCBORDecodeContext *it, int *success)
 	/* Grab and verify the expression type. */
 	result.type = data->value[0];
 #else
-	cut_get_cbor_numeric(it, AMP_TYPE_BYTE, &result.type);
+	cut_get_cbor_numeric(it, AMP_TYPE_BYTE, &expr_type);
+	result.type = expr_type;
 #endif
     if(type_is_known(result.type) == 0)
     {
@@ -315,11 +331,12 @@ tnv_t *expr_eval(expr_t *expr)
 	vecit_t it;
 	int success;
 
-	AMP_DEBUG_ENTRY("expr_eval","(0x"ADDR_FIELDSPEC")", (uaddr) expr);
+	AMP_DEBUG_ENTRY("expr_eval","(0x%"PRIxPTR")", expr);
 
 	/* Sanity Checks. */
 	if((expr == NULL) || ((max = vec_num_entries(expr->rpn.values)) == 0))
 	{
+		AMP_DEBUG_ERR("expr_eval","Bad args.", NULL);
 		return NULL;
 	}
 
@@ -330,6 +347,7 @@ tnv_t *expr_eval(expr_t *expr)
 	stack = vec_create(max, tnv_cb_del, tnv_cb_comp, tnv_cb_copy, VEC_FLAG_AS_STACK, &success);
 	if(success != AMP_OK)
 	{
+		AMP_DEBUG_ERR("expr_eval","Cannot create stack.", NULL);
 		return NULL;
 	}
 
@@ -359,6 +377,8 @@ tnv_t *expr_eval(expr_t *expr)
 
 		if(result == NULL)
 		{
+			AMP_DEBUG_ERR("expr_eval","Cannot evaluate expression.", NULL);
+
 			vec_release(&stack, 0);
 			return NULL;
 		}
@@ -413,7 +433,7 @@ tnv_t *expr_get_atomic(ari_t *ari)
 {
 	tnv_t *result = NULL;
 
-    AMP_DEBUG_ENTRY("expr_get_edd","("ADDR_FIELDSPEC")", (uaddr) ari);
+    AMP_DEBUG_ENTRY("expr_get_edd","(%"PRIxPTR")", ari);
 
 	CHKNULL(ari);
 
@@ -450,7 +470,7 @@ tnv_t *expr_get_atomic(ari_t *ari)
 	    result = edd->def.collect(&(ari->as_reg.parms));
 	}
 
-	AMP_DEBUG_EXIT("expr_get_edd", "("ADDR_FIELDSPEC")", (uaddr) result);
+	AMP_DEBUG_EXIT("expr_get_edd", "(%"PRIxPTR")", result);
 
 	return result;
 }
@@ -489,7 +509,7 @@ tnv_t *expr_get_var(ari_t *ari)
 	tnv_t *result = NULL;
 	var_t *var = NULL;
 
-    AMP_DEBUG_ENTRY("expr_get_var","("ADDR_FIELDSPEC")", (uaddr) ari);
+    AMP_DEBUG_ENTRY("expr_get_var","(%"PRIxPTR")", ari);
 
     CHKNULL(ari);
 
diff --git a/nm/shared/primitives/expr.h b/nm/shared/primitives/expr.h
index e256827f..a375822b 100644
--- a/nm/shared/primitives/expr.h
+++ b/nm/shared/primitives/expr.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: expr.h
@@ -33,6 +45,11 @@
 #include "tnv.h"
 
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
@@ -142,4 +159,8 @@ op_t*     op_create(ari_t *ari, uint8_t num, op_fn apply);
 void      op_release(op_t *op, int destroy);
 
 
-#endif /* EXPR_H_ */
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _EXPR_H_ */
diff --git a/nm/shared/primitives/report.c b/nm/shared/primitives/report.c
index 9e3b59ee..2552de3e 100644
--- a/nm/shared/primitives/report.c
+++ b/nm/shared/primitives/report.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file report.c
@@ -25,7 +37,8 @@
  **  09/28/18  E. Birrane     Update to latest AMP v0.5. (JHU/APL)
  *****************************************************************************/
 
-#include "platform.h"
+#include <inttypes.h>
+#include "shared/platform.h"
 
 #include "../utils/utils.h"
 
@@ -105,7 +118,7 @@ void rpt_cb_del_fn(void *item)
 
 void  rpt_clear(rpt_t *rpt)
 {
-    AMP_DEBUG_ENTRY("rpt_clear_lyst","("ADDR_FIELDSPEC")", (uaddr) rpt);
+    AMP_DEBUG_ENTRY("rpt_clear_lyst","(%"PRIxPTR")", rpt);
     CHKVOID(rpt);
     tnvc_clear(rpt->entries);
 }
@@ -157,12 +170,11 @@ rpt_t* rpt_copy_ptr(rpt_t *src)
  *  09/28/18  E. Birrane     Switched to vectors for entries.
  *****************************************************************************/
 
-rpt_t* rpt_create(ari_t *id, time_t timestamp, tnvc_t *entries)
+rpt_t* rpt_create(ari_t *id, OS_time_t timestamp, tnvc_t *entries)
 {
 	rpt_t *result = NULL;
 
-	AMP_DEBUG_ENTRY("rpt_create","("ADDR_FIELDSPEC",%d,entries)",
-			        (uaddr) id, time);
+	AMP_DEBUG_ENTRY("rpt_create","(%"PRIxPTR",%d,entries)", id, timestamp);
 
 	/* Step 1: Allocate the message. */
 	if((result = (rpt_t*) STAKE(sizeof(rpt_t))) == NULL)
@@ -220,15 +232,14 @@ void* rpt_deserialize_ptr(QCBORDecodeContext *it, int *success)
 {
 	rpt_t *result = NULL;
 	size_t len;
-	time_t timestamp;
+	OS_time_t timestamp;
 	ari_t *id;
 	tnvc_t *entries;
 	QCBORError err;
 	QCBORItem item;
 
 	AMP_DEBUG_ENTRY("rpt_deserialize_ptr",
-			        "("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-					(uaddr)it, (uaddr)success);
+			        "(%"PRIxPTR",%"PRIxPTR")", it, success);
 
 	/* Sanity Checks. */
 	CHKNULL(success);
@@ -270,7 +281,7 @@ void* rpt_deserialize_ptr(QCBORDecodeContext *it, int *success)
 	}
 	else
 	{
-		timestamp = 0;
+          timestamp = OS_TimeAssembleFromMilliseconds(0, 0);
 	}
 
 #if AMP_VERSION < 7
@@ -373,7 +384,7 @@ int rpt_serialize(QCBOREncodeContext *encoder, void *item)
 	CHKUSR(encoder, AMP_FAIL);
 	CHKUSR(rpt, AMP_FAIL);
 
-	num = (rpt->time == 0) ? 2 : 3;
+	num = (OS_TimeGetTotalMilliseconds(rpt->time) == 0) ? 2 : 3;
 
 	/* Start a container. */
 	QCBOREncode_OpenArray(encoder);
@@ -396,7 +407,8 @@ int rpt_serialize(QCBOREncodeContext *encoder, void *item)
 	
 	if(num == 3)
 	{
-	   QCBOREncode_AddUInt64(encoder, rpt->time);
+          amp_tv_t tv = amp_tv_from_ctime(rpt->time, NULL);
+          amp_tv_serialize(encoder, &tv);
 	}
 
 	/* Step 3: Encode the entries. */
diff --git a/nm/shared/primitives/report.h b/nm/shared/primitives/report.h
index d0f58b83..0ef48e34 100644
--- a/nm/shared/primitives/report.h
+++ b/nm/shared/primitives/report.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file report.h
@@ -31,12 +43,19 @@
 #ifndef _REPORT_H_
 #define _REPORT_H_
 
+#include <osapi-mutex.h>
 #include "../utils/nm_types.h"
 #include "../utils/db.h"
 #include "tnv.h"
+#include "time.h"
 #include "ari.h"
 
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
@@ -82,7 +101,7 @@ typedef struct
 
 typedef struct {
 
-	time_t time;        /**> Time the report entries were generated. */
+	OS_time_t time;        /**> Time the report entries were generated. */
 	ari_t *id;
 	tnvc_t *entries;
 
@@ -109,7 +128,7 @@ void     rpt_clear(rpt_t *rpt);
 
 rpt_t*   rpt_copy_ptr(rpt_t *src);
 
-rpt_t*   rpt_create(ari_t *id, time_t time, tnvc_t *entries);
+rpt_t*   rpt_create(ari_t *id, OS_time_t time, tnvc_t *entries);
 
 void*    rpt_deserialize_ptr(QCBORDecodeContext *it, int *success);
 
@@ -146,4 +165,9 @@ int       rpttpl_serialize(QCBOREncodeContext *encoder, void *item);
 
 blob_t*   rpttpl_serialize_wrapper(rpttpl_t *rpttpl);
 
+
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* _REPORT_H_ */
diff --git a/nm/shared/primitives/rules.c b/nm/shared/primitives/rules.c
index 480f6147..2b95a07b 100644
--- a/nm/shared/primitives/rules.c
+++ b/nm/shared/primitives/rules.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file rules.c
@@ -24,7 +36,9 @@
  **  07/05/16  E. Birrane     Fixed time offsets when creating TRL & SRL (Secure DTN - NASA: NNX14CS58P)
  **  09/29/18  E. Birrane     Updated to AMPv0.5 (JHU/APL)
  *****************************************************************************/
-#include "platform.h"
+
+#include <inttypes.h>
+#include "shared/platform.h"
 
 #include "rules.h"
 
@@ -91,7 +105,7 @@ rule_t*   rule_copy_ptr(rule_t *src)
 	}
 
 	/* Shallow copy the easy things. */
-	result->ticks_left = src->ticks_left;
+	result->eval_at = src->eval_at;
 	result->flags = src->flags;
 	result->num_eval = src->num_eval;
 	result->num_fire = src->num_fire;
@@ -101,7 +115,7 @@ rule_t*   rule_copy_ptr(rule_t *src)
 }
 
 
-rule_t*  rule_create_sbr(ari_t id, uvast start, sbr_def_t def, ac_t action)
+rule_t*  rule_create_sbr(ari_t id, OS_time_t start, sbr_def_t def, ac_t action)
 {
 	rule_t *result = NULL;
 	int success;
@@ -123,22 +137,24 @@ rule_t*  rule_create_sbr(ari_t id, uvast start, sbr_def_t def, ac_t action)
 
 	RULE_SET_ACTIVE(result->flags);
 
-	if(start < AMP_RELATIVE_TIME_EPOCH)
+	if(OS_TimeGetTotalSeconds(start) < EPOCH_ABSTIME_DTN + EPOCH_DTN_POSIX)
 	{
-		result->ticks_left = start;
+          OS_time_t now;
+          OS_GetLocalTime(&now);
+          result->eval_at = OS_TimeAdd(start, now);
 	}
 	else
 	{
-		result->ticks_left = (start - getCtime());
+          result->eval_at = start;
 	}
 
 
-	AMP_DEBUG_EXIT("rule_create_sbr", ADDR_FIELDSPEC, (uaddr) result);
+	AMP_DEBUG_EXIT("rule_create_sbr", PRIdPTR, result);
 
 	return result;
 }
 
-rule_t*  rule_create_tbr(ari_t id, uvast start, tbr_def_t def, ac_t action)
+rule_t*  rule_create_tbr(ari_t id, OS_time_t start, tbr_def_t def, ac_t action)
 {
 	rule_t *result = NULL;
 	int success;
@@ -167,17 +183,19 @@ rule_t*  rule_create_tbr(ari_t id, uvast start, tbr_def_t def, ac_t action)
 
 	RULE_SET_ACTIVE(result->flags);
 
-	if(start < AMP_RELATIVE_TIME_EPOCH)
+	if(OS_TimeGetTotalSeconds(start) < EPOCH_ABSTIME_DTN + EPOCH_DTN_POSIX)
 	{
-		result->ticks_left = start + def.period;
+          OS_time_t now;
+          OS_GetLocalTime(&now);
+          result->eval_at = OS_TimeAdd(OS_TimeAdd(start, now), def.period);
 	}
 	else
 	{
-		result->ticks_left = (start - getCtime()) + def.period;
+          result->eval_at = OS_TimeAdd(start, def.period);
 	}
 
 
-	AMP_DEBUG_EXIT("rule_create_tbr", ADDR_FIELDSPEC, (uaddr) result);
+	AMP_DEBUG_EXIT("rule_create_tbr", PRIdPTR, result);
 
 	return result;
 }
@@ -188,7 +206,7 @@ rule_t*  rule_deserialize_helper(QCBORDecodeContext *array_it, int *success)
 {
 	rule_t *result = NULL;
 	ari_t *id;
-	uvast start;
+	OS_time_t start;
 	ac_t action;
 	sbr_def_t as_sbr;
 	tbr_def_t as_tbr;
@@ -278,8 +296,7 @@ rule_t*  rule_deserialize_ptr(QCBORDecodeContext *it, int *success)
 	rule_t *result = NULL;
 	QCBORError err;
 
-	AMP_DEBUG_ENTRY("rule_deserialize_ptr","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-						(uaddr)it, (uaddr)success);
+	AMP_DEBUG_ENTRY("rule_deserialize_ptr","(%"PRIxPTR",%"PRIxPTR")", it, success);
 
 	CHKNULL(success);
 	*success = AMP_FAIL;
@@ -351,8 +368,7 @@ rule_t*  rule_db_deserialize_ptr(QCBORDecodeContext *it, int *success)
 	rule_t *result = NULL;
 	QCBORError err;
 
-	AMP_DEBUG_ENTRY("rule_db_deserialize_ptr","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-					(uaddr)it, (uaddr)success);
+	AMP_DEBUG_ENTRY("rule_db_deserialize_ptr","(%"PRIxPTR",%"PRIxPTR")", it, success);
 
 	CHKNULL(success);
 	*success = AMP_FAIL;
@@ -393,7 +409,7 @@ rule_t*  rule_db_deserialize_ptr(QCBORDecodeContext *it, int *success)
 		return NULL;
 	}
 
-	*success = cut_get_cbor_numeric(it, AMP_TYPE_UINT, &(result->ticks_left));
+	*success = cut_get_cbor_numeric(it, AMP_TYPE_UINT, &(result->eval_at));
 	if(*success != AMP_OK)
 	{
 		rule_release(result, 1);
@@ -474,7 +490,8 @@ int rule_db_serialize(QCBOREncodeContext *encoder, void *item)
 	}
 
 	/* Step 2: Encode the ticks left. */
-	QCBOREncode_AddUInt64(encoder, rule->ticks_left);
+        amp_tv_t tv = amp_tv_from_ctime(rule->eval_at, NULL);
+        amp_tv_serialize(encoder, &tv);
 	QCBOREncode_AddUInt64(encoder, rule->num_eval);
 	QCBOREncode_AddUInt64(encoder, rule->num_fire);
 
@@ -559,7 +576,8 @@ int rule_serialize_helper(QCBOREncodeContext *array_enc, rule_t *rule)
 	}
 
 	/* Step 2: the start time. */
-	QCBOREncode_AddUInt64(array_enc, rule->start);
+        amp_tv_t tv = amp_tv_from_ctime(rule->start, NULL);
+        amp_tv_serialize(array_enc, &tv);
 
 	/* Step 3: Encode def. */
 	if(rule->id.type == AMP_TYPE_SBR)
@@ -612,6 +630,7 @@ int sbr_should_fire(rule_t *rule)
 	{
 	   	result = tnv_to_int(*eval_result, &success);
 	   	result = (success != AMP_OK) ? 0 : result;
+		AMP_DEBUG_INFO("sbr_should_fire", "Final result %d.", result);
 	}
 
    	tnv_release(eval_result, 1);
@@ -710,7 +729,8 @@ tbr_def_t tbrdef_deserialize(QCBORDecodeContext *array_it, int *success)
 int tbrdef_serialize(QCBOREncodeContext *array_enc, tbr_def_t *def)
 {
 	/* Step 1: Encode period. */
-	QCBOREncode_AddUInt64(array_enc, def->period);
+        amp_tv_t tv = amp_tv_from_ctime(def->period, NULL);
+        amp_tv_serialize(array_enc, &tv);
 
 	/* Step 2: Encode max num fires. */
 	QCBOREncode_AddUInt64(array_enc, def->max_fire);
diff --git a/nm/shared/primitives/rules.h b/nm/shared/primitives/rules.h
index 7f37dd46..873295c3 100644
--- a/nm/shared/primitives/rules.h
+++ b/nm/shared/primitives/rules.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** \file rules.h
@@ -33,6 +45,10 @@
 #include "../primitives/expr.h"
 
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
@@ -66,15 +82,15 @@
 typedef struct
 {
 	expr_t expr;       /**> If this evals to true, run action.      */
-	uvast max_fire; /**> # times to run action.                  */
-	uvast max_eval; /**> # times to eval expression.             */
+	amp_uvast max_fire; /**> # times to run action.                  */
+	amp_uvast max_eval; /**> # times to eval expression.             */
 } sbr_def_t;
 
 
 typedef struct
 {
-	uvast period;   /**> # ticks between rule firings.           */
-	uvast max_fire; /**> # times action can be run.              */
+	OS_time_t period;   /**> # ticks between rule firings.           */
+	amp_uvast max_fire; /**> # times action can be run.              */
 } tbr_def_t;
 
 
@@ -91,7 +107,7 @@ typedef struct
  */
 typedef struct {
 	ari_t id;          /**> The identifier for the SBR definition.  */
-	uvast start;       /**> When to start the evaluation.           */
+	OS_time_t start;       /**> When to start the evaluation.           */
 
 	union {
 		sbr_def_t as_sbr;
@@ -102,9 +118,9 @@ typedef struct {
 
 	/** Everything below is not part of a rule definition. **/
 
-	uint32_t ticks_left; /**> Number of ticks until next eval.      */
-	uvast    num_eval;   /**> Number of times rule evaluated.       */
-	uvast    num_fire;   /**> Number of times a rule action was run. */
+	OS_time_t eval_at;   /**> Time of next eval.      */
+	amp_uvast    num_eval;   /**> Number of times rule evaluated.       */
+	amp_uvast    num_fire;   /**> Number of times a rule action was run. */
 	uint8_t  flags;      /**> Status of rule: Active or not.        */
 
 	db_desc_t desc;      /**> SDR info. for persistent storage.     */
@@ -128,9 +144,9 @@ void      rule_cb_ht_del_fn(rh_elt_t *elt);
 
 rule_t*   rule_copy_ptr(rule_t *rule);
 
-rule_t*   rule_create_sbr(ari_t id, uvast start, sbr_def_t def, ac_t action);
+rule_t*   rule_create_sbr(ari_t id, OS_time_t start, sbr_def_t def, ac_t action);
 
-rule_t*   rule_create_tbr(ari_t id, uvast start, tbr_def_t def, ac_t action);
+rule_t*   rule_create_tbr(ari_t id, OS_time_t start, tbr_def_t def, ac_t action);
 
 rule_t*   rule_deserialize_helper(QCBORDecodeContext *it, int *success);
 
@@ -166,4 +182,8 @@ tbr_def_t tbrdef_deserialize(QCBORDecodeContext *it, int *success);
 int tbrdef_serialize(QCBOREncodeContext *encoder, tbr_def_t *def);
 
 
-#endif // _RULES_H_
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _RULES_H_ */
diff --git a/nm/shared/primitives/table.c b/nm/shared/primitives/table.c
index b31ceb67..30851b21 100644
--- a/nm/shared/primitives/table.c
+++ b/nm/shared/primitives/table.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: table.c
@@ -20,11 +32,9 @@
  **  09/30/18  E. Birrane    Updated to AMP v0.5. (JHU/APL)
  *****************************************************************************/
 
-#include "platform.h"
-
-#include "ion.h"
+#include <inttypes.h>
+#include "shared/platform.h"
 #include "../utils/utils.h"
-
 #include "../primitives/table.h"
 #include "tnv.h"
 
@@ -144,8 +154,7 @@ void* tbl_deserialize_ptr(QCBORDecodeContext *it, int *success)
 	QCBORItem item;
 
 	AMP_DEBUG_ENTRY("tbl_deserialize_ptr",
-					"("ADDR_FIELDSPEC","ADDR_FIELDSPEC")",
-					(uaddr)it, (uaddr)success);
+					"(%"PRIxPTR",%"PRIxPTR")", it, success);
 
 	/* Sanity Checks. */
 	CHKNULL(success);
@@ -350,7 +359,25 @@ int tbl_serialize(QCBOREncodeContext *encoder, void *item)
 
 blob_t*   tbl_serialize_wrapper(tbl_t *tbl)
 {
-	return cut_serialize_wrapper(TBL_DEFAULT_ENC_SIZE, tbl, (cut_enc_fn)tbl_serialize);
+    blob_t *result = NULL;
+
+    /*
+     * Tables may have increasingly large numbers of entries. To
+     * preserve memory, we try with first small, then large, then huge allocations.
+     */
+
+    if((result = cut_serialize_wrapper(TBL_DEFAULT_ENC_SIZE_SMALL, tbl, (cut_enc_fn)tbl_serialize)) == NULL)
+    {
+        AMP_DEBUG_WARN("tbl_serialize_wrapper", "Increasing buffer size to %d.", TBL_DEFAULT_ENC_SIZE_LARGE);
+
+        if((result = cut_serialize_wrapper(TBL_DEFAULT_ENC_SIZE_LARGE, tbl, (cut_enc_fn)tbl_serialize)) == NULL)
+        {
+            AMP_DEBUG_WARN("tbl_serialize_wrapper", "Increasing buffer size to %d.", TBL_DEFAULT_ENC_SIZE_HUGE);
+            result = cut_serialize_wrapper(TBL_DEFAULT_ENC_SIZE_HUGE, tbl, (cut_enc_fn)tbl_serialize);
+        }
+    }
+
+	return result;
 }
 
 void tbl_cb_del_fn(void *item)
diff --git a/nm/shared/primitives/table.h b/nm/shared/primitives/table.h
index 332ff956..c90def39 100644
--- a/nm/shared/primitives/table.h
+++ b/nm/shared/primitives/table.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: table.h
@@ -33,13 +45,22 @@
 #include "../utils/db.h"
 #include "ari.h"
 
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
  * +--------------------------------------------------------------------------+
  */
 
-#define TBL_DEFAULT_ENC_SIZE  1024
+#define TBL_DEFAULT_ENC_SIZE_SMALL  1024
+#define TBL_DEFAULT_ENC_SIZE_LARGE  10240
+#define TBL_DEFAULT_ENC_SIZE_HUGE   102400
+
 #define TBLT_DEFAULT_ENC_SIZE 1024
 
 /*
@@ -143,4 +164,8 @@ void      tblt_col_cb_del_fn(void *item);
 void*     tblt_col_cb_copy_fn(void *item);
 
 
-#endif // TABLE_H_
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _TABLE_H_ */
diff --git a/nm/shared/primitives/tnv.c b/nm/shared/primitives/tnv.c
index f6099b2e..c7f3040d 100644
--- a/nm/shared/primitives/tnv.c
+++ b/nm/shared/primitives/tnv.c
@@ -1,11 +1,23 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
- ** File Name: tdc.c
+ ** File Name: tnv.c
  **
  ** Description: This implements a Type-Name-Value instance and multiple
  **              encodings of TNV collections.
@@ -25,9 +37,8 @@
  **  08/28/18  E. Birrane     Update to latest spec and TNVs (JHU/APL)
  *****************************************************************************/
 
-#include "platform.h"
-
-#include "ion.h"
+#include <inttypes.h>
+#include "shared/platform.h"
 #include "../utils/utils.h"
 
 #include "tnv.h"
@@ -88,6 +99,7 @@ tnv_t* tnv_cast(tnv_t *tnv, amp_type_e type)
 		(type_is_numeric(type) == 0) ||
 		(TNV_IS_MAP(tnv->flags)))
 	{
+		AMP_DEBUG_ERR("tnv_cast", "tnv->type is %d and type is %d.", tnv->type, type);
 		AMP_DEBUG_ERR("tnv_cast","Bad parms.", NULL);
 		return NULL;
 	}
@@ -97,7 +109,7 @@ tnv_t* tnv_cast(tnv_t *tnv, amp_type_e type)
 		case AMP_TYPE_INT:   result = tnv_from_int(tnv_to_int(*tnv, &success)); break;
 		case AMP_TYPE_UINT:  result = tnv_from_uint(tnv_to_uint(*tnv, &success)); break;
 		case AMP_TYPE_VAST:  result = tnv_from_vast(tnv_to_vast(*tnv, &success)); break;
-		case AMP_TYPE_TV:    result = tnv_from_tv(tnv_to_uvast(*tnv, &success)); break;
+		case AMP_TYPE_TV:    result = tnv_from_tv(tnv_to_tv(*tnv, &success)); break;
 		case AMP_TYPE_TS:
 		case AMP_TYPE_UVAST:  result = tnv_from_uvast(tnv_to_uvast(*tnv, &success)); break;
 		case AMP_TYPE_REAL32:  result = tnv_from_real32(tnv_to_real32(*tnv, &success)); break;
@@ -293,6 +305,7 @@ tnv_t *tnv_copy_ptr(tnv_t *val)
 
 	if(val == NULL)
 	{
+		AMP_DEBUG_ERR("tnv_copy_ptr","NULL value.", NULL);
 		return NULL;
 	}
 
@@ -348,7 +361,7 @@ tnv_t tnv_deserialize(QCBORDecodeContext *it, int *success)
     QCBORError err;
     tnv_t result;
 
-    AMP_DEBUG_ENTRY("tnv_deserialize","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")", (uaddr)it, (uaddr)success);
+    AMP_DEBUG_ENTRY("tnv_deserialize","(%"PRIxPTR",%"PRIxPTR")", it, success);
 
     tnv_init(&result, AMP_TYPE_UNK);
 
@@ -501,10 +514,10 @@ int tnv_deserialize_val_by_type(QCBORDecodeContext *it, tnv_t *result)
 	   	case AMP_TYPE_BYTE:   success = cut_get_cbor_numeric(it, result->type, (uint8_t*) &(result->value.as_byte));  break;
 	   	case AMP_TYPE_INT:    success = cut_get_cbor_numeric(it, result->type, (int32_t*) &(result->value.as_int));   break;
 	   	case AMP_TYPE_UINT:   success = cut_get_cbor_numeric(it, result->type, (uint32_t*) &(result->value.as_uint)); break;
-	   	case AMP_TYPE_VAST:   success = cut_get_cbor_numeric(it, result->type, (vast*) &(result->value.as_vast));     break;
+	   	case AMP_TYPE_VAST:   success = cut_get_cbor_numeric(it, result->type, (amp_vast*) &(result->value.as_vast));     break;
 	   	case AMP_TYPE_TV:
 	   	case AMP_TYPE_TS:
-	   	case AMP_TYPE_UVAST:  success = cut_get_cbor_numeric(it, result->type, (uvast*) &(result->value.as_uvast));   break;
+	   	case AMP_TYPE_UVAST:  success = cut_get_cbor_numeric(it, result->type, (amp_uvast*) &(result->value.as_uvast));   break;
 	   	case AMP_TYPE_REAL32: success = cut_get_cbor_numeric(it, result->type, (float*) &(result->value.as_real32));  break;
 	   	case AMP_TYPE_REAL64: success = cut_get_cbor_numeric(it, result->type, (double*) &(result->value.as_real64)); break;
 
@@ -748,7 +761,7 @@ tnv_t* tnv_from_real64(double val)
  *   1. Result must be freed with tnv_release(<item>, 1);
  *****************************************************************************/
 
-tnv_t*  tnv_from_str(char *str)
+tnv_t*  tnv_from_str(const char *str)
 {
 	tnv_t* result = NULL;
 	uint32_t len = 0;
@@ -809,7 +822,7 @@ tnv_t*  tnv_from_uint(uint32_t val)
  *   1. Result must be freed with tnv_release(<item>, 1);
  *****************************************************************************/
 
-tnv_t*  tnv_from_uvast(uvast val)
+tnv_t*  tnv_from_uvast(amp_uvast val)
 {
 	tnv_t *result = tnv_create();
 	CHKNULL(result);
@@ -831,12 +844,12 @@ tnv_t*  tnv_from_uvast(uvast val)
  *   1. Result must be freed with tnv_release(<item>, 1);
  *****************************************************************************/
 
-tnv_t*  tnv_from_tv(time_t val)
+tnv_t*  tnv_from_tv(amp_tv_t val)
 {
 	tnv_t *result = tnv_create();
 	CHKNULL(result);
 	tnv_init(result, AMP_TYPE_TV);
-	result->value.as_uvast = val;
+	result->value.as_uvast = OS_TimeGetTotalSeconds(val.secs);
 	return result;
 }
 
@@ -853,7 +866,7 @@ tnv_t*  tnv_from_tv(time_t val)
  *   1. Result must be freed with tnv_release(<item>, 1);
  *****************************************************************************/
 
-tnv_t*  tnv_from_vast(vast val)
+tnv_t*  tnv_from_vast(amp_vast val)
 {
 	tnv_t *result = tnv_create();
 	CHKNULL(result);
@@ -1153,6 +1166,8 @@ int32_t  tnv_to_int(tnv_t val, int *success)
 		case AMP_TYPE_INT:    result = val.value.as_int;              break;
 		case AMP_TYPE_UINT:   result = (int32_t) val.value.as_uint;   break;
 		case AMP_TYPE_VAST:   result = (int32_t) val.value.as_vast;   break;
+		case AMP_TYPE_TV:
+		case AMP_TYPE_TS:
 		case AMP_TYPE_UVAST:  result = (int32_t) val.value.as_uvast;  break;
 		case AMP_TYPE_REAL32: result = (int32_t) val.value.as_real32; break;
 		case AMP_TYPE_REAL64: result = (int32_t) val.value.as_real64; break;
@@ -1196,6 +1211,8 @@ float  tnv_to_real32(tnv_t val, int *success)
 		case AMP_TYPE_INT:   result = (float) val.value.as_int;    break;
 		case AMP_TYPE_UINT:  result = (float) val.value.as_uint;   break;
 		case AMP_TYPE_VAST:  result = (float) val.value.as_vast;   break;
+        case AMP_TYPE_TV:
+        case AMP_TYPE_TS:
 		case AMP_TYPE_UVAST: result = (float) val.value.as_uvast;  break;
 		case AMP_TYPE_REAL32:result = (float) val.value.as_real32; break;
 		case AMP_TYPE_REAL64:result = (float) val.value.as_real64; break;
@@ -1238,6 +1255,8 @@ double  tnv_to_real64(tnv_t val, int *success)
 		case AMP_TYPE_INT:   result = (double) val.value.as_int;    break;
 		case AMP_TYPE_UINT:  result = (double) val.value.as_uint;   break;
 		case AMP_TYPE_VAST:  result = (double) val.value.as_vast;   break;
+        case AMP_TYPE_TV:
+        case AMP_TYPE_TS:
 		case AMP_TYPE_UVAST: result = (double) val.value.as_uvast;  break;
 		case AMP_TYPE_REAL32:result = (double) val.value.as_real32; break;
 		case AMP_TYPE_REAL64:result = (double) val.value.as_real64; break;
@@ -1247,7 +1266,6 @@ double  tnv_to_real64(tnv_t val, int *success)
 }
 
 
-
 /******************************************************************************
  * Conversion function, relying on language type casting rather than trying
  * to be clever based on internal representation.
@@ -1280,6 +1298,8 @@ uint32_t  tnv_to_uint(tnv_t val, int *success)
 		case AMP_TYPE_INT:    result = (uint32_t) val.value.as_int;    break;
 		case AMP_TYPE_UINT:   result = val.value.as_uint;              break;
 		case AMP_TYPE_VAST:   result = (uint32_t) val.value.as_vast;   break;
+        case AMP_TYPE_TV:
+        case AMP_TYPE_TS:
 		case AMP_TYPE_UVAST:  result = (uint32_t) val.value.as_uvast;  break;
 		case AMP_TYPE_REAL32: result = (uint32_t) val.value.as_real32; break;
 		case AMP_TYPE_REAL64: result = (uint32_t) val.value.as_real64; break;
@@ -1304,9 +1324,9 @@ uint32_t  tnv_to_uint(tnv_t val, int *success)
  *   1. Mapped values cannot be converted.
  *****************************************************************************/
 
-uvast  tnv_to_uvast(tnv_t val, int *success)
+amp_uvast  tnv_to_uvast(tnv_t val, int *success)
 {
-	uvast result = 0;
+	amp_uvast result = 0;
 
 	if(TNV_IS_MAP(val.flags))
 	{
@@ -1319,13 +1339,15 @@ uvast  tnv_to_uvast(tnv_t val, int *success)
 	switch(val.type)
 	{
 		case AMP_TYPE_BOOL:
-		case AMP_TYPE_BYTE:   result = (uvast) val.value.as_byte;   break;
-		case AMP_TYPE_INT:    result = (uvast) val.value.as_int;    break;
-		case AMP_TYPE_UINT:   result = (uvast) val.value.as_uint;   break;
-		case AMP_TYPE_VAST:   result = (uvast) val.value.as_vast;   break;
+		case AMP_TYPE_BYTE:   result = (amp_uvast) val.value.as_byte;   break;
+		case AMP_TYPE_INT:    result = (amp_uvast) val.value.as_int;    break;
+		case AMP_TYPE_UINT:   result = (amp_uvast) val.value.as_uint;   break;
+		case AMP_TYPE_VAST:   result = (amp_uvast) val.value.as_vast;   break;
+		case AMP_TYPE_TV:
+		case AMP_TYPE_TS:
 		case AMP_TYPE_UVAST:  result =  val.value.as_uvast;         break;
-		case AMP_TYPE_REAL32: result = (uvast) val.value.as_real32; break;
-		case AMP_TYPE_REAL64: result = (uvast) val.value.as_real64; break;
+		case AMP_TYPE_REAL32: result = (amp_uvast) val.value.as_real32; break;
+		case AMP_TYPE_REAL64: result = (amp_uvast) val.value.as_real64; break;
 		default: *success = AMP_FAIL; break;
 	}
 	return result;
@@ -1346,9 +1368,9 @@ uvast  tnv_to_uvast(tnv_t val, int *success)
  *   1. Mapped values cannot be converted.
  *****************************************************************************/
 
-vast  tnv_to_vast(tnv_t val, int *success)
+amp_vast  tnv_to_vast(tnv_t val, int *success)
 {
-	vast result = 0;
+	amp_vast result = 0;
 
 	if(TNV_IS_MAP(val.flags))
 	{
@@ -1361,19 +1383,26 @@ vast  tnv_to_vast(tnv_t val, int *success)
 	switch(val.type)
 	{
 		case AMP_TYPE_BOOL:
-		case AMP_TYPE_BYTE:   result = (vast) val.value.as_byte;   break;
-		case AMP_TYPE_INT:    result = (vast) val.value.as_int;    break;
-		case AMP_TYPE_UINT:   result = (vast) val.value.as_uint;   break;
+		case AMP_TYPE_BYTE:   result = (amp_vast) val.value.as_byte;   break;
+		case AMP_TYPE_INT:    result = (amp_vast) val.value.as_int;    break;
+		case AMP_TYPE_UINT:   result = (amp_vast) val.value.as_uint;   break;
 		case AMP_TYPE_VAST:   result = val.value.as_vast;          break;
-		case AMP_TYPE_UVAST:  result = (vast) val.value.as_uvast;  break;
-		case AMP_TYPE_REAL32: result = (vast) val.value.as_real32; break;
-		case AMP_TYPE_REAL64: result = (vast) val.value.as_real64; break;
+        case AMP_TYPE_TV:
+        case AMP_TYPE_TS:
+		case AMP_TYPE_UVAST:  result = (amp_vast) val.value.as_uvast;  break;
+		case AMP_TYPE_REAL32: result = (amp_vast) val.value.as_real32; break;
+		case AMP_TYPE_REAL64: result = (amp_vast) val.value.as_real64; break;
 		default: *success = AMP_FAIL; break;
 	}
 	return result;
 }
 
 
+amp_tv_t tnv_to_tv(tnv_t val, int *success)
+{
+  amp_vast secs = tnv_to_vast(val, success);
+  return (amp_tv_t){ .secs = OS_TimeFromTotalSeconds(secs) };
+}
 
 
 
@@ -1818,7 +1847,7 @@ static tnvc_t tnvc_deserialize_tvc(QCBORDecodeContext *array_it, size_t array_le
 	blob_t types;
 	int i;
 
-	AMP_DEBUG_ENTRY("tnvc_deserialize_tvc","(0x"ADDR_FIELDSPEC",0x"ADDR_FIELDSPEC")", (uaddr) array_it, (uaddr) success);
+	AMP_DEBUG_ENTRY("tnvc_deserialize_tvc","(0x%"PRIxPTR",0x%"PRIxPTR")", array_it, success);
 	memset(&result,0,sizeof(result));
 	*success = AMP_OK;
 
@@ -1892,7 +1921,7 @@ static tnvc_t tnvc_deserialize_tvc(QCBORDecodeContext *array_it, size_t array_le
 	blob_t types;
 	int i;
 
-	AMP_DEBUG_ENTRY("tnvc_deserialize_tvc","(0x"ADDR_FIELDSPEC",0x"ADDR_FIELDSPEC")", (uaddr) array_it, (uaddr) success);
+	AMP_DEBUG_ENTRY("tnvc_deserialize_tvc","(0x%"PRIxPTR",0x%"PRIxPTR")", array_it, success);
 	memset(&result,0,sizeof(result));
 	*success = AMP_OK;
 
@@ -2059,8 +2088,9 @@ blob_t tnvc_get_types(tnvc_t *tnvc, int *success)
 	blob_init(&types, NULL, 0, length);
 	for(i = 0; i < length; i++)
 	{
-		amp_type_e cur_type = tnvc_get_type(tnvc, i);
-		blob_append(&types, (uint8_t*)&cur_type, 1);
+		// Force as single-byte value for serializing
+		uint8_t cur_type = (uint8_t)tnvc_get_type(tnvc, i);
+		blob_append(&types, &cur_type, 1);
 	}
 
 	*success = AMP_OK;
@@ -2324,7 +2354,7 @@ static int tnvc_serialize_tvc(QCBOREncodeContext *encoder, tnvc_t *tnvc)
 
 
 /* 09/30/2018) */
-int  tnvc_size(tnvc_t *tnvc)
+size_t  tnvc_size(tnvc_t *tnvc)
 {
 	CHKZERO(tnvc);
 	return vec_num_entries(tnvc->values);
diff --git a/nm/shared/primitives/tnv.h b/nm/shared/primitives/tnv.h
index 1fd37df7..351385c4 100644
--- a/nm/shared/primitives/tnv.h
+++ b/nm/shared/primitives/tnv.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: tnv.h
@@ -30,15 +42,16 @@
 #ifndef TNV_H_
 #define TNV_H_
 
-#include "stdint.h"
-
-
+#include <stdint.h>
 #include "../utils/nm_types.h"
 #include "../utils/cbor_utils.h"
-
 #include "../utils/vector.h"
+#include "time.h"
 
 
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /*
  * +--------------------------------------------------------------------------+
@@ -119,8 +132,8 @@ typedef struct
 		uint8_t  as_byte;
 		uint32_t as_uint;
 		int32_t  as_int;
-		vast     as_vast;
-		uvast    as_uvast;
+		amp_vast     as_vast;
+		amp_uvast    as_uvast;
 		float    as_real32;
 		double   as_real64;
 	} value;
@@ -171,11 +184,11 @@ tnv_t*    tnv_from_map(amp_type_e type, uint8_t map_idx);
 tnv_t*    tnv_from_obj(amp_type_e type, void *item);
 tnv_t*    tnv_from_real32(float val);
 tnv_t*    tnv_from_real64(double val);
-tnv_t*    tnv_from_str(char *str);
+tnv_t*    tnv_from_str(const char *str);
 tnv_t*    tnv_from_uint(uint32_t val);
-tnv_t*    tnv_from_uvast(uvast val);
-tnv_t*    tnv_from_tv(time_t val);
-tnv_t*    tnv_from_vast(vast val);
+tnv_t*    tnv_from_uvast(amp_uvast val);
+tnv_t*    tnv_from_vast(amp_vast val);
+tnv_t*    tnv_from_tv(amp_tv_t val);
 void      tnv_init(tnv_t *val, amp_type_e type);
 int       tnv_serialize(QCBOREncodeContext *encoder, void *item);
 int       tnv_serialize_value(QCBOREncodeContext *encoder, void *item);
@@ -187,8 +200,9 @@ int32_t   tnv_to_int(tnv_t val, int *success);
 float     tnv_to_real32(tnv_t val, int *success);
 double	  tnv_to_real64(tnv_t val, int *success);
 uint32_t  tnv_to_uint(tnv_t val, int *success);
-uvast 	  tnv_to_uvast(tnv_t val, int *success);
-vast 	  tnv_to_vast(tnv_t val, int *success);
+amp_uvast 	  tnv_to_uvast(tnv_t val, int *success);
+amp_vast 	  tnv_to_vast(tnv_t val, int *success);
+amp_tv_t tnv_to_tv(tnv_t val, int *success);
 
 
 /*** TNVC Functions ***/
@@ -225,9 +239,13 @@ void     tnvc_release(tnvc_t *tnvc, int destroy);
 int      tnvc_serialize(QCBOREncodeContext *encoder, void *item);
 blob_t*  tnvc_serialize_wrapper(tnvc_t *tnvc);
 
-int      tnvc_size(tnvc_t *tnvc);
+size_t      tnvc_size(tnvc_t *tnvc);
 
 int      tnvc_update(tnvc_t *tnvc, uint8_t idx, tnv_t *src_tnv);
 
 
-#endif // TNV_H_INCLUDED
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _TNV_H_ */
diff --git a/nm/shared/utils/cbor_utils.c b/nm/shared/utils/cbor_utils.c
index 91a431db..c3414a75 100644
--- a/nm/shared/utils/cbor_utils.c
+++ b/nm/shared/utils/cbor_utils.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -26,7 +38,8 @@
  **  08/31/18  E. Birrane     Initial Implementation (JHU/APL)
  *****************************************************************************/
  
-#include "platform.h"
+#include <inttypes.h>
+#include "shared/platform.h"
 #include "cbor_utils.h"
 #include "utils.h"
 
@@ -162,7 +175,7 @@ int cut_dec_bytes(QCBORDecodeContext *it, uint8_t *buf, size_t len)
 
 /** Encode a UVAST into CBOR-encoding and return as a blob
  */
-int cut_enc_uvast(uvast num, blob_t *result)
+int cut_enc_uvast(amp_uvast num, blob_t *result)
 {
 	QCBOREncodeContext encoder;
 
@@ -233,7 +246,7 @@ int cut_get_cbor_numeric(QCBORDecodeContext *it, amp_type_e type, void *val)
 		*((uint8_t*)val) = UsefulInputBuf_GetByte(buf);
 
         // Decrement the nesting level
-        DecodeNesting_DecrementCount(&(it->nesting));
+//        DecodeNesting_DecrementCount(&(it->nesting));
 
 		// And check for errors
 		if (UsefulInputBuf_GetError(buf) == 0) {
@@ -353,6 +366,7 @@ blob_t* cut_serialize_wrapper(size_t size, void *item, cut_enc_fn encode)
 	blob_t *result = NULL;
 	QCBOREncodeContext encoder;
 	QCBORError err;
+	size_t orig_size = size;
 
 	if(item == NULL)
 	{
@@ -388,6 +402,13 @@ blob_t* cut_serialize_wrapper(size_t size, void *item, cut_enc_fn encode)
 
     UsefulBufC Encoded;
     err = QCBOREncode_Finish(&encoder, &Encoded);
+
+    // Debugging Info.
+    if(err == QCBOR_ERR_BUFFER_TOO_SMALL)
+    {
+        AMP_DEBUG_ERR("cut_serialize_wrapper","Buffer too small. Orig size was %d. Calc size was %d.", orig_size, size);
+    }
+
     if (err != QCBOR_SUCCESS) {
 		AMP_DEBUG_ERR("cut_serialize_wrapper", "Encoding Error %d", err);
 		blob_release(result,1);
@@ -404,7 +425,7 @@ int cut_deserialize_vector(vector_t *vec, QCBORDecodeContext *it, vec_des_fn des
 	size_t length;
 	size_t i;
 
-	AMP_DEBUG_ENTRY("cut_deserialize_vector","("ADDR_FIELDSPEC","ADDR_FIELDSPEC")", (uaddr)it, (uaddr)des_fn);
+	AMP_DEBUG_ENTRY("cut_deserialize_vector","(%p,%p)", it, des_fn);
 
 	// Sanity checks
 	if((vec == NULL) || (it == NULL))
diff --git a/nm/shared/utils/cbor_utils.h b/nm/shared/utils/cbor_utils.h
index 5578359e..208b1e5c 100644
--- a/nm/shared/utils/cbor_utils.h
+++ b/nm/shared/utils/cbor_utils.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -28,9 +40,14 @@
 #ifndef __CBOR_UTILS__
 #define __CBOR_UTILS__
 
+#include <qcbor/qcbor.h>
 #include "nm_types.h"
 #include "vector.h"
-#include "qcbor.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 
 #define CUT_ENC_BUFSIZE 4096
@@ -50,7 +67,7 @@ static inline int cut_enc_byte(QCBOREncodeContext *encoder, uint8_t buf)
    return cut_enc_bytes(encoder, &buf, sizeof(uint8_t));
 }
 
-int cut_enc_uvast(uvast num, blob_t *result);
+int cut_enc_uvast(amp_uvast num, blob_t *result);
 
 int cut_get_cbor_numeric_raw(blob_t *data, amp_type_e type, void *val);
 int       cut_get_cbor_numeric(QCBORDecodeContext *value, amp_type_e type, void *val);
@@ -74,4 +91,9 @@ int cut_get_cbor_str_ptr(QCBORDecodeContext *it, char *dst, size_t length);
      AMP_DEBUG_WARN(__func__, "Warning: CBOR Decoding finished with err %d", tmperr); \
    }
 
+
+#ifdef __cplusplus
+}
 #endif
+
+#endif  /* _CBOR_UTILS_H_ */
diff --git a/nm/shared/utils/db.c b/nm/shared/utils/db.c
index f42fddff..5bade61e 100644
--- a/nm/shared/utils/db.c
+++ b/nm/shared/utils/db.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -43,9 +55,9 @@ vdb_store_t gVDB;
 db_store_t  gDB;
 
 
-
-int  db_forget(db_desc_t *desc, Object list)
+int  db_forget(db_desc_t *desc, void* list)
 {
+#if 0
 	Sdr sdr = getIonsdr();
 	Object elt;
 
@@ -84,12 +96,13 @@ int  db_forget(db_desc_t *desc, Object list)
 
 	sdr_end_xn(sdr);
 
+#endif
 	return AMP_OK;
 }
 
-
 int  db_read_objs(char *name)
 {
+#if 0
 	Sdr sdr = getIonsdr();
 
 	CHKUSR(name, AMP_FAIL);
@@ -141,6 +154,7 @@ int  db_read_objs(char *name)
 		return -1;
 	}
 
+#endif
 	return 1;
 }
 
@@ -153,8 +167,9 @@ int  db_read_objs(char *name)
  * desc    : The db descriptor holding where this should live
  * list    : The SDR list holding the item descriptor (at *descrObj).
  */
-int  db_persist(blob_t *blob, db_desc_t *desc, Object list)
+int  db_persist(blob_t *blob, db_desc_t *desc, void* list)
 {
+#if 0
 	Sdr sdr = getIonsdr();
 
 	CHKUSR(blob, AMP_FAIL);
@@ -228,10 +243,10 @@ int  db_persist(blob_t *blob, db_desc_t *desc, Object list)
 	   return AMP_SYSERR;
    }
 
+#endif
    return AMP_OK;
 }
 
-
 int  db_persist_ctrl(void* item)
 {
 	int result;
@@ -239,7 +254,7 @@ int  db_persist_ctrl(void* item)
 	blob_t *blob = ctrl_db_serialize(ctrl);
 
 	CHKERR(blob);
-	result = db_persist(blob, &(ctrl->desc), gDB.ctrls);
+//	result = db_persist(blob, &(ctrl->desc), gDB.ctrls);
 	blob_release(blob, 1);
 	return result;
 }
@@ -252,7 +267,7 @@ int  db_persist_macdef(void* item)
 	blob_t *blob = macdef_serialize_wrapper(def);
 
 	CHKERR(blob);
-	result = db_persist(blob, &(def->desc), gDB.macdefs);
+//	result = db_persist(blob, &(def->desc), gDB.macdefs);
 	blob_release(blob, 1);
 	return result;
 }
@@ -264,7 +279,7 @@ int  db_persist_rpttpl(void *item)
 	blob_t *blob = rpttpl_serialize_wrapper(rpttpl);
 
 	CHKERR(blob);
-	result = db_persist(blob, &(rpttpl->desc), gDB.rpttpls);
+//	result = db_persist(blob, &(rpttpl->desc), gDB.rpttpls);
 	blob_release(blob, 1);
 	return result;
 }
@@ -276,7 +291,7 @@ int  db_persist_rule(void* item)
 	blob_t *blob = rule_db_serialize_wrapper(rule);
 
 	CHKERR(blob);
-	result = db_persist(blob, &(rule->desc), gDB.rules);
+//	result = db_persist(blob, &(rule->desc), gDB.rules);
 	blob_release(blob, 1);
 	return result;
 }
@@ -292,7 +307,7 @@ int  db_persist_var(void* item)
 	{
 		return AMP_FAIL;
 	}
-	result = db_persist(blob, &(var->desc), gDB.vars);
+//	result = db_persist(blob, &(var->desc), gDB.vars);
 	blob_release(blob, 1);
 	return result;
 }
@@ -303,8 +318,9 @@ int  db_persist_var(void* item)
  * Initialize VDB list from a list in the SDR.
  */
 
-int vdb_obj_init(Object sdr_list, vdb_init_cb_fn init_cb)
+int vdb_obj_init(void* sdr_list, vdb_init_cb_fn init_cb)
 {
+#if 0
 	Object elt;
 	Object descObj;
 	db_desc_t cur_desc;
@@ -353,6 +369,9 @@ int vdb_obj_init(Object sdr_list, vdb_init_cb_fn init_cb)
 	sdr_end_xn(sdr);
 
 	return num;
+#else
+	return 0;
+#endif
 }
 
 
@@ -568,6 +587,7 @@ int db_init(char *name, void (*adm_init_cb)())
 
 	success = db_read_objs(name);
 
+#if 0
 	num = vdb_obj_init(gDB.ctrls, vdb_db_init_ctrl);
 	AMP_DEBUG_ALWAYS("vdb_init", "Added %d Controls from DB.", num);
 
@@ -582,6 +602,7 @@ int db_init(char *name, void (*adm_init_cb)())
 
 	num = vdb_obj_init(gDB.vars,    vdb_db_init_var);
 	AMP_DEBUG_ALWAYS("vdb_init", "Added %d Variable Definitions from DB.", num);
+#endif
 
 	return success;
 }
diff --git a/nm/shared/utils/db.h b/nm/shared/utils/db.h
index 90808424..46c2d565 100644
--- a/nm/shared/utils/db.h
+++ b/nm/shared/utils/db.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2013 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2013-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -29,12 +41,15 @@
 #ifndef DB_H_
 #define DB_H_
 
-#include "platform.h"
-#include "sdr.h"
-
-#include "nm_types.h"
+#include "shared/platform.h"
 #include "rhht.h"
 #include "vector.h"
+#include "nm_types.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 
 /*
@@ -168,12 +183,12 @@
 
 typedef struct
 {
-   Object  ctrls;
-   Object  macdefs;
-   Object  rpttpls;
-   Object  rules;
-   Object  vars;
-   Object  descObj;  /**> The pointer to the store object in the SDR. */
+  //Object  ctrls;
+  //Object  macdefs;
+  //Object  rpttpls;
+  //Object  rules;
+  //Object  vars;
+  //Object  descObj;  /**> The pointer to the store object in the SDR. */
 } db_store_t;
 
 
@@ -207,11 +222,11 @@ typedef struct
  */
 typedef struct
 {
-	Object itemObj;     /**> Serialized object in an SDR. */
+  //Object itemObj;     /**> Serialized object in an SDR. */
 	uint32_t itemSize;  /**> Size of object in itemObj.   */
 
     /* Below is not kept in the SDR. */
-	Object descObj;     /**> This descriptor in SDR.      */
+  //Object descObj;     /**> This descriptor in SDR.      */
 } db_desc_t;
 
 
@@ -230,11 +245,9 @@ extern db_store_t  gDB;
  */
 
 
+int  db_forget(db_desc_t *desc, void* list);
 
-int  db_forget(db_desc_t *desc, Object list);
-
-
-int  db_persist(blob_t *blob, db_desc_t *desc, Object list);
+int  db_persist(blob_t *blob, db_desc_t *desc, void* list);
 
 int  db_persist_ctrl(void* item);
 int  db_persist_macdef(void* item);
@@ -249,7 +262,7 @@ void db_destroy();
 int db_init(char *name, void (*adm_init_cb)());
 
 
-int vdb_obj_init(Object sdr_list, vdb_init_cb_fn init_cb);
+//int vdb_obj_init(Object sdr_list, vdb_init_cb_fn init_cb);
 
 int vdb_db_init_ctrl(blob_t *data, db_desc_t desc);
 
@@ -259,4 +272,8 @@ int vdb_db_init_rule(blob_t *data, db_desc_t desc);
 int vdb_db_init_var(blob_t *data, db_desc_t desc);
 
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* DB_H_ */
diff --git a/nm/shared/utils/debug.h b/nm/shared/utils/debug.h
index 08f9ded2..2047777b 100644
--- a/nm/shared/utils/debug.h
+++ b/nm/shared/utils/debug.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2011-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -23,6 +35,13 @@
 #ifndef DEBUG_H_
 #define DEBUG_H_
 
+#include <stdio.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 /*****************************************************************************
  *                              DEBUG DEFINITIONS                            *
  *****************************************************************************/
@@ -36,12 +55,8 @@
 #define AMP_DEBUG_LVL_WARN 3 /** Warning and above debugging */
 #define AMP_DEBUG_LVL_ERR  4 /** Error and above debugging */
 
-#define AMP_DEBUG_LVL	AMP_DEBUG_LVL_WARN
-
+#define AMP_DEBUG_LVL	AMP_DEBUG_LVL_PROC
 #define	AMP_GMSG_BUFLEN	256
-#if AMP_DEBUGGING == 1
-extern char		gAmpMsg[];		/*	Debug message buffer.	*/
-#endif
 
 /**
  * \def AMP_DEBUG
@@ -71,37 +86,27 @@ extern char		gAmpMsg[];		/*	Debug message buffer.	*/
  * AMP_DEBUGGING #define.
  */
 
-#if defined (ION_LWT)
-
-#define AMP_DEBUG(level, type, func, format,...) if(level >= AMP_DEBUG_LVL) \
-{_isprintf(gAmpMsg, AMP_GMSG_BUFLEN, format, __VA_ARGS__); putErrmsg(func, gAmpMsg);}
+#if AMP_DEBUGGING == 1
+#define AMP_DEBUG_ENTRY(func, format, ...)  amp_log(AMP_DEBUG_LVL_PROC,'+', __FILE__, __LINE__, func, format, ##__VA_ARGS__)
+#define AMP_DEBUG_EXIT(func, format, ...)   amp_log(AMP_DEBUG_LVL_PROC,'-', __FILE__, __LINE__, func, format, ##__VA_ARGS__)
+#define AMP_DEBUG_INFO(func, format, ...)   amp_log(AMP_DEBUG_LVL_INFO,'i', __FILE__, __LINE__, func, format, ##__VA_ARGS__)
+#define AMP_DEBUG_WARN(func, format, ...)   amp_log(AMP_DEBUG_LVL_WARN,'w', __FILE__, __LINE__, func, format, ##__VA_ARGS__)
+#define AMP_DEBUG_ERR(func, format, ...)    amp_log(AMP_DEBUG_LVL_ERR, 'x', __FILE__, __LINE__, func, format, ##__VA_ARGS__)
+#define AMP_DEBUG_ALWAYS(func, format, ...) amp_log(AMP_DEBUG_LVL,     ':', __FILE__, __LINE__, func, format, ##__VA_ARGS__)
+void amp_log(int level, char label, const char *file, int line, const char *func, const char *fmt, ...);
 
 #else
-
-#define AMP_DEBUG(level, type, func, format,...) if(level >= AMP_DEBUG_LVL) \
-{isprintf(gAmpMsg, AMP_GMSG_BUFLEN, (char *) format, __VA_ARGS__); \
-fprintf(stderr, "[%s:%d] %c %s %s\n",__FILE__,__LINE__,type, func, gAmpMsg);}
+#define AMP_DEBUG_ENTRY(func, format, ...)
+#define AMP_DEBUG_EXIT(func, format, ...)
+#define AMP_DEBUG_INFO(func, format, ...)
+#define AMP_DEBUG_WARN(func, format, ...)
+#define AMP_DEBUG_ERR(func, format, ...)
+#define AMP_DEBUG_ALWAYS(func, format, ...)
 
 #endif
 
-#define AMP_DEBUG_ENTRY(func, format,...) \
-AMP_DEBUG(AMP_DEBUG_LVL_PROC,'+',func,format, __VA_ARGS__)
-
-#define AMP_DEBUG_EXIT(func, format,...) \
-AMP_DEBUG(AMP_DEBUG_LVL_PROC,'-',func,format, __VA_ARGS__)
-
-#define AMP_DEBUG_INFO(func, format,...) \
-AMP_DEBUG(AMP_DEBUG_LVL_INFO,'i',func,format, __VA_ARGS__)
-
-#define AMP_DEBUG_WARN(func, format,...) \
-AMP_DEBUG(AMP_DEBUG_LVL_WARN,'w',func,format, __VA_ARGS__)
-
-#define AMP_DEBUG_ERR(func, format,...) \
-AMP_DEBUG(AMP_DEBUG_LVL_ERR,'x',func,format, __VA_ARGS__)
-
-#define AMP_DEBUG_ALWAYS(func, format,...) \
-AMP_DEBUG(AMP_DEBUG_LVL,':',func,format, __VA_ARGS__)
-
-#define AMP_DBG_ERR(format,...) AMP_DEBUG_ERR(__func__,format,__VA_ARGS__)
+#ifdef __cplusplus
+}
+#endif
 
-#endif // DEBUG_H_
+#endif  /* _DEBUG_H_ */
diff --git a/nm/shared/utils/nm_types.c b/nm/shared/utils/nm_types.c
index 1755e5c8..dc4cf593 100644
--- a/nm/shared/utils/nm_types.c
+++ b/nm/shared/utils/nm_types.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -22,6 +34,7 @@
  **  09/02/18  E. Birrane   Cleanup and update to latest spec. (JHU/APL)
  *****************************************************************************/
 #include "nm_types.h"
+#include <strings.h>
 
 const char * const amp_type_str[] = {
 										 "CNST",    /* AMP_TYPE_CNST    */
diff --git a/nm/shared/utils/nm_types.h b/nm/shared/utils/nm_types.h
index 20965001..02c6404b 100644
--- a/nm/shared/utils/nm_types.h
+++ b/nm/shared/utils/nm_types.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2011 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2011-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 
 /*****************************************************************************
@@ -28,11 +40,15 @@
 
 #include <stdint.h>
 #include <string.h>
-#include "platform.h"
-
+#include "shared/platform.h"
 #include "debug.h"
 
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
@@ -88,11 +104,6 @@ typedef enum
 #define AMP_MAX_EID_LEN (16)
 
 
-/* The AMP relative time cut-off, set as the first second of
- * September 9th, 2012.
- */
-#define AMP_RELATIVE_TIME_EPOCH (1347148800)
-
 /*
  * +--------------------------------------------------------------------------+
  * |							  	MACROS  								  +
@@ -133,4 +144,8 @@ uint8_t      type_is_known(amp_type_e type);
 const char*  type_to_str(amp_type_e type);
 
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* NM_TYPES_H */
diff --git a/nm/shared/utils/rhht.c b/nm/shared/utils/rhht.c
index 05325128..90aa9b78 100644
--- a/nm/shared/utils/rhht.c
+++ b/nm/shared/utils/rhht.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -37,6 +49,8 @@
  **  09/14/18  E. Birrane     Updates for data structures, logging, reentrance,
  **                           coding standards and documentation. (JHU/APL)
  *****************************************************************************/
+
+#include <errno.h>
 #include "utils.h"
 #include "rhht.h"
 
@@ -226,18 +240,27 @@ rhht_t rhht_create(rh_idx_t buckets, rh_comp_fn compare, rh_hash_fn hash, rh_del
 		ht.num_elts = ht.max_delta = 0;
                 ht.num_bkts = buckets;
 
-		if(initResourceLock(&(ht.lock)))
-		{
-	        AMP_DEBUG_ERR("rhht_create","Unable to initialize mutex, errno = %s",
-	        		        strerror(errno));
-	        *success = RH_SYSERR;
-		}
-		else
-		{
-			ht.compare = (compare == NULL) ? p_rh_default_compare : compare;
-			ht.hash = (hash == NULL) ? p_rh_default_hash : hash;
-			ht.delete = del;
-		}
+                pthread_mutexattr_t attr;
+                pthread_mutexattr_init(&attr);
+                pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
+                if(pthread_mutex_init(&ht.lock, &attr))
+                {
+                  AMP_DEBUG_ERR("rhht_create","Unable to initialize mutex, errno = %s",
+                                strerror(errno));
+                  *success = RH_SYSERR;
+                  return ht;
+                }
+                if(pthread_cond_init(&ht.cond_ins_mod, NULL))
+                {
+                  AMP_DEBUG_ERR("rhht_create","Unable to initialize condvar, errno = %s",
+                                strerror(errno));
+                  *success = RH_SYSERR;
+                  return ht;
+                }
+
+                ht.compare = (compare == NULL) ? p_rh_default_compare : compare;
+                ht.hash = (hash == NULL) ? p_rh_default_hash : hash;
+                ht.delete = del;
 	}
 
 	return ht;
@@ -249,7 +272,7 @@ void rhht_del_idx(rhht_t *ht, rh_idx_t idx)
 	CHKVOID(ht);
 	CHKVOID(idx < ht->num_bkts);
 
-	lockResource(&(ht->lock));
+	pthread_mutex_lock(&ht->lock);
 
 	if((ht->buckets[idx].value != NULL) && (ht->delete != NULL))
 	{
@@ -261,9 +284,9 @@ void rhht_del_idx(rhht_t *ht, rh_idx_t idx)
 	ht->buckets[idx].delta = 0;
 	ht->num_elts--;
 
-    p_rhht_bkwrd_shft(ht, idx);
+        p_rhht_bkwrd_shft(ht, idx);
 
-    unlockResource(&(ht->lock));
+	pthread_mutex_unlock(&ht->lock);
 }
 
 void rhht_del_key(rhht_t *ht, void *item)
@@ -319,12 +342,12 @@ int rhht_find(rhht_t *ht, void *key, rh_idx_t *idx)
 	/* Step 1: Hash the item. */
 	tmp = ht->hash(ht, key);
 
-	lockResource(&(ht->lock));
+	pthread_mutex_lock(&ht->lock);
 
 	/* Step 2: If nothing is there, it.. isn't there. */
 	if(ht->buckets[tmp].value == NULL)
 	{
-		unlockResource(&(ht->lock));
+        	pthread_mutex_unlock(&ht->lock);
 		return RH_NOT_FOUND;
 	}
 
@@ -337,7 +360,7 @@ int rhht_find(rhht_t *ht, void *key, rh_idx_t *idx)
 				*idx = tmp;
 			}
 
-			unlockResource(&(ht->lock));
+        	pthread_mutex_unlock(&ht->lock);
 			return RH_OK;
 		}
 
@@ -359,7 +382,7 @@ int rhht_find(rhht_t *ht, void *key, rh_idx_t *idx)
 		*idx = tmp;
 	}
 
-	unlockResource(&(ht->lock));
+        pthread_mutex_unlock(&ht->lock);
 
 	return RH_NOT_FOUND;
 }
@@ -373,7 +396,7 @@ void rhht_foreach(rhht_t *ht, rh_foreach_fn for_fn, void *tag)
 	CHKVOID(ht);
 	CHKVOID(for_fn);
 
-	lockResource(&(ht->lock));
+	pthread_mutex_lock(&ht->lock);
 	for(i = 0; i < ht->num_bkts; i++)
 	{
 		if(ht->buckets[i].value != NULL)
@@ -381,7 +404,7 @@ void rhht_foreach(rhht_t *ht, rh_foreach_fn for_fn, void *tag)
 			for_fn(&(ht->buckets[i]), tag);
 		}
 	}
-	unlockResource(&(ht->lock));
+        pthread_mutex_unlock(&ht->lock);
 }
 
 
@@ -429,7 +452,7 @@ int rhht_insert(rhht_t *ht, void *key, void *value, rh_idx_t *idx)
 	elt.delta = 0;
 	ideal_idx = ht->hash(ht, key);
 
-	lockResource(&(ht->lock));
+	pthread_mutex_lock(&ht->lock);
 
 	for(iter = 0; (iter < ht->num_bkts) && (elt.value != NULL); iter++)
 	{
@@ -471,7 +494,8 @@ int rhht_insert(rhht_t *ht, void *key, void *value, rh_idx_t *idx)
 
 	ht->num_elts++;
 
-	unlockResource(&(ht->lock));
+        pthread_cond_signal(&ht->cond_ins_mod);
+        pthread_mutex_unlock(&ht->lock);
 
     return RH_OK;
 }
@@ -508,9 +532,11 @@ void rhht_release(rhht_t *ht, int destroy)
 
     SRELEASE(ht->buckets);
 
+    pthread_cond_destroy(&ht->cond_ins_mod);
+    pthread_mutex_destroy(&ht->lock);
+
     if(destroy)
     {
-    	killResourceLock(&(ht->lock));
     	SRELEASE(ht);
     }
 }
diff --git a/nm/shared/utils/rhht.h b/nm/shared/utils/rhht.h
index 6b62673d..6e2695b5 100644
--- a/nm/shared/utils/rhht.h
+++ b/nm/shared/utils/rhht.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 /*****************************************************************************
  **
  ** File Name: rhht.h
@@ -33,10 +45,14 @@
 #ifndef RHHT_H_
 #define RHHT_H_
 
-#include "stdint.h"
-#include "ion.h"
+#include <stdint.h>
+#include <pthread.h>
 
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 /*
  * +--------------------------------------------------------------------------+
  * |							  CONSTANTS  								  +
@@ -93,7 +109,10 @@ typedef struct rhht {
     rh_idx_t   num_elts;
     rh_idx_t   max_delta;
 
-    ResourceLock lock;
+    /// Mutex handle
+    pthread_mutex_t lock;
+    /// Condition when a value is inserted or updated
+    pthread_cond_t cond_ins_mod;
 
     rh_comp_fn compare;
     rh_hash_fn hash;
@@ -119,4 +138,8 @@ void    rhht_release(rhht_t *ht, int destroy);
 void*   rhht_retrieve_idx(rhht_t *ht, rh_idx_t idx);
 void*   rhht_retrieve_key(rhht_t *ht, void *key);
 
+#ifdef __cplusplus
+}
+#endif
+
 #endif /* RHHT_H_ */
diff --git a/nm/shared/utils/utils.c b/nm/shared/utils/utils.c
index 5a5e0804..a87e6559 100644
--- a/nm/shared/utils/utils.c
+++ b/nm/shared/utils/utils.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -30,25 +42,41 @@
  **  09/02/18  E. Birrane     Removed Serialize/Deserialize functions (JHU/APL)
  *****************************************************************************/
 
-#include "platform.h"
-#include "ion.h"
-
-#include "../utils/debug.h"
-#include "../utils/utils.h"
+#include <stdlib.h>
+#include <stdarg.h>
+#include <osapi-mutex.h>
+#include <osapi-error.h>
+#include "shared/platform.h"
+#include "shared/utils/debug.h"
+#include "shared/utils/utils.h"
 #include "vector.h"
 
-static ResourceLock gMemMutex;
+static osal_id_t gMemMutex;
 
 
 #if AMP_DEBUGGING == 1
-char gAmpMsg[AMP_GMSG_BUFLEN];
+void amp_log(int level, char label, const char *file, int line, const char *func, const char *fmt, ...)
+{
+  if (level < AMP_DEBUG_LVL)
+  {
+    return;
+  }
+
+  va_list valist;
+  char gAmpMsg[AMP_GMSG_BUFLEN];
+  va_start(valist, fmt);
+  vsnprintf(gAmpMsg, AMP_GMSG_BUFLEN, (char *) fmt, valist);
+  va_end(valist);
+  fprintf(stderr, "[%s:%d] %c %s %s\n", file, line, label, func, gAmpMsg);
+}
+
 #endif
 
 int8_t utils_mem_int()
 {
-	if(initResourceLock(&gMemMutex))
+	if(OS_MutSemCreate(&gMemMutex, "utils", 0) != OS_SUCCESS)
 	{
-		AMP_DEBUG_ERR("utils_mem_int", "Cannot allocate memory mutex.", NULL);
+		AMP_DEBUG_ERR("utils_mem_int", "Cannot allocate memory mutex.");
 		return AMP_SYSERR;
 
 	}
@@ -57,7 +85,7 @@ int8_t utils_mem_int()
 
 void utils_mem_teardown()
 {
-	killResourceLock(&gMemMutex);
+	OS_MutSemDelete(gMemMutex);
 }
 
 
@@ -65,7 +93,7 @@ void* utils_safe_take(size_t size)
 {
 	void *result;
 
-	lockResource(&gMemMutex);
+	OS_MutSemTake(gMemMutex);
 #ifndef USE_MALLOC
 	result = MTAKE(size);
 #else
@@ -75,7 +103,7 @@ void* utils_safe_take(size_t size)
 	{
 		memset(result,0,size);
 	}
-	unlockResource(&gMemMutex);
+	OS_MutSemGive(gMemMutex);
 	return result;
 }
 
@@ -86,13 +114,13 @@ void utils_safe_release(void* ptr)
 		return;
 	}
 
-	lockResource(&gMemMutex);
+	OS_MutSemTake(gMemMutex);
 #ifndef USE_MALLOC
 	MRELEASE(ptr);
 #else
 	free(ptr); /* Use this when memory debugging with valgrind. */
 #endif
-	unlockResource(&gMemMutex);
+	OS_MutSemGive(gMemMutex);
 }
 
 /******************************************************************************
@@ -116,7 +144,7 @@ void utils_safe_release(void* ptr)
  *  09/02/18  E. Birrane     Updated to not hard-code success values. (JHU/APL)
  *****************************************************************************/
 
-unsigned long utils_atox(char *s, int *success)
+unsigned long utils_atox(const char *s, int *success)
 {
 	unsigned long result = 0;
 	int i = 0;
@@ -124,21 +152,21 @@ unsigned long utils_atox(char *s, int *success)
 	int j = 0;
 	int temp = 0;
 
-	AMP_DEBUG_ENTRY("utils_atox","(%#llx, %#llx)", s, success);
+	AMP_DEBUG_ENTRY("utils_atox","(%p, %p)", s, success);
 
 	/* Step 0 - Sanity Check. */
 	if (success == NULL)
 	{
-		AMP_DEBUG_ERR("utils_atox","Bad Args.",NULL);
-		AMP_DEBUG_ENTRY("utils_atox","->0.",NULL);
+		AMP_DEBUG_ERR("utils_atox","Bad Args.");
+		AMP_DEBUG_ENTRY("utils_atox","->0.");
 		return AMP_FAIL;
 	}
 
 	*success = AMP_FAIL;
 	if(s == NULL)
 	{
-		AMP_DEBUG_ERR("utils_atox","Bad Args.",NULL);
-		AMP_DEBUG_ENTRY("utils_atox","->0.",NULL);
+		AMP_DEBUG_ERR("utils_atox","Bad Args.");
+		AMP_DEBUG_ENTRY("utils_atox","->0.");
 		return AMP_FAIL;
 	}
 
@@ -162,7 +190,7 @@ unsigned long utils_atox(char *s, int *success)
 	{
 		AMP_DEBUG_ERR("utils_atox","x UI: String %s too long to convert to hex unsigned long.", s);
 		*success = AMP_FAIL;
-		AMP_DEBUG_ENTRY("utils_atox","->0.",NULL);
+		AMP_DEBUG_ENTRY("utils_atox","->0.");
 		return AMP_FAIL;
 	}
 
@@ -225,13 +253,13 @@ unsigned long utils_atox(char *s, int *success)
  *  10/14/12  E. Birrane     Initial implementation (JHU/APL)
  *****************************************************************************/
 
-char *utils_hex_to_string(uint8_t *buffer, uint32_t size)
+char *utils_hex_to_string(const uint8_t *buffer, size_t size)
 {
     char *result = NULL;
     uint32_t char_size = 0;
 
     char temp[3];
-    int i = 0;
+    size_t i = 0;
     int r = 0;
 
     AMP_DEBUG_ENTRY("utils_hex_to_string","(%x,%d)",
@@ -288,9 +316,9 @@ char *utils_hex_to_string(uint8_t *buffer, uint32_t size)
  *  10/14/12  E. Birrane     Initial implementation (JHU/APL)
  *****************************************************************************/
 
-void utils_print_hex(unsigned char *s, uint32_t len)
+void utils_print_hex(const unsigned char *s, size_t len)
 {
-	int i;
+	size_t i;
 
 	printf("0x");
 	for(i = 0; i < len; i++)
@@ -334,7 +362,7 @@ uint8_t getNibble(char c)
 
 
 
-blob_t* utils_string_to_hex(char *value)
+blob_t* utils_string_to_hex(const char *value)
 {
 	blob_t *result = NULL;
 	char tmp_s[3];
@@ -343,8 +371,6 @@ blob_t* utils_string_to_hex(char *value)
 	int pad = 0; 
 	size_t size = 0;
 
-	CHKNULL(value);
-
 	/*
 	 * Step 0.5 Handle case where string starts with "0x" by simply
 	 * advancing s to skip over it. This won't modify s from the
@@ -415,66 +441,3 @@ blob_t* utils_string_to_hex(char *value)
 	AMP_DEBUG_EXIT("utils_string_to_hex", "->%#llx.", result);
 	return result;
 }
-
-
-
-
-/*
- * THis software adapted from:
- * http://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html
- *
- * performs: result = t1 - t2.
- */
-int utils_time_delta(struct timeval *result, struct timeval *t1, struct timeval *t2)
-{
-	/* Perform the carry for the later subtraction by updating t2. */
-	if (t1->tv_usec < t2->tv_usec) {
-		int nsec = (t2->tv_usec - t1->tv_usec) / 1000000 + 1;
-		t2->tv_usec -= 1000000 * nsec;
-		t2->tv_sec += nsec;
-	}
-	if (t1->tv_usec - t2->tv_usec > 1000000) {
-		int nsec = (t1->tv_usec - t2->tv_usec) / 1000000;
-		t2->tv_usec += 1000000 * nsec;
-		t2->tv_sec -= nsec;
-	}
-
-	/* Compute the time remaining to wait.
-	          tv_usec is certainly positive. */
-	result->tv_sec = t1->tv_sec - t2->tv_sec;
-	result->tv_usec = t1->tv_usec - t2->tv_usec;
-
-	/* Return 1 if result is negative. */
-	return t1->tv_sec < t2->tv_sec;
-}
-
-
-
-/* Return number of micro-seconds that have elapsed since the passed-in time.*/
-vast    utils_time_cur_delta(struct timeval *t1)
-{
-	vast result = 0;
-
-	struct timeval cur;
-	struct timeval delta;
-	int neg = 0;
-
-	getCurrentTime(&cur);
-	neg = utils_time_delta(&delta, &cur, t1);
-
-	result = delta.tv_usec;
-	result += delta.tv_sec * 1000000;
-
-	if(neg)
-	{
-		result *= -1;
-	}
-
-	return result;
-}
-
-
-
-
-
-
diff --git a/nm/shared/utils/utils.h b/nm/shared/utils/utils.h
index 7c45d4de..71f32802 100644
--- a/nm/shared/utils/utils.h
+++ b/nm/shared/utils/utils.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2012 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2012-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*****************************************************************************
  **
@@ -29,12 +41,15 @@
 #ifndef UTILS_H_
 #define UTILS_H_
 
-#include "stdint.h"
-#include "platform.h"
-#include "bp.h"
-#include "lyst.h"
+#include <stdint.h>
+#include <osapi-clock.h>
+#include "shared/platform.h"
+#include "shared/primitives/blob.h"
 
-#include "../primitives/blob.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 /*
  * +--------------------------------------------------------------------------+
@@ -62,13 +77,9 @@
  * |							  	MACROS  								  +
  * +--------------------------------------------------------------------------+
  */
-//#define USE_MALLOC  // If set, utils_safe_* will use MALLOC instead of ION MTAKE/MRELEASE
-
 #define STAKE(size) utils_safe_take(size)
 #define SRELEASE(ptr) utils_safe_release(ptr)
 
-#define CHKUSR(e,usr)    		if (!(e) && iEnd(#e)) return usr
-
 /*
  * +--------------------------------------------------------------------------+
  * |							  DATA TYPES  								  +
@@ -88,14 +99,16 @@ void   utils_safe_release(void* ptr);
 void*  utils_safe_take(size_t size);
 
 //unsigned long utils_atox(char *s);
-unsigned long utils_atox(char *s, int *success);
+unsigned long utils_atox(const char *s, int *success);
 
-char*    utils_hex_to_string(uint8_t *buffer, uint32_t size);
-void     utils_print_hex(unsigned char *s, uint32_t len);
+char*    utils_hex_to_string(const uint8_t *buffer, size_t size);
+void     utils_print_hex(const unsigned char *s, size_t len);
 
-blob_t*  utils_string_to_hex(char *value);
-int      utils_time_delta(struct timeval *result, struct timeval *t1, struct timeval *t2);
-vast     utils_time_cur_delta(struct timeval *t1);
+blob_t*  utils_string_to_hex(const char *value);
 
 
-#endif /* UTILS_H_ */
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* _UTILS_H_ */
diff --git a/nm/shared/utils/vector.c b/nm/shared/utils/vector.c
index 07b2bbff..674ea397 100644
--- a/nm/shared/utils/vector.c
+++ b/nm/shared/utils/vector.c
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
  * vector.c
@@ -11,8 +23,9 @@
  *      Author: ebirrane
  */
 
+#include <osapi-error.h>
+#include "shared/platform.h"
 #include "shared/utils/utils.h"
-#include "platform.h"
 #include "vector.h"
 
 
@@ -88,7 +101,7 @@ void vec_clear(vector_t *vec)
 		return;
 	}
 
-	lockResource(&vec->lock);
+	pthread_mutex_lock(&vec->lock);
 
 	for(i = 0; i < vec->total_slots; i++)
 	{
@@ -105,7 +118,7 @@ void vec_clear(vector_t *vec)
 
 	vec->next_idx = 0;
     vec->num_free = vec->total_slots;
-	unlockResource(&vec->lock);
+	pthread_mutex_unlock(&vec->lock);
 }
 
 vector_t vec_copy(vector_t *src, int *success)
@@ -115,12 +128,12 @@ vector_t vec_copy(vector_t *src, int *success)
 
 	*success = AMP_FAIL;
 
-	lockResource(&(src->lock));
+	pthread_mutex_lock(&src->lock);
 
 	result = vec_create(src->total_slots, src->delete_fn, src->compare_fn, src->copy_fn, src->flags, success);
 	if(*success != VEC_OK)
 	{
-		unlockResource(&(src->lock));
+	  pthread_mutex_unlock(&src->lock);
 		return result;
 	}
 
@@ -137,7 +150,7 @@ vector_t vec_copy(vector_t *src, int *success)
 	result.next_idx = src->next_idx;
 	result.num_free = src->num_free;
 
-	unlockResource(&(src->lock));
+	pthread_mutex_unlock(&src->lock);
 
 	*success = VEC_OK;
 	return result;
@@ -149,11 +162,19 @@ vector_t vec_create(uint8_t num, vec_del_fn delete_fn, vec_comp_fn compare_fn, v
 
 	memset(&result,0, sizeof(vector_t));
 
-	if(initResourceLock(&(result.lock)))
+        pthread_mutexattr_t attr;
+        pthread_mutexattr_init(&attr);
+        pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
+	if(pthread_mutex_init(&result.lock, &attr))
 	{
 		*success = VEC_SYSERR;
 		return result;
 	}
+	if (pthread_cond_init(&result.cond_ins_mod, NULL))
+	{
+          *success = VEC_SYSERR;
+          return result;
+	}
 
 	result.flags = flags;
 
@@ -195,7 +216,7 @@ vec_idx_t vec_find(vector_t *vec, void *key, int *success)
 
 	*success = VEC_FAIL;
 
-	lockResource(&(vec->lock));
+	pthread_mutex_lock(&vec->lock);
 	for(result = 0; result < vec->total_slots; result++)
 	{
 		if(vec->data[result].occupied == 1)
@@ -208,7 +229,7 @@ vec_idx_t vec_find(vector_t *vec, void *key, int *success)
 		}
 	}
 
-	unlockResource(&(vec->lock));
+	pthread_mutex_unlock(&vec->lock);
 
 	return result;
 }
@@ -221,7 +242,7 @@ int vec_insert(vector_t *vec, void *value, vec_idx_t *idx)
 	CHKERR(vec);
 
 
-	lockResource(&(vec->lock));
+	pthread_mutex_lock(&vec->lock);
 	success = vec_make_room(vec, 1);
 
 	if(success == VEC_OK)
@@ -247,9 +268,11 @@ int vec_insert(vector_t *vec, void *value, vec_idx_t *idx)
 		}
 		vec->next_idx = i;
 		vec->num_free--;
+
+		pthread_cond_signal(&vec->cond_ins_mod);
 	}
 
-	unlockResource(&(vec->lock));
+	pthread_mutex_unlock(&vec->lock);
 
 	return success;
 }
@@ -257,7 +280,7 @@ int vec_insert(vector_t *vec, void *value, vec_idx_t *idx)
 void vec_lock(vector_t *vec)
 {
 	CHKVOID(vec);
-	lockResource(&(vec->lock));
+	pthread_mutex_lock(&vec->lock);
 }
 
 
@@ -346,10 +369,11 @@ void vec_release(vector_t *vec, int destroy)
        vec->data = NULL;
     }
 
+    pthread_cond_destroy(&vec->cond_ins_mod);
+    pthread_mutex_destroy(&vec->lock);
 
 	if(destroy)
 	{
-		killResourceLock(&(vec->lock));
 		SRELEASE(vec);
 	}
 }
@@ -397,7 +421,7 @@ void* vec_set(vector_t *vec, vec_idx_t idx, void *data, int *success)
 {
 	void *result = NULL;
 
-	lockResource(&(vec->lock));
+	pthread_mutex_lock(&vec->lock);
 
 
 	if( (vec == NULL) ||
@@ -405,7 +429,7 @@ void* vec_set(vector_t *vec, vec_idx_t idx, void *data, int *success)
 	  )
 	{
 		*success = VEC_FAIL;
-		unlockResource(&(vec->lock));
+		pthread_mutex_unlock(&vec->lock);
 		return NULL;
 	}
 
@@ -423,7 +447,7 @@ void* vec_set(vector_t *vec, vec_idx_t idx, void *data, int *success)
     }
     
 	vec->data[idx].value = data;
-	unlockResource(&(vec->lock));
+	pthread_mutex_unlock(&vec->lock);
 
 	return result;
 }
@@ -436,7 +460,7 @@ vec_idx_t   vec_size(vector_t *vec)
 void vec_unlock(vector_t *vec)
 {
 	CHKVOID(vec);
-	unlockResource(&(vec->lock));
+	pthread_mutex_unlock(&vec->lock);
 }
 
 
@@ -593,16 +617,16 @@ int   vec_str_init(vector_t *vec, uint8_t num)
 
 
 
-int vec_uvast_add(vector_t *vec, uvast value, vec_idx_t *idx)
+int vec_uvast_add(vector_t *vec, amp_uvast value, vec_idx_t *idx)
 {
 	int success = VEC_OK;
 	vecit_t it;
-	uvast *new_entry;
+	amp_uvast *new_entry;
 
 	/* First, make sure we don't already have an entry. */
 	for(it = vecit_first(vec); vecit_valid(it); it = vecit_next(it))
 	{
-		new_entry = (uvast *) vecit_data(it);
+		new_entry = (amp_uvast *) vecit_data(it);
 		if(*new_entry == value)
 		{
 			*idx = vecit_idx(it);
@@ -610,7 +634,7 @@ int vec_uvast_add(vector_t *vec, uvast value, vec_idx_t *idx)
 		}
 	}
 
-	if((new_entry = STAKE(sizeof(uvast))) == NULL)
+	if((new_entry = STAKE(sizeof(amp_uvast))) == NULL)
 	{
 		return VEC_SYSERR;
 	}
@@ -638,8 +662,8 @@ int vec_uvast_init(vector_t *vec, uint8_t num)
 
 int vec_uvast_comp(void *i1, void *i2)
 {
-	uvast *v1 = (uvast *) i1;
-	uvast *v2 = (uvast *) i2;
+	amp_uvast *v1 = (amp_uvast *) i1;
+	amp_uvast *v2 = (amp_uvast *) i2;
 
 	CHKERR(v1);
 	CHKERR(v2);
@@ -652,16 +676,16 @@ void* vec_uvast_copy(void* item)
 	void *new_item = NULL;
 	CHKNULL(item);
 
-	if((new_item = STAKE(sizeof(uvast))) == NULL)
+	if((new_item = STAKE(sizeof(amp_uvast))) == NULL)
 	{
 		return NULL;
 	}
-	memcpy(new_item, item, sizeof(uvast));
+	memcpy(new_item, item, sizeof(amp_uvast));
 	return new_item;
 }
 
 
-int vec_uvast_find_idx(vector_t *vec, uvast value, vec_idx_t *idx)
+int vec_uvast_find_idx(vector_t *vec, amp_uvast value, vec_idx_t *idx)
 {
 	vecit_t it;
 
@@ -672,7 +696,7 @@ int vec_uvast_find_idx(vector_t *vec, uvast value, vec_idx_t *idx)
 
 	for(it = vecit_first(vec); vecit_valid(it); it=vecit_next(it))
 	{
-		uvast *data = (uvast *) vecit_data(it);
+		amp_uvast *data = (amp_uvast *) vecit_data(it);
 		if(data != NULL)
 		{
 			if(*data == value)
diff --git a/nm/shared/utils/vector.h b/nm/shared/utils/vector.h
index f8e39f3f..a1e73d89 100644
--- a/nm/shared/utils/vector.h
+++ b/nm/shared/utils/vector.h
@@ -1,8 +1,20 @@
-/******************************************************************************
- **                           COPYRIGHT NOTICE
- **      (c) 2018 The Johns Hopkins University Applied Physics Laboratory
- **                         All rights reserved.
- ******************************************************************************/
+/*
+ * Copyright (c) 2018-2023 The Johns Hopkins University Applied Physics
+ * Laboratory LLC.
+ *
+ * This file is part of the Delay-Tolerant Networking Management
+ * Architecture (DTNMA) Tools package.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 /*
  * vector.h
@@ -14,9 +26,16 @@
 #ifndef NM_SHARED_PRIMITIVES_VECTOR_H_
 #define NM_SHARED_PRIMITIVES_VECTOR_H_
 
-#include "platform.h"
+#include <pthread.h>
+#include "shared/platform.h"
 #include "../primitives/blob.h"
 
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 #define VEC_MAX_IDX 100
 #define VEC_HALF_IDX 50
 #define VEC_DEFAULT_NUM 4
@@ -52,7 +71,10 @@ typedef struct
 	vec_idx_t num_free;     // Number of free elements in the vector.
 	vec_idx_t total_slots;  // Slots allocated
 
-	ResourceLock lock;
+	/// Mutex handle
+	pthread_mutex_t lock;
+	/// Condition when a value is inserted or updated
+	pthread_cond_t cond_ins_mod;
 
 	vec_comp_fn compare_fn;
 	vec_del_fn  delete_fn;
@@ -127,13 +149,16 @@ int   vec_str_comp(void *i1, void *i2);
 void* vec_str_copy(void* item);
 int   vec_str_init(vector_t *vec, uint8_t num);
 
-int   vec_uvast_add(vector_t *vec, uvast value, vec_idx_t *idx);
+int   vec_uvast_add(vector_t *vec, amp_uvast value, vec_idx_t *idx);
 int   vec_uvast_init(vector_t *vec, uint8_t num);
 int   vec_uvast_comp(void *i1, void *i2);
 void* vec_uvast_copy(void* item);
-int vec_uvast_find_idx(vector_t *vec, uvast value, vec_idx_t *idx);
+int vec_uvast_find_idx(vector_t *vec, amp_uvast value, vec_idx_t *idx);
 
 
 
+#ifdef __cplusplus
+}
+#endif
 
-#endif /* NM_SHARED_PRIMITIVES_VECTOR_H_ */
+#endif  /* _VECTOR_H_ */
diff --git a/nm/test/BP_AGENT.TXT b/nm/test/BP_AGENT.TXT
index 1a81baaf..e9d7f0c7 100644
--- a/nm/test/BP_AGENT.TXT
+++ b/nm/test/BP_AGENT.TXT
@@ -1,5 +1,8 @@
-# BP AGENT ADM TEst Cases
+# BP AGENT ADM Test Cases
 #
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
+
 ###############################################################################
 # TC 1 Exercise BP Reporting
 ###############################################################################
@@ -7,7 +10,12 @@
 #------------------------------------------------------------------------------
 # Step 1.1: Generate the BP Full Report.
 #------------------------------------------------------------------------------
-c11541054f840542252347814587182d41004180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/Rptt.full_report()],[])
+#
+#------------------------------------------------------------------------------
+c1154105050225238127456167656e744449414e4100
+WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 1.2: Verify report correctly received.
@@ -16,7 +24,13 @@ c11541054f840542252347814587182d41004180
 #------------------------------------------------------------------------------
 # Step 1.3: Request an endpoint report for ipn:1.1
 #------------------------------------------------------------------------------
-c1154105581d8405422523558153c7182d41014d83054112486769706e3a312e314180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.1)],[])
+#
+#------------------------------------------------------------------------------
+c11541050502252381c7182d41010501126769706e3a312e3100
+WAIT 5
+
 
 #------------------------------------------------------------------------------
 # Step 1.4: Verify a single endpoint report received.
@@ -25,7 +39,14 @@ c1154105581d8405422523558153c7182d41014d83054112486769706e3a312e314180
 #------------------------------------------------------------------------------
 # Step 1.5: Request an endpoint report for endpoints ipn:1.0, ipn:1.1, ipn:1.2
 #------------------------------------------------------------------------------
-c115410558468405422523583d8353c7182d41014d83054112486769706e3a312e3053c7182d41014d83054112486769706e3a312e3153c7182d41014d83054112486769706e3a312e324180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.0), 
+#          ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.1), 
+#          ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.2)], [])
+#
+#------------------------------------------------------------------------------
+c11541050502252383c7182d41010501126769706e3a312e30c7182d41010501126769706e3a312e31c7182d41010501126769706e3a312e3200
+WAIT 5
 
 #------------------------------------------------------------------------------
 # Step 1.6: Verify 3 endpoint reports received.
@@ -34,19 +55,33 @@ c115410558468405422523583d8353c7182d41014d83054112486769706e3a312e3053c7182d4101
 #------------------------------------------------------------------------------
 # Step 1.7: Generate the BP Full Report.
 #------------------------------------------------------------------------------
-c11541054f840542252347814587182d41004180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/Rptt.full_report()],[])
+#
+#------------------------------------------------------------------------------
+c1154105050225238127456167656e744449414e4100
+WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 1.8: Reset BP agent counts.
 #------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:dtn.bp_agent/Ctrl.reset_all_counts()
+#
+#------------------------------------------------------------------------------
 8118294100
+WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 1.9: Generate the BP Full Report.
 #------------------------------------------------------------------------------
-c11541054f840542252347814587182d41004180
-
-#------------------------------------------------------------------------------
-# Step 1.10: Verify counts have reduced single step 1.7.
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/Rptt.full_report()],[])
+#
 #------------------------------------------------------------------------------
+c1154105050225238127456167656e744449414e4100
+WAIT 1
 
+#------------------------------------------------------------------------------
+# Step 1.10: Verify counts have reduced as a result of step 1.8.
+#------------------------------------------------------------------------------
\ No newline at end of file
diff --git a/nm/test/amp_agent_suite.txt b/nm/test/amp_agent_suite.txt
index 0f73f9a8..d435784b 100644
--- a/nm/test/amp_agent_suite.txt
+++ b/nm/test/amp_agent_suite.txt
@@ -1,14 +1,21 @@
-# Standard Reports.
+# Test Set: Standard Reports.
 #
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
+# Assume ipn:1.0 is available
 
 ###################################################
 # Test Case 1 Generate Reports.
 ###################################################
- 
+
 #------------------------------------------------------------------------------
 # Step 1.1: Generate Agent ADM Full Report.
 #------------------------------------------------------------------------------
-c11541054f840542252347814587181941004180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])
+#
+#------------------------------------------------------------------------------
+c11541050502252381871819410000
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -16,9 +23,13 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 1.3 Generate BP Report
+# Step 1.3 Generate the BP Full Report.
 #------------------------------------------------------------------------------
-c11541054f840542252347814587182d41004180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:bp.agent/Rptt.full_report()],[])
+#
+#------------------------------------------------------------------------------
+c1154105050225238127456167656e744449414e4100
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -28,7 +39,13 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.5: Generate ADM Report and BP Report Concurrently.
 #------------------------------------------------------------------------------
-c11541055584054225234d824587181941004587182d41004180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#         [ari:/IANA:amp.agent/Rptt.full_report(), 
+#          ari:/IANA:bp.agent/Rptt.full_report()],[])
+#
+#------------------------------------------------------------------------------
+c11541050502252382871819410027456167656e744449414e4100
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -40,11 +57,15 @@ WAIT 1
 ###################################################
 
 #------------------------------------------------------------------------------
-# Step 2.1: Generate Endpoint report for endpoint 
+# Step 2.1: Generate Endpoint report for endpoint ipn:1.1
 #------------------------------------------------------------------------------
-# For ipn:1.1
-c1154105581d8405422523558153c7182d41014d83054112486769706e3a312e314180
-WAIT 1
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#       [ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.1)],[])
+#
+#------------------------------------------------------------------------------
+c11541050502252381c7182d41010501126769706e3a312e3100
+WAIT 5
 
 
 #------------------------------------------------------------------------------
@@ -52,12 +73,27 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 2.3 Generate Endpoint report for endpoints
+# Step 2.3 Generate Endpoint report for 3 endpoints:
+#              ipn:1.0, 
+#              ipn:1.1, 
+#              ipn:1.2
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#         [ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.0), 
+#          ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.1), 
+#          ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.2)], [])
+#
 #------------------------------------------------------------------------------
-# For  "ipn:1.0", "ipn:1.1", and "ipn:1.2"
+c11541050502252383c7182d41010501126769706e3a312e30c7182d41010501126769706e3a312e31c7182d41010501126769706e3a312e3200
+WAIT 5
+
+#------------------------------------------------------------------------------
+# Step 2.4: Verify endpoint reports received for the three endpoints:
+#           ipn:1.0
+#           ipn:1.1
+#           ipn:1.2
 #------------------------------------------------------------------------------
-c115410558468405422523583d8353c7182d41014d83054112486769706e3a312e3053c7182d41014d83054112486769706e3a312e3153c7182d41014d83054112486769706e3a312e324180
-WAIT 1
 
 
 ###################################################
@@ -66,9 +102,13 @@ WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 3.1: Generate Report that has specified EDD in it.
-# EDD selected is NUM_TBL_TPLS 
+#           EDD selected is NUM_TBL_TPLS defined by the AMP Agent ADM
 #------------------------------------------------------------------------------
-c11541054e8405422523468144821641014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Edd.num_tbl_tpls],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523818216410100
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -77,9 +117,13 @@ WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 3.3: Generate Report that has specified VAR in it.
-# VAR selected is NUM_RULES
+#           VAR selected is NUM_RULES defined by the AMP Agent ADM
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Var.num_rules],[])
+#
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c181d41004180
+c115410505022523818c181d410000
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -88,11 +132,16 @@ WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 3.5 Generate two report at once: with EDD and VAR in it.
+#          EDD selected is NUM_TBL_TPLS defined by the AMP Agent ADM
+#          VAR selected is NUM_RULES defined by the AMP Agent ADM
 #------------------------------------------------------------------------------
-# EDD selected is NUM_TBL_TPLS
-# VAR selected is NUM_RULES
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#         [ari:/IANA:amp.agent/Edd.num_tbl_tpls, 
+#          ari:/IANA:amp.agent/Var.num_rules], [])
+#
 #------------------------------------------------------------------------------
-c11541055484054225234c824482164101458c181d41004180
+c11541050502252382821641018c181d410000
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -105,17 +154,37 @@ WAIT 1
 ###################################################
 
 #------------------------------------------------------------------------------
-# Step 4.1: Add a report template (R1)
-#             NN: 1 ISS: 1 Name: 1.
-#             (0xa701410101)
+# Step 4.1: Add a report template (R1) that provides the number of table 
+#           templates (num_tbl_tpls) and number of report templates 
+#           (num_rpt_tpls) known to the Agent.
+#
 #------------------------------------------------------------------------------
-c11541025818840542242545a7014101014c824482164101458c181d4100
+#
+# Type: Report Template (rptt)
+# Nickname (NN): 1
+# Issuer (ISS): 1 
+# Name: R1
+# RPTT ARI: ari:/1:1/Rptt.R1
+# CBOR RPTT ARI: 0x3742523141314131
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_rptt(ari:/1:1/Rptt.R1, 
+#        [ari:/IANA:amp.agent/Edd.num_tbl_tpls, 
+#         ari:/IANA:amp.agent/Edd.num_rpt_tpls])
+#
+#------------------------------------------------------------------------------
+c1154102050224253742523141314131828216410182164100
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 4.2: Describe Report
+# Step 4.2: Describe the Report Template (rptt) R1
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_rptt([ari:/1:1/Rptt.R1])
+#
 #------------------------------------------------------------------------------
-c11541044c83054125478145a701410101
+c1154104050125813742523141314131
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -123,15 +192,23 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 4.4: Dump RPTT table.
+# Step 4.4: Generate a table of all known report templates.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts], [])
+#
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41024180
+c115410605022523818a181b410200
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 4.5: Request Report R1
+# Step 4.5: Request Report R1.
 #------------------------------------------------------------------------------
-c11541054f8405422523478145a7014101014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/1:1/Rptt.R1], [])
+#
+#------------------------------------------------------------------------------
+c11541050502252381374252314131413100
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -139,21 +216,35 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 4.7: Dump RPTT table and make sure R1 still exists.
+# Step 4.7: Generate a table of all known report templates and make sure 
+#           R1 still exists.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts], [])
+#
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41024180
+c115410605022523818a181b410200
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 4.8: Delete R1
 #------------------------------------------------------------------------------
-c11541034c83054125478145a701410101
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_rptt([ari:/1:1/Rptt.R1])
+#
+#------------------------------------------------------------------------------
+c1154103050125813742523141314131
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 4.9: Dump RPTT table and make sure R1 is gone.
+# Step 4.9: Generate a table of all known report templates and make sure 
+#            R1 has been deleted (is not represented in the table).
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41024180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts], [])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410200
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -161,15 +252,15 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 4.11: Dump RPTT table and make sure R1 is gone.
+# Step 4.11: Generate a table of all known report templates and make sure 
+#            R1 is not represented in the table.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41024180
-WAIT 1
-
-#------------------------------------------------------------------------------
-# Step 4.12: Reboot Mgr and make sure R1 does not come back.
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts], [])
+#
 #------------------------------------------------------------------------------
-
+c115410605022523818a181b410200
+WAIT 1
 
 ###################################################
 # Test Case 5: Describe Report
@@ -178,14 +269,19 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 5.1: Describe the AMP Agent FUll report.
 #------------------------------------------------------------------------------
-c11541044c830541254781458718194100
+#
+# ari:/IANA:amp.agent/Ctrl.desc_rptt(ari:/IANA:amp.agent/Rptt.full_report())
+#
+#------------------------------------------------------------------------------
+c1154104050125818718194100
 WAIT 1
 
 
 
-
 # Test Set 2: Variables
 #
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
 
 ###############################################################################
 # TC 1 Test Basic Variable Operations
@@ -197,24 +293,54 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.1: Define UINT V1 as "2 + 2"
 #------------------------------------------------------------------------------
-# Note: V1 ARI will be 0x8c18644101 
+# 
+# ARI: ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v1, (UINT) 2 2 +, UINT)
+#
 #------------------------------------------------------------------------------
-c11541005820850543242611458c186441015150148342430242430247c51818410141804114
+# 
+# V1 ARI: ari://var.v1
+# V1 encoding: 0x0c427631
+#
+# CBOR breakout:
+#
+# CONTROL  TNVC    PARM TYPES       PARM1    PARM2                     PARM3
+#          TYPE
+# add_var   TV    (ARI,EXPR,BYTE)   (V1)     (UINT) 2, 2, +            UINT
+# c1154100  05     03 24 26 11     0c427631 148343024302c51818410100   14
+#------------------------------------------------------------------------------
+c115410005032426110c427631148343024302c5181841010014
 WAIT 1
 
+
+
 #------------------------------------------------------------------------------
 # Step 1.2: List VARs on the agent and confirm that V1 is listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41014180
+#
+# V1 ARI: ari://var.v1
+# V1 encoding: 0x0c427631
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410100
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.3: Generate a report for V1 and confirm it has value UINT 4
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c186441014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763100
 WAIT 1
 
 
+
 #------------------------------------------------------------------------------
 # Step 1.4: Restart the Agent. 
 #------------------------------------------------------------------------------
@@ -223,35 +349,60 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.5: List VARs on the agent and confirm that V1 is still listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410100
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.6: Generate a report for V1 and confirm it still has value UINT 4
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c186441014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763100
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.7 Delete V1
 #------------------------------------------------------------------------------
-c11541014c830541254781458c18644101
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_var([ari://var.v1])
+#
+#------------------------------------------------------------------------------
+c1154101050125810c427631
 WAIT 1
 
 
 #------------------------------------------------------------------------------
 # Step 1.8: List VARs on the agent and confirm that V1 is NOT listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410100
 WAIT 1
 
+
+
 #------------------------------------------------------------------------------
 # Step 1.9: Generate a report for V1 and confirm it is not reported.
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c186441014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763100
 WAIT 1
 
 
+
 #------------------------------------------------------------------------------
 # Step 1.10: Restart the Agent. 
 #------------------------------------------------------------------------------
@@ -260,18 +411,28 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.11: List VARs on the agent and confirm that V1 is NOT listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410100
 WAIT 1
 
 
+
 #------------------------------------------------------------------------------
 # Step 1.12: Generate a report for V1 and confirm it is not reported.
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c186441014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763100
 WAIT 1
 
 
 
+
 ###############################################################################
 # Test Case 2.2: Complex Variables
 ###############################################################################
@@ -281,110 +442,244 @@ WAIT 1
 # V2 = V4;             // Test that V2 = 5.
 # V4 = eval(V3);       // Test that V4 = 6.
 #
-# V2 ARI = 0xac01410201
-# V3 ARI = 0xac01410301
-# V4 ARI = 0xac01410401
+# V2 ARI = 0x0c427632             
+# V3 ARI = 0x0c427633
+# V4 ARI = 0x0c427634
 ###############################################################################
 
 #------------------------------------------------------------------------------
 # Step 2.2.1: Define UINT V2 as "4"
 #------------------------------------------------------------------------------
-c11541005585054324261145ac01410201464514814243044114
+#
+# ARI: ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v2, (UINT) 4, UINT)
+#
+#------------------------------------------------------------------------------
+c115410005032426110c4276321481430414
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.2: Define EXPR V3 as "V2 + 1"
 #------------------------------------------------------------------------------
-# EXPR = [UINT, [V3, 1, plusUINT]]
+#
+# ARI: ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v3, (UINT) ari://var.v2 1 +, EXPR)
+#
+#------------------------------------------------------------------------------
+#
+# CBOR breakout:
+#
+# CONTROL  TNVC    PARM TYPES       PARM1    PARM2                        PARM3
+#          TYPE
+# add_var   TV    (ARI,EXPR,BYTE)   (V3)     (UINT) v2, 1, +              EXPR
+# c1154100  05     03 24 26 11    0c427633  14830c4276324301c51818410100   26
 #------------------------------------------------------------------------------
-c1154100582385054324261145ac014103015453148345ac0141020142430147c51818410141804126
+c115410005032426110c42763314830c4276324301c5181841010026
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.3: Define UINT V4 as having an initializing expression of {V3}
 #------------------------------------------------------------------------------
-c1154100581885054324261145ac014104014948148145ac014103014114
+#
+# ARI:  ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v4, UINT ari://var.v3, UINT)
+#
+#------------------------------------------------------------------------------
+c115410005032426110c42763414810c42763314
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 2.2.4: Define custom report R1 = {V2, V3, V4}
 #------------------------------------------------------------------------------
-# R1 ARI = 0xa701410501
+#
+# R1 ARI = 0x07427231
+#
+# ARI: ari:/IANA:Amp.Agent/Ctrl.add_rptt(ari://rptt.r1, [ari://var.v2, ari://var.v3, ari://var.v4])
+#
 #------------------------------------------------------------------------------
-c1154102581f840542242545a701410501538345ac0141020145ac0141030145ac01410401
+c11541020502242507427231830c4276320c4276330c427634
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.5: Generate Report R1 and verify values are {4,EXPR,5}
 #------------------------------------------------------------------------------
-c11541054f8405422523478145a7014105014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://rptt.r1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810742723100
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.6: STORE(V2, V4)  - V2 = V4
 #------------------------------------------------------------------------------
-c115410e55840542242645ac014102014948148145ac01410401
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v2, (UINT) ari://var.v4)
+#
+#------------------------------------------------------------------------------
+c115410e050224260c42763214810c427634
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.7: STORE(V4, V3) - V4 = expr_eval(V3)
 #------------------------------------------------------------------------------
-c115410e55840542242645ac014104014948148145ac01410301
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v4, ari://var.v3)
+#
+#------------------------------------------------------------------------------
+c115410e050224260c42763414810c427633
 WAIT 1
 
 
 #------------------------------------------------------------------------------
 # Step 2.2.8: Generate Report R1 and verify values are {5,EXPR,6}
 #------------------------------------------------------------------------------
-c11541054f8405422523478145a7014105014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://rptt.r1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810742723100
 WAIT 1
 
 
+# Test Set: Macros
+#
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
 
-# Create a Macro that dumps an AMP full report. Clears the AMP report. Produces new Report.
-# Type: Macro. NN=1, ISS=1, Name=1
-# 0xa401410101
+###############################################################################
+# Test Case 1 Test Basic Macro Operations
+###############################################################################
+# Generate basic macros in the AMP.
 #
-c1154107584285054312242543624d3145a40141010158308354c11541054f840542252347814587181941004180448115410f54c11541054f840542252347814587181941004180
+###############################################################################
+
+#------------------------------------------------------------------------------
+# Step 1.1: Create a Macro that 
+#   1) Generates a BP Agent Full Report
+#   2) Issues a reset all counts command to reset the counters in the BP Agent
+#      full report
+#   3) Generates a new BP Agent Full Report
+#
+#------------------------------------------------------------------------------
+#
+# Type: Macro (mac)
+# Nickname (NN): 1
+# Issuer (ISS): 1 
+# Name: test_full_rpt
+# Macro ARI: ari:/1:1/Mac.test_full_rpt
+# CBOR Macro ARI: 0x344d746573745f66756c6c5f72707441314131
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_macro("test_full_rpt", ari:/1:1/Mac.test_full_rpt,
+#       [ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/Rptt.full_report()], []),
+#        ari:/IANA:dtn.bp_agent/Ctrl.reset_all_counts(),
+#        ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/Rptt.full_report()], [])])
+#
+#------------------------------------------------------------------------------
+c115410705031224256d746573745f66756c6c5f727074344d746573745f66756c6c5f7270744131413183c1154105050225238187182d4100008118294100c1154105050225238187182d410000
 WAIT 1
 
-#Describe Macro
-c11541094c83054125478145a401410101
+#------------------------------------------------------------------------------
+# Step 1.2: Describe Macro test_full_rpt.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_macro([ari:/1:1/Mac.test_full_rpt])
+#
+#------------------------------------------------------------------------------
+c115410905012581344d746573745f66756c6c5f72707441314131
 WAIT 1
 
-# Reboot manager and see if macro reloads.
+#------------------------------------------------------------------------------
+# Step 1.3: Reboot manager and see if macro is restored.
+#------------------------------------------------------------------------------
+
 
-# Request table of known macros.
+#------------------------------------------------------------------------------
+# Step 1.4: Request table of known macros.
+#------------------------------------------------------------------------------
 #
-c11541064f84054225234781458a181b41034180
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
 WAIT 1
 
-# Reboot agent and see if macro comes back.
+#------------------------------------------------------------------------------
+# Step 1.5: Reboot manager and see if macro is restored.
+#------------------------------------------------------------------------------
+
+#------------------------------------------------------------------------------
+# Step 1.6: Request table of known macros. Make sure the macro is still present.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
+WAIT 1
 
-# Request table of known macros. Make sure it is still there.
-c11541064f84054225234781458a181b41034180
+
+#------------------------------------------------------------------------------
+# Step 1.7: Delete macro test_full_rptt.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_macro([ari:/1:1/Mac.test_full_rpt])
+#
+#------------------------------------------------------------------------------
+c115410805012581344d746573745f66756c6c5f72707441314131
+WAIT 1
+
+#------------------------------------------------------------------------------
+# Step 1.8: Request table of known macros. Make sure the macro is no longer 
+#           listed.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
 WAIT 1
 
-# Delete Macro
-c11541084c83054125478145a401410101
+
+#------------------------------------------------------------------------------
+# Step 1.9: Reboot agent and make sure macro doesn't come back.
+#------------------------------------------------------------------------------
+
+
+#------------------------------------------------------------------------------
+# Step 1.10: Request table of known macros. Make sure the macro is no longer 
+#           listed.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
 WAIT 1
 
-# Request table of known macros and make sure macro is no longer listed.
 
-# Reboot agent and make sure macro doesn't come back.
 
-# Request table of known macros. Make sure it is no longer there.
-c11541064f84054225234781458a181b41034180
 
 
 
 
 
-# Test Set 3: Time-Based Rule Production.
+
+
+
+
+
+# Test Set 4: Time-Based Rule Production.
 #
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
 
 ###############################################################################
-# TC 3.1 Generate Reports to a schedule.
+# TC 4.1 Generate Reports to a schedule.
 ###############################################################################
 # This test will cause an AGENT FULL report to be generated
 # 5 times at intervals of 5 seconds each.
@@ -393,20 +688,26 @@ c11541064f84054225234781458a181b41034180
 
 
 #------------------------------------------------------------------------------
-# Step 3.1.1: Build the TBR to report on the AGENT Full Report.
-# NN: 1, ISS: 1, Name: 1
+# Step 4.1.1: Build the TBR to report on the AGENT Full Report.
 #------------------------------------------------------------------------------
-# NOTE: The TRL will have an ID of: 0xab01410101
+#
+# NOTE: The TBR will be identified as "ari://Tbr.1" which is 0x0b4131
 # START: 0
 # PERIOD: 5
 # COUNT: 5
 # Action: {GEN_RPT({FULL_REPORT}, 0)}
+# Description: TBR1
+#
 #------------------------------------------------------------------------------
-c115410a583588054624161616251245ab01410101410041054105568154c11541054f840542252347814587181941004180486747656e52707473
+#
+# ARI: ari:/IANA:AMP.AGENT/CTRL.ADD_TBR(ari://Tbr.1, 0, 5, 5, [ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])], TBR1)
+#
+#------------------------------------------------------------------------------
+c115410a05062420201625120b413100050581c11541050502252381871819410000682018544252312019
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 3.1.2: Verify that 5 reports are received approximately 
+# Step 4.1.2: Verify that 5 reports are received approximately 
 # 5 seconds apart (variance up to 1 second between individual reports
 # are within tolerance due to the 1Hz rate of the agent autonomy
 # engine. 
@@ -416,94 +717,160 @@ WAIT 30
  
 
 ###############################################################################
-# TC 3.2: Manipulate TBRs.
+# TC 4.2: Manipulate TBRs.
 ###############################################################################
 # Interrupt a running TBR
 ###############################################################################
 
 #------------------------------------------------------------------------------
-# Step 3.2.1: Define a TRL that will generate an AGENT FULL REPORT every 30
-# seconds 100 times.
+# Step 4.2.1: Define a TBR  (TBR 2) that will generate an AGENT FULL REPORT 
+# every 30 seconds 100 times.
 #------------------------------------------------------------------------------
-# TBR 2 will have an Id of: 0xab01410201
+#
+# NOTE: The TBR will be identified as "ari://Tbr.2" which is 0x0b4132
+# START: 0
+# PERIOD: 30
+# COUNT: 100
+# Action: {GEN_RPT({FULL_REPORT}, 0)}
+# Description: TBR2
+#
 #------------------------------------------------------------------------------
-c115410a583488054624161616251245ab01410201410042181e421864568154c11541054f840542252347814587181941004180456454425232
+#
+# ARI: ari:/IANA:AMP.AGENT/CTRL.ADD_TBR(ari://Tbr.2, 0, 30, 100, 
+#         [ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])], TBR2)
+#
+#------------------------------------------------------------------------------
+c115410a05062420201625120b413200181e186481c11541050502252381871819410000682018544252322019
 WAIT 1
 
 
 #------------------------------------------------------------------------------
-# Step 3.2.2: List TBRs on the agent. 
+# Step 4.2.2: List TBRs on the agent. 
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41044180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410400
 WAIT 1
 
 
 #------------------------------------------------------------------------------
-# Step 3.2.3: Verify TBR 2 is listed in the report.
+# Step 4.2.3: Verify TBR 2 is listed in the reported rules.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 3.2.4: Describe TBR 2.
+# Step 4.2.4: Describe TBR 2.
 #------------------------------------------------------------------------------
-c115410d4c83054125478145ab01410201
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_rule([ari://Tbr.2])
+#
+#------------------------------------------------------------------------------
+c115410d050125810b4132
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 3.2.5: Verify the description matches the definition.
+# Step 4.2.5: Verify the description matches the definition.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 3.2.6: Delete the TRL.
+# Step 4.2.6: Delete TBR 2.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_rule([ari://TBR.2])
+#
 #------------------------------------------------------------------------------
-c115410c4c83054125478145ab01410201
+c115410c050125810b4132
 WAIT 1
 
 
 #------------------------------------------------------------------------------
-# Step 3.2.7: Verify no reports received after TRL deleted.
+# Step 4.2.7: Verify no reports received after TRL deleted.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 3.2.8: List TBRs on the agent.
+# Step 4.2.8: List TBRs on the agent.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])
+#
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41044180
+c115410605022523818a181b410400
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 3.2.9: Verify TBR2 not shown in list.
+# Step 4.2.9: Verify TBR2 not shown in list.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 3.2.10: Describe TBR 2 from the agent.
+# Step 4.2.10: Describe TBR 2 from the agent.
 #------------------------------------------------------------------------------
-c115410d4c83054125478145ab01410201
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_rule([ari://TBR.2])
+#
+#------------------------------------------------------------------------------
+c115410d050125810b4132
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 3.2.11: Verify TBR not there to be described.
+# Step 4.2.11: Verify TBR not there to be described.
 #------------------------------------------------------------------------------
 
-
 ###############################################################################
-# TC 3.3: Run parameterized macro by TBR
+# TC 4.3: Run macro by TBR
 ###############################################################################
 # 
 ###############################################################################
 
 #------------------------------------------------------------------------------
-# Step 3.3.1: Define TBR T7 to run Agent Macro USER_DESC 1 time wither period 5.
+# Step 4.3.1: Create a Macro that generates a BP full report.
+#
+# Type: Macro (mac)
+# Name: bp_full_rpt_macro
+# Macro ARI: ari://Mac.bp_full_rpt_macro
+# CBOR Macro ARI: 0x045162705f66756c6c5f7270745f6d6163726f
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_macro("bp_full_rpt_macro", 
+#        ari://Mac.bp_full_rpt_macro, [ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#         [ari:/IANA:dtn.bp_agent/Rptt.full_report()], [])])
+#
+#------------------------------------------------------------------------------
+c11541070503122425732262705f66756c6c5f7270745f6d6163726f22045162705f66756c6c5f7270745f6d6163726f81c1154105050225238187182d410000
+WAIT 1
+
+
+#------------------------------------------------------------------------------
+# Step 4.3.2: Define TBR T7 to run Agent Macro bp_full_rpt_macro 1 time with 
+#             period 5.
+#------------------------------------------------------------------------------
+#
+# NOTE: The TBR will be identified as "ari://Tbr.7" which is 0x0b4137
+# START: 0
+# PERIOD: 5
+# COUNT: 1
+# Action: {bp_full_rpt_macro}
+# Description: TBR7
+#
 #------------------------------------------------------------------------------
-# T7 ARI: 0xab01410701
+#
+# ARI: ari:/IANA:AMP.AGENT/CTRL.ADD_TBR(ari://Tbr.7, 0, 5, 1, 
+#        [ari://Mac.bp_full_rpt_macro], TBR7)
+#
 #------------------------------------------------------------------------------
-c115410a583888054624161616251245ab01410701410041014101581d81581ac41741005584054225254781458718194100478145ab0141070143625437
+c115410a05062420201625120b413700050181045162705f66756c6c5f7270745f6d6163726f682018544252372019
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 3.3.2: Read the returned report and make sure parms were correct.
+# Step 4.3.2: Read the returned report and make sure parms were correct.
 #------------------------------------------------------------------------------
 
 
-# State-Based Rule Production.
+# Test Set 5: State-Based Rule Production.
+#
+# Assumes nm_mgr is on ipn:1.1
+# Assumes nm_agent is on ipn:1.2
 #
 
 ###############################################################################
@@ -517,17 +884,35 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.1: Define UINT V5 = 0.
 #------------------------------------------------------------------------------
-# V5 ARI = 0xac01410501
+#
+# V5 ARI = 0x0c427635
+# 
+# ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v5, (UINT) 0, UINT)
+#
+# 
+# CBOR breakout:
+#
+# CONTROL  TNVC    PARM TYPES       PARM1    PARM2         PARM3
+#          TYPE
+# add_var   TV    (ARI,EXPR,BYTE)   (V1)     (UINT) 0      UINT
+# c1154100  05     03 24 26 11     0c427635 14814300        14
+#
 #------------------------------------------------------------------------------
-c11541005585054324261145ac01410501464514814243004114
+c115410005032426110c4276351481430014
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.2: Retrieve value of V5 in a report.
 #------------------------------------------------------------------------------
-c11541054f8405422523478145ac014105014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v5],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763500
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.3: Confirm value of V5 is 0.
 #------------------------------------------------------------------------------
@@ -535,16 +920,25 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.4: Define Macro M1 generate an agent FULL_REPORT and reset V5 = 0
 #------------------------------------------------------------------------------
-# Macro = [genRpt([FULL_REPORT], 0), Store(V5, 0)]
-# M1 ARI = 0xa401410501
+#
+# Macro M1 ARI: 0x04424d31
+# 
+# ARI: ari:/IANA:amp.agent/Ctrl.add_macro("m1", ari://Mac.M1, 
+#      [ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[]),
+#       ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v5, (UINT)0)])
+#
 #------------------------------------------------------------------------------
-c115410758418505431224254463746d7045a401410501582e8254c11541054f84054225234781458718194100418057c115410e52840542242645ac0141050146451481424300
+c11541070503122425626d3104424d3182c11541050502252381871819410000c115410e050224260c42763514814300
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 1.5: List Macros 
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41034180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -554,7 +948,11 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.7: Describe Macro M1
 #------------------------------------------------------------------------------
-c11541094c83054125478145a401410501
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_macro([ari://Mac.M1])
+#
+#------------------------------------------------------------------------------
+c11541090501258104424d31
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -564,20 +962,31 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.9: Define SRL S1 to run every time V5 >= 2 up to 3 times. 
 #------------------------------------------------------------------------------
-# A1 ARI = 0xa801410101
+#
+# S1 ARI = 0x08425331
 # Start = 0
 # Expr = [V5, 2, >=]
 # MaxEval = 1000
 # Count = 3
 # Action = [M1]
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_sbr(ari://Sbr.S1, 0, 
+#       (UINT) ari://Var.v5 2 >=, 1000, 3, [ari://Mac.M1], "S1")
+#
 #------------------------------------------------------------------------------
-c115410b583a8905472416261616251245a80141010141005554148345ac0141050142430248c5181842182f4180431903e84103478145a40141050143625331
+c115410b050724162616162512084253310014830c4276354302c5181842182f001903e8038104424d31625331
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 1.10: List known rules
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41044180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410400
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -587,7 +996,11 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.12: Describe SRL1
 #------------------------------------------------------------------------------
-c115410d4c83054125478145a801410101
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_rule([ari://Sbr.S1])
+#
+#------------------------------------------------------------------------------
+c115410d0501258108425331
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -598,19 +1011,30 @@ WAIT 1
 # Step 1.14: Set TBR T1 to run every 20 seconds 6 times that will
 # run the command: V5 = V5 + 1 which is: STOR(V5, {(UINT), V5 1 +})
 #------------------------------------------------------------------------------
-# T5 ARI = 0xab01410501
-# T5 Start = 0
-# T5 Period = 20
-# T5 Count = 6
+#
+# T1 ARI = 0x0b425431 
+# T1 Start = 0
+# T1 Period = 20
+# T1 Count = 6
+# T1 Action: ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v5, (UINT) ari://var.v5 1 +)
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_tbr(ari://tbr.T1, 0, 20, 6, 
+#      [ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v5, (UINT) ari://var.v5 1 +)], "T1")
+#
 #------------------------------------------------------------------------------
-c115410a584488054624161616251245ab014105014100411441065829815826c115410e5820840542242645ac014105015453148345ac0141050142430147c518184101418043625435
+c115410a05062416161625120b42543100140681c115410e050224260c42763514830c4276354301c51818410100625431
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 1.15: Describe T1 and make sure it is correct.
 #------------------------------------------------------------------------------
-
-c115410d4c83054125478145ab01410501
+#
+# ARI ari:/IANA:amp.agent/Ctrl.desc_rule([ari://Tbr.T1])
+#
+#------------------------------------------------------------------------------
+c115410d050125810b425431
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -626,13 +1050,26 @@ WAIT 170
 #------------------------------------------------------------------------------
 # Step 1.18: List known rules and verify S1 and T1 are no longer listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41044180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410400
 WAIT 1
 
+
 #------------------------------------------------------------------------------
-# Step 1.19: Delete S1. i.e. show no issue with deleting a deleted SBR
+# Step 1.19: Delete S1. i.e. show no issue with deleting a deleted SBR.
+#            Expect to see the following in Agent output:
+#            "[nm/agent/adm_amp_agent_impl.c:1946] 
+#            w DEL_RULE Cannot find RULE to be deleted."
+#
 #------------------------------------------------------------------------------
-c115410c4c83054125478145a801410101
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_rule([ari://Sbr.S1])
+#
+#------------------------------------------------------------------------------
+c115410c0501258108425331
 WAIT 1
 
 
@@ -640,3 +1077,58 @@ WAIT 1
 # Step 1.20: Restart Agent and verify only 1 Var and 1 Macro restore.
 #------------------------------------------------------------------------------
 
+# Test Set 6: Standard Tables.
+#
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
+# Assume ipn:1.0 is available
+
+###################################################
+# Test Case 1 Generate Tables.
+###################################################
+
+#------------------------------------------------------------------------------
+# Step 1.1: Generate a table that lists all the adms that are supported by 
+#           the agent using the AMP Agent adm table template.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.adms()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410000
+WAIT 1
+
+#------------------------------------------------------------------------------
+# Step 1.2: Verify ADM table received and correct. Must include the AMP Agent ADM
+#------------------------------------------------------------------------------
+
+#------------------------------------------------------------------------------
+# Step 1.3: Generate a table that lists all the table templates that are defined  
+#           by the agent using the AMP Agent tblts table template.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.tblts()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410500
+WAIT 1
+
+#------------------------------------------------------------------------------
+# Step 1.4: Verify TBLT table received and correct. 
+#------------------------------------------------------------------------------
+
+#------------------------------------------------------------------------------
+# Step 1.5: Generate tables concurrently: variables and rules.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls(
+#         [ari:/IANA:amp.agent/Tblt.variables(), 
+#          ari:/IANA:amp.agent/Tblt.rules()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523828a181b41018a181b410400
+WAIT 1
+
+#------------------------------------------------------------------------------
+# Step 1.6: Verify both tables received and correct.
+#------------------------------------------------------------------------------
\ No newline at end of file
diff --git a/nm/test/macros.txt b/nm/test/macros.txt
index 52734709..4c982775 100644
--- a/nm/test/macros.txt
+++ b/nm/test/macros.txt
@@ -1,39 +1,116 @@
-# Create a Macro that dumps an AMP full report. Clears the AMP report. Produces new Report.
-# Type: Macro. NN=1, ISS=1, Name=1
-# 0xa401410101
+# Test Set 3: Macros
 #
-c1154107584285054312242543624d3145a40141010158308354c11541054f840542252347814587181941004180448115410f54c11541054f840542252347814587181941004180
-WAIT 1
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
 
-#Describe Macro
-c11541094c83054125478145a401410101
-WAIT 1
+###############################################################################
+# Test Case 1 Test Basic Macro Operations
+###############################################################################
+# Generate basic macros in the AMP.
+#
+###############################################################################
 
-# Reboot manager and see if macro reloads.
+#------------------------------------------------------------------------------
+# Step 1.1: Create a Macro that 
+#   1) Generates a BP Agent Full Report
+#   2) Issues a reset all counts command to reset the counters in the BP Agent
+#      full report
+#   3) Generates a new BP Agent Full Report
+#
+#------------------------------------------------------------------------------
+#
+# Type: Macro (mac)
+# Nickname (NN): 1
+# Issuer (ISS): 1 
+# Name: test_full_rpt
+# Macro ARI: ari:/1:1/Mac.test_full_rpt
+# CBOR Macro ARI: 0x344d746573745f66756c6c5f72707441314131
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_macro("test_full_rpt", ari:/1:1/Mac.test_full_rpt,
+#       [ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/Rptt.full_report()], []),
+#        ari:/IANA:dtn.bp_agent/Ctrl.reset_all_counts(),
+#        ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:dtn.bp_agent/Rptt.full_report()], [])])
+#
+#------------------------------------------------------------------------------
+c115410705031224256d746573745f66756c6c5f727074344d746573745f66756c6c5f7270744131413183c1154105050225238187182d4100008118294100c1154105050225238187182d410000
+WAIT 1
 
-# Request table of known macros.
+#------------------------------------------------------------------------------
+# Step 1.2: Describe Macro test_full_rpt.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_macro([ari:/1:1/Mac.test_full_rpt])
 #
-c11541064f84054225234781458a181b41034180
+#------------------------------------------------------------------------------
+c115410905012581344d746573745f66756c6c5f72707441314131
 WAIT 1
 
-# Reboot agent and see if macro comes back.
+#------------------------------------------------------------------------------
+# Step 1.3: Reboot manager and see if macro is restored.
+#------------------------------------------------------------------------------
 
-# Request table of known macros. Make sure it is still there.
-c11541064f84054225234781458a181b41034180
-WAIT 1
 
-# Delete Macro
-c11541084c83054125478145a401410101
+#------------------------------------------------------------------------------
+# Step 1.4: Request table of known macros.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
 WAIT 1
 
-# Request table of known macros and make sure macro is no longer listed.
+#------------------------------------------------------------------------------
+# Step 1.5: Reboot manager and see if macro is restored.
+#------------------------------------------------------------------------------
 
-# Reboot agent and make sure macro doesn't come back.
+#------------------------------------------------------------------------------
+# Step 1.6: Request table of known macros. Make sure the macro is still present.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
+WAIT 1
 
-# Request table of known macros. Make sure it is no longer there.
-c11541064f84054225234781458a181b41034180
 
+#------------------------------------------------------------------------------
+# Step 1.7: Delete macro test_full_rptt.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_macro([ari:/1:1/Mac.test_full_rpt])
+#
+#------------------------------------------------------------------------------
+c115410805012581344d746573745f66756c6c5f72707441314131
+WAIT 1
+
+#------------------------------------------------------------------------------
+# Step 1.8: Request table of known macros. Make sure the macro is no longer 
+#           listed.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
+WAIT 1
 
 
+#------------------------------------------------------------------------------
+# Step 1.9: Reboot agent and make sure macro doesn't come back.
+#------------------------------------------------------------------------------
 
 
+#------------------------------------------------------------------------------
+# Step 1.10: Request table of known macros. Make sure the macro is no longer 
+#           listed.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
+WAIT 1
\ No newline at end of file
diff --git a/nm/test/reports.txt b/nm/test/reports.txt
index e49492bf..a56f7aca 100644
--- a/nm/test/reports.txt
+++ b/nm/test/reports.txt
@@ -1,14 +1,21 @@
-# Standard Reports.
+# Test Set 1: Standard Reports.
 #
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
+# Assume ipn:1.0 is available
 
 ###################################################
 # Test Case 1 Generate Reports.
 ###################################################
- 
+
 #------------------------------------------------------------------------------
 # Step 1.1: Generate Agent ADM Full Report.
 #------------------------------------------------------------------------------
-c11541054f840542252347814587181941004180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])
+#
+#------------------------------------------------------------------------------
+c11541050502252381871819410000
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -16,9 +23,13 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 1.3 Generate BP Report
+# Step 1.3 Generate the BP Full Report.
 #------------------------------------------------------------------------------
-c11541054f840542252347814587182d41004180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:bp.agent/Rptt.full_report()],[])
+#
+#------------------------------------------------------------------------------
+c1154105050225238127456167656e744449414e4100
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -28,7 +39,13 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.5: Generate ADM Report and BP Report Concurrently.
 #------------------------------------------------------------------------------
-c11541055584054225234d824587181941004587182d41004180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#         [ari:/IANA:amp.agent/Rptt.full_report(), 
+#          ari:/IANA:bp.agent/Rptt.full_report()],[])
+#
+#------------------------------------------------------------------------------
+c11541050502252382871819410027456167656e744449414e4100
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -40,11 +57,15 @@ WAIT 1
 ###################################################
 
 #------------------------------------------------------------------------------
-# Step 2.1: Generate Endpoint report for endpoint 
+# Step 2.1: Generate Endpoint report for endpoint ipn:1.1
 #------------------------------------------------------------------------------
-# For ipn:1.1
-c1154105581d8405422523558153c7182d41014d83054112486769706e3a312e314180
-WAIT 1
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#       [ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.1)],[])
+#
+#------------------------------------------------------------------------------
+c11541050502252381c7182d41010501126769706e3a312e3100
+WAIT 5
 
 
 #------------------------------------------------------------------------------
@@ -52,12 +73,27 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 2.3 Generate Endpoint report for endpoints
+# Step 2.3 Generate Endpoint report for 3 endpoints:
+#              ipn:1.0, 
+#              ipn:1.1, 
+#              ipn:1.2
 #------------------------------------------------------------------------------
-# For  "ipn:1.0", "ipn:1.1", and "ipn:1.2"
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#         [ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.0), 
+#          ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.1), 
+#          ari:/IANA:dtn.bp_agent/Rptt.endpoint_report(ipn:1.2)], [])
+#
+#------------------------------------------------------------------------------
+c11541050502252383c7182d41010501126769706e3a312e30c7182d41010501126769706e3a312e31c7182d41010501126769706e3a312e3200
+WAIT 5
+
+#------------------------------------------------------------------------------
+# Step 2.4: Verify endpoint reports received for the three endpoints:
+#           ipn:1.0
+#           ipn:1.1
+#           ipn:1.2
 #------------------------------------------------------------------------------
-c115410558468405422523583d8353c7182d41014d83054112486769706e3a312e3053c7182d41014d83054112486769706e3a312e3153c7182d41014d83054112486769706e3a312e324180
-WAIT 1
 
 
 ###################################################
@@ -66,9 +102,13 @@ WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 3.1: Generate Report that has specified EDD in it.
-# EDD selected is NUM_TBL_TPLS 
+#           EDD selected is NUM_TBL_TPLS defined by the AMP Agent ADM
 #------------------------------------------------------------------------------
-c11541054e8405422523468144821641014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Edd.num_tbl_tpls],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523818216410100
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -77,9 +117,13 @@ WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 3.3: Generate Report that has specified VAR in it.
-# VAR selected is NUM_RULES
+#           VAR selected is NUM_RULES defined by the AMP Agent ADM
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Var.num_rules],[])
+#
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c181d41004180
+c115410505022523818c181d410000
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -88,11 +132,16 @@ WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 3.5 Generate two report at once: with EDD and VAR in it.
+#          EDD selected is NUM_TBL_TPLS defined by the AMP Agent ADM
+#          VAR selected is NUM_RULES defined by the AMP Agent ADM
 #------------------------------------------------------------------------------
-# EDD selected is NUM_TBL_TPLS
-# VAR selected is NUM_RULES
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#         [ari:/IANA:amp.agent/Edd.num_tbl_tpls, 
+#          ari:/IANA:amp.agent/Var.num_rules], [])
+#
 #------------------------------------------------------------------------------
-c11541055484054225234c824482164101458c181d41004180
+c11541050502252382821641018c181d410000
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -105,17 +154,37 @@ WAIT 1
 ###################################################
 
 #------------------------------------------------------------------------------
-# Step 4.1: Add a report template (R1)
-#             NN: 1 ISS: 1 Name: 1.
-#             (0xa701410101)
+# Step 4.1: Add a report template (R1) that provides the number of table 
+#           templates (num_tbl_tpls) and number of report templates 
+#           (num_rpt_tpls) known to the Agent.
+#
+#------------------------------------------------------------------------------
+#
+# Type: Report Template (rptt)
+# Nickname (NN): 1
+# Issuer (ISS): 1 
+# Name: R1
+# RPTT ARI: ari:/1:1/Rptt.R1
+# CBOR RPTT ARI: 0x3742523141314131
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_rptt(ari:/1:1/Rptt.R1, 
+#        [ari:/IANA:amp.agent/Edd.num_tbl_tpls, 
+#         ari:/IANA:amp.agent/Edd.num_rpt_tpls])
+#
 #------------------------------------------------------------------------------
-c11541025818840542242545a7014101014c824482164101458c181d4100
+c1154102050224253742523141314131828216410182164100
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 4.2: Describe Report
+# Step 4.2: Describe the Report Template (rptt) R1
 #------------------------------------------------------------------------------
-c11541044c83054125478145a701410101
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_rptt([ari:/1:1/Rptt.R1])
+#
+#------------------------------------------------------------------------------
+c1154104050125813742523141314131
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -123,15 +192,23 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 4.4: Dump RPTT table.
+# Step 4.4: Generate a table of all known report templates.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41024180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts], [])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410200
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 4.5: Request Report R1
+# Step 4.5: Request Report R1.
 #------------------------------------------------------------------------------
-c11541054f8405422523478145a7014101014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/1:1/Rptt.R1], [])
+#
+#------------------------------------------------------------------------------
+c11541050502252381374252314131413100
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -139,21 +216,35 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 4.7: Dump RPTT table and make sure R1 still exists.
+# Step 4.7: Generate a table of all known report templates and make sure 
+#           R1 still exists.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts], [])
+#
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41024180
+c115410605022523818a181b410200
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 4.8: Delete R1
 #------------------------------------------------------------------------------
-c11541034c83054125478145a701410101
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_rptt([ari:/1:1/Rptt.R1])
+#
+#------------------------------------------------------------------------------
+c1154103050125813742523141314131
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 4.9: Dump RPTT table and make sure R1 is gone.
+# Step 4.9: Generate a table of all known report templates and make sure 
+#            R1 has been deleted (is not represented in the table).
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts], [])
+#
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41024180
+c115410605022523818a181b410200
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -161,15 +252,15 @@ WAIT 1
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 4.11: Dump RPTT table and make sure R1 is gone.
-#------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41024180
-WAIT 1
-
+# Step 4.11: Generate a table of all known report templates and make sure 
+#            R1 is not represented in the table.
 #------------------------------------------------------------------------------
-# Step 4.12: Reboot Mgr and make sure R1 does not come back.
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rptts], [])
+#
 #------------------------------------------------------------------------------
-
+c115410605022523818a181b410200
+WAIT 1
 
 ###################################################
 # Test Case 5: Describe Report
@@ -178,9 +269,9 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 5.1: Describe the AMP Agent FUll report.
 #------------------------------------------------------------------------------
-c11541044c830541254781458718194100
-WAIT 1
-
-
-
-
+#
+# ari:/IANA:amp.agent/Ctrl.desc_rptt(ari:/IANA:amp.agent/Rptt.full_report())
+#
+#------------------------------------------------------------------------------
+c1154104050125818718194100
+WAIT 1
\ No newline at end of file
diff --git a/nm/test/sbr.txt b/nm/test/sbr.txt
index a8f960c2..698a9f79 100644
--- a/nm/test/sbr.txt
+++ b/nm/test/sbr.txt
@@ -1,4 +1,7 @@
-# State-Based Rule Production.
+# Test Set 5: State-Based Rule Production.
+#
+# Assumes nm_mgr is on ipn:1.1
+# Assumes nm_agent is on ipn:1.2
 #
 
 ###############################################################################
@@ -12,17 +15,35 @@
 #------------------------------------------------------------------------------
 # Step 1.1: Define UINT V5 = 0.
 #------------------------------------------------------------------------------
-# V5 ARI = 0xac01410501
+#
+# V5 ARI = 0x0c427635
+# 
+# ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v5, (UINT) 0, UINT)
+#
+# 
+# CBOR breakout:
+#
+# CONTROL  TNVC    PARM TYPES       PARM1    PARM2         PARM3
+#          TYPE
+# add_var   TV    (ARI,EXPR,BYTE)   (V1)     (UINT) 0      UINT
+# c1154100  05     03 24 26 11     0c427635 14814300        14
+#
 #------------------------------------------------------------------------------
-c11541005585054324261145ac01410501464514814243004114
+c115410005032426110c4276351481430014
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.2: Retrieve value of V5 in a report.
 #------------------------------------------------------------------------------
-c11541054f8405422523478145ac014105014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v5],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763500
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.3: Confirm value of V5 is 0.
 #------------------------------------------------------------------------------
@@ -30,16 +51,25 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.4: Define Macro M1 generate an agent FULL_REPORT and reset V5 = 0
 #------------------------------------------------------------------------------
-# Macro = [genRpt([FULL_REPORT], 0), Store(V5, 0)]
-# M1 ARI = 0xa401410501
+#
+# Macro M1 ARI: 0x04424d31
+# 
+# ARI: ari:/IANA:amp.agent/Ctrl.add_macro("m1", ari://Mac.M1, 
+#      [ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[]),
+#       ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v5, (UINT)0)])
+#
 #------------------------------------------------------------------------------
-c115410758418505431224254463746d7045a401410501582e8254c11541054f84054225234781458718194100418057c115410e52840542242645ac0141050146451481424300
+c11541070503122425626d3104424d3182c11541050502252381871819410000c115410e050224260c42763514814300
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 1.5: List Macros 
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41034180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.macros()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410300
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -49,7 +79,11 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.7: Describe Macro M1
 #------------------------------------------------------------------------------
-c11541094c83054125478145a401410501
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_macro([ari://Mac.M1])
+#
+#------------------------------------------------------------------------------
+c11541090501258104424d31
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -59,20 +93,31 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.9: Define SRL S1 to run every time V5 >= 2 up to 3 times. 
 #------------------------------------------------------------------------------
-# A1 ARI = 0xa801410101
+#
+# S1 ARI = 0x08425331
 # Start = 0
 # Expr = [V5, 2, >=]
 # MaxEval = 1000
 # Count = 3
 # Action = [M1]
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_sbr(ari://Sbr.S1, 0, 
+#       (UINT) ari://Var.v5 2 >=, 1000, 3, [ari://Mac.M1], "S1")
+#
 #------------------------------------------------------------------------------
-c115410b583a8905472416261616251245a80141010141005554148345ac0141050142430248c5181842182f4180431903e84103478145a40141050143625331
+c115410b050724162616162512084253310014830c4276354302c5181842182f001903e8038104424d31625331
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 1.10: List known rules
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41044180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410400
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -82,7 +127,11 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.12: Describe SRL1
 #------------------------------------------------------------------------------
-c115410d4c83054125478145a801410101
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_rule([ari://Sbr.S1])
+#
+#------------------------------------------------------------------------------
+c115410d0501258108425331
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -93,19 +142,30 @@ WAIT 1
 # Step 1.14: Set TBR T1 to run every 20 seconds 6 times that will
 # run the command: V5 = V5 + 1 which is: STOR(V5, {(UINT), V5 1 +})
 #------------------------------------------------------------------------------
-# T5 ARI = 0xab01410501
-# T5 Start = 0
-# T5 Period = 20
-# T5 Count = 6
+#
+# T1 ARI = 0x0b425431 
+# T1 Start = 0
+# T1 Period = 20
+# T1 Count = 6
+# T1 Action: ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v5, (UINT) ari://var.v5 1 +)
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_tbr(ari://tbr.T1, 0, 20, 6, 
+#      [ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v5, (UINT) ari://var.v5 1 +)], "T1")
+#
 #------------------------------------------------------------------------------
-c115410a584488054624161616251245ab014105014100411441065829815826c115410e5820840542242645ac014105015453148345ac0141050142430147c518184101418043625435
+c115410a05062416161625120b42543100140681c115410e050224260c42763514830c4276354301c51818410100625431
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 1.15: Describe T1 and make sure it is correct.
 #------------------------------------------------------------------------------
-
-c115410d4c83054125478145ab01410501
+#
+# ARI ari:/IANA:amp.agent/Ctrl.desc_rule([ari://Tbr.T1])
+#
+#------------------------------------------------------------------------------
+c115410d050125810b425431
 WAIT 1
 
 #------------------------------------------------------------------------------
@@ -121,17 +181,29 @@ WAIT 170
 #------------------------------------------------------------------------------
 # Step 1.18: List known rules and verify S1 and T1 are no longer listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41044180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410400
 WAIT 1
 
+
 #------------------------------------------------------------------------------
-# Step 1.19: Delete S1. i.e. show no issue with deleting a deleted SBR
+# Step 1.19: Delete S1. i.e. show no issue with deleting a deleted SBR.
+#            Expect to see the following in Agent output:
+#            "[nm/agent/adm_amp_agent_impl.c:1946] 
+#            w DEL_RULE Cannot find RULE to be deleted."
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_rule([ari://Sbr.S1])
+#
 #------------------------------------------------------------------------------
-c115410c4c83054125478145a801410101
+c115410c0501258108425331
 WAIT 1
 
 
 #------------------------------------------------------------------------------
 # Step 1.20: Restart Agent and verify only 1 Var and 1 Macro restore.
-#------------------------------------------------------------------------------
-
+#------------------------------------------------------------------------------
\ No newline at end of file
diff --git a/nm/test/tbr.txt b/nm/test/tbr.txt
index f7bef735..225ba14d 100644
--- a/nm/test/tbr.txt
+++ b/nm/test/tbr.txt
@@ -1,8 +1,10 @@
-# Test Set 3: Time-Based Rule Production.
+# Test Set 4: Time-Based Rule Production.
 #
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
 
 ###############################################################################
-# TC 3.1 Generate Reports to a schedule.
+# TC 4.1 Generate Reports to a schedule.
 ###############################################################################
 # This test will cause an AGENT FULL report to be generated
 # 5 times at intervals of 5 seconds each.
@@ -11,20 +13,26 @@
 
 
 #------------------------------------------------------------------------------
-# Step 3.1.1: Build the TBR to report on the AGENT Full Report.
-# NN: 1, ISS: 1, Name: 1
+# Step 4.1.1: Build the TBR to report on the AGENT Full Report.
 #------------------------------------------------------------------------------
-# NOTE: The TRL will have an ID of: 0xab01410101
+#
+# NOTE: The TBR will be identified as "ari://Tbr.1" which is 0x0b4131
 # START: 0
 # PERIOD: 5
 # COUNT: 5
 # Action: {GEN_RPT({FULL_REPORT}, 0)}
+# Description: TBR1
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:AMP.AGENT/CTRL.ADD_TBR(ari://Tbr.1, 0, 5, 5, [ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])], TBR1)
+#
 #------------------------------------------------------------------------------
-c115410a583588054624161616251245ab01410101410041054105568154c11541054f840542252347814587181941004180486747656e52707473
+c115410a05062420201625120b413100050581c11541050502252381871819410000682018544252312019
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 3.1.2: Verify that 5 reports are received approximately 
+# Step 4.1.2: Verify that 5 reports are received approximately 
 # 5 seconds apart (variance up to 1 second between individual reports
 # are within tolerance due to the 1Hz rate of the agent autonomy
 # engine. 
@@ -34,90 +42,152 @@ WAIT 30
  
 
 ###############################################################################
-# TC 3.2: Manipulate TBRs.
+# TC 4.2: Manipulate TBRs.
 ###############################################################################
 # Interrupt a running TBR
 ###############################################################################
 
 #------------------------------------------------------------------------------
-# Step 3.2.1: Define a TRL that will generate an AGENT FULL REPORT every 30
-# seconds 100 times.
+# Step 4.2.1: Define a TBR  (TBR 2) that will generate an AGENT FULL REPORT 
+# every 30 seconds 100 times.
 #------------------------------------------------------------------------------
-# TBR 2 will have an Id of: 0xab01410201
+#
+# NOTE: The TBR will be identified as "ari://Tbr.2" which is 0x0b4132
+# START: 0
+# PERIOD: 30
+# COUNT: 100
+# Action: {GEN_RPT({FULL_REPORT}, 0)}
+# Description: TBR2
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:AMP.AGENT/CTRL.ADD_TBR(ari://Tbr.2, 0, 30, 100, 
+#         [ari:/IANA:amp.agent/Ctrl.gen_rpts([ari:/IANA:amp.agent/Rptt.full_report()],[])], TBR2)
+#
 #------------------------------------------------------------------------------
-c115410a583488054624161616251245ab01410201410042181e421864568154c11541054f840542252347814587181941004180456454425232
+c115410a05062420201625120b413200181e186481c11541050502252381871819410000682018544252322019
 WAIT 1
 
 
 #------------------------------------------------------------------------------
-# Step 3.2.2: List TBRs on the agent. 
+# Step 4.2.2: List TBRs on the agent. 
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])
+#
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41044180
+c115410605022523818a181b410400
 WAIT 1
 
 
 #------------------------------------------------------------------------------
-# Step 3.2.3: Verify TBR 2 is listed in the report.
+# Step 4.2.3: Verify TBR 2 is listed in the reported rules.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 3.2.4: Describe TBR 2.
+# Step 4.2.4: Describe TBR 2.
 #------------------------------------------------------------------------------
-c115410d4c83054125478145ab01410201
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_rule([ari://Tbr.2])
+#
+#------------------------------------------------------------------------------
+c115410d050125810b4132
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 3.2.5: Verify the description matches the definition.
+# Step 4.2.5: Verify the description matches the definition.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 3.2.6: Delete the TRL.
+# Step 4.2.6: Delete TBR 2.
 #------------------------------------------------------------------------------
-c115410c4c83054125478145ab01410201
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_rule([ari://TBR.2])
+#
+#------------------------------------------------------------------------------
+c115410c050125810b4132
 WAIT 1
 
 
 #------------------------------------------------------------------------------
-# Step 3.2.7: Verify no reports received after TRL deleted.
+# Step 4.2.7: Verify no reports received after TRL deleted.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 3.2.8: List TBRs on the agent.
+# Step 4.2.8: List TBRs on the agent.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41044180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.rules()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410400
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 3.2.9: Verify TBR2 not shown in list.
+# Step 4.2.9: Verify TBR2 not shown in list.
 #------------------------------------------------------------------------------
 
 #------------------------------------------------------------------------------
-# Step 3.2.10: Describe TBR 2 from the agent.
+# Step 4.2.10: Describe TBR 2 from the agent.
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.desc_rule([ari://TBR.2])
+#
 #------------------------------------------------------------------------------
-c115410d4c83054125478145ab01410201
+c115410d050125810b4132
 WAIT 1
 
 #------------------------------------------------------------------------------
-# Step 3.2.11: Verify TBR not there to be described.
+# Step 4.2.11: Verify TBR not there to be described.
 #------------------------------------------------------------------------------
 
 
 ###############################################################################
-# TC 3.3: Run parameterized macro by TBR
+# TC 4.3: Run macro by TBR
 ###############################################################################
 # 
 ###############################################################################
 
 #------------------------------------------------------------------------------
-# Step 3.3.1: Define TBR T7 to run Agent Macro USER_DESC 1 time wither period 5.
+# Step 4.3.1: Create a Macro that generates a BP full report.
+#
+# Type: Macro (mac)
+# Name: bp_full_rpt_macro
+# Macro ARI: ari://Mac.bp_full_rpt_macro
+# CBOR Macro ARI: 0x045162705f66756c6c5f7270745f6d6163726f
+#
 #------------------------------------------------------------------------------
-# T7 ARI: 0xab01410701
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.add_macro("bp_full_rpt_macro", 
+#        ari://Mac.bp_full_rpt_macro, [ari:/IANA:amp.agent/Ctrl.gen_rpts(
+#         [ari:/IANA:dtn.bp_agent/Rptt.full_report()], [])])
+#
 #------------------------------------------------------------------------------
-c115410a583888054624161616251245ab01410701410041014101581d81581ac41741005584054225254781458718194100478145ab0141070143625437
+c11541070503122425732262705f66756c6c5f7270745f6d6163726f22045162705f66756c6c5f7270745f6d6163726f81c1154105050225238187182d410000
 WAIT 1
 
+
 #------------------------------------------------------------------------------
-# Step 3.3.2: Read the returned report and make sure parms were correct.
+# Step 4.3.2: Define TBR T7 to run Agent Macro bp_full_rpt_macro 1 time with 
+#             period 5.
 #------------------------------------------------------------------------------
+#
+# NOTE: The TBR will be identified as "ari://Tbr.7" which is 0x0b4137
+# START: 0
+# PERIOD: 5
+# COUNT: 1
+# Action: {bp_full_rpt_macro}
+# Description: TBR7
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:AMP.AGENT/CTRL.ADD_TBR(ari://Tbr.7, 0, 5, 1, 
+#        [ari://Mac.bp_full_rpt_macro], TBR7)
+#
+#------------------------------------------------------------------------------
+c115410a05062420201625120b413700050181045162705f66756c6c5f7270745f6d6163726f682018544252372019
+WAIT 1
 
-
+#------------------------------------------------------------------------------
+# Step 4.3.2: Read the returned report and make sure parms were correct.
+#------------------------------------------------------------------------------
\ No newline at end of file
diff --git a/nm/test/var.txt b/nm/test/var.txt
index eff8035b..725f9103 100644
--- a/nm/test/var.txt
+++ b/nm/test/var.txt
@@ -1,5 +1,7 @@
 # Test Set 2: Variables
 #
+# Assume nm_mgr is on ipn:1.1
+# Assume nm_agent is on ipn:1.2
 
 ###############################################################################
 # TC 1 Test Basic Variable Operations
@@ -11,24 +13,54 @@
 #------------------------------------------------------------------------------
 # Step 1.1: Define UINT V1 as "2 + 2"
 #------------------------------------------------------------------------------
-# Note: V1 ARI will be 0x8c18644101 
+# 
+# ARI: ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v1, (UINT) 2 2 +, UINT)
+#
 #------------------------------------------------------------------------------
-c11541005820850543242611458c186441015150148342430242430247c51818410141804114
+# 
+# V1 ARI: ari://var.v1
+# V1 encoding: 0x0c427631
+#
+# CBOR breakout:
+#
+# CONTROL  TNVC    PARM TYPES       PARM1    PARM2                     PARM3
+#          TYPE
+# add_var   TV    (ARI,EXPR,BYTE)   (V1)     (UINT) 2, 2, +            UINT
+# c1154100  05     03 24 26 11     0c427631 148343024302c51818410100   14
+#------------------------------------------------------------------------------
+c115410005032426110c427631148343024302c5181841010014
 WAIT 1
 
+
+
 #------------------------------------------------------------------------------
 # Step 1.2: List VARs on the agent and confirm that V1 is listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41014180
+#
+# V1 ARI: ari://var.v1
+# V1 encoding: 0x0c427631
+#
+#------------------------------------------------------------------------------
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410100
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.3: Generate a report for V1 and confirm it has value UINT 4
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c186441014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763100
 WAIT 1
 
 
+
 #------------------------------------------------------------------------------
 # Step 1.4: Restart the Agent. 
 #------------------------------------------------------------------------------
@@ -37,35 +69,60 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.5: List VARs on the agent and confirm that V1 is still listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410100
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.6: Generate a report for V1 and confirm it still has value UINT 4
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c186441014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763100
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 1.7 Delete V1
 #------------------------------------------------------------------------------
-c11541014c830541254781458c18644101
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.del_var([ari://var.v1])
+#
+#------------------------------------------------------------------------------
+c1154101050125810c427631
 WAIT 1
 
 
 #------------------------------------------------------------------------------
 # Step 1.8: List VARs on the agent and confirm that V1 is NOT listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410100
 WAIT 1
 
+
+
 #------------------------------------------------------------------------------
 # Step 1.9: Generate a report for V1 and confirm it is not reported.
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c186441014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763100
 WAIT 1
 
 
+
 #------------------------------------------------------------------------------
 # Step 1.10: Restart the Agent. 
 #------------------------------------------------------------------------------
@@ -74,18 +131,28 @@ WAIT 1
 #------------------------------------------------------------------------------
 # Step 1.11: List VARs on the agent and confirm that V1 is NOT listed.
 #------------------------------------------------------------------------------
-c11541064f84054225234781458a181b41014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_tbls([ari:/IANA:amp.agent/Tblt.variables()],[])
+#
+#------------------------------------------------------------------------------
+c115410605022523818a181b410100
 WAIT 1
 
 
+
 #------------------------------------------------------------------------------
 # Step 1.12: Generate a report for V1 and confirm it is not reported.
 #------------------------------------------------------------------------------
-c11541054f84054225234781458c186441014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://var.v1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810c42763100
 WAIT 1
 
 
 
+
 ###############################################################################
 # Test Case 2.2: Complex Variables
 ###############################################################################
@@ -95,63 +162,103 @@ WAIT 1
 # V2 = V4;             // Test that V2 = 5.
 # V4 = eval(V3);       // Test that V4 = 6.
 #
-# V2 ARI = 0xac01410201
-# V3 ARI = 0xac01410301
-# V4 ARI = 0xac01410401
+# V2 ARI = 0x0c427632             
+# V3 ARI = 0x0c427633
+# V4 ARI = 0x0c427634
 ###############################################################################
 
 #------------------------------------------------------------------------------
 # Step 2.2.1: Define UINT V2 as "4"
 #------------------------------------------------------------------------------
-c11541005585054324261145ac01410201464514814243044114
+#
+# ARI: ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v2, (UINT) 4, UINT)
+#
+#------------------------------------------------------------------------------
+c115410005032426110c4276321481430414
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.2: Define EXPR V3 as "V2 + 1"
 #------------------------------------------------------------------------------
-# EXPR = [UINT, [V3, 1, plusUINT]]
+#
+# ARI: ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v3, (UINT) ari://var.v2 1 +, EXPR)
+#
+#------------------------------------------------------------------------------
+#
+# CBOR breakout:
+#
+# CONTROL  TNVC    PARM TYPES       PARM1    PARM2                        PARM3
+#          TYPE
+# add_var   TV    (ARI,EXPR,BYTE)   (V3)     (UINT) v2, 1, +              EXPR
+# c1154100  05     03 24 26 11    0c427633  14830c4276324301c51818410100   26
 #------------------------------------------------------------------------------
-c1154100582385054324261145ac014103015453148345ac0141020142430147c51818410141804126
+c115410005032426110c42763314830c4276324301c5181841010026
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.3: Define UINT V4 as having an initializing expression of {V3}
 #------------------------------------------------------------------------------
-c1154100581885054324261145ac014104014948148145ac014103014114
+#
+# ARI:  ari:/IANA:Amp.Agent/Ctrl.add_var(ari://var.v4, UINT ari://var.v3, UINT)
+#
+#------------------------------------------------------------------------------
+c115410005032426110c42763414810c42763314
 WAIT 1
 
 #------------------------------------------------------------------------------
 # Step 2.2.4: Define custom report R1 = {V2, V3, V4}
 #------------------------------------------------------------------------------
-# R1 ARI = 0xa701410501
+#
+# R1 ARI = 0x07427231
+#
+# ARI: ari:/IANA:Amp.Agent/Ctrl.add_rptt(ari://rptt.r1, [ari://var.v2, ari://var.v3, ari://var.v4])
+#
 #------------------------------------------------------------------------------
-c1154102581f840542242545a701410501538345ac0141020145ac0141030145ac01410401
+c11541020502242507427231830c4276320c4276330c427634
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.5: Generate Report R1 and verify values are {4,EXPR,5}
 #------------------------------------------------------------------------------
-c11541054f8405422523478145a7014105014180
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://rptt.r1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810742723100
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.6: STORE(V2, V4)  - V2 = V4
 #------------------------------------------------------------------------------
-c115410e55840542242645ac014102014948148145ac01410401
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v2, (UINT) ari://var.v4)
+#
+#------------------------------------------------------------------------------
+c115410e050224260c42763214810c427634
 WAIT 1
 
+
 #------------------------------------------------------------------------------
 # Step 2.2.7: STORE(V4, V3) - V4 = expr_eval(V3)
 #------------------------------------------------------------------------------
-c115410e55840542242645ac014104014948148145ac01410301
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.store_var(ari://var.v4, ari://var.v3)
+#
+#------------------------------------------------------------------------------
+c115410e050224260c42763414810c427633
 WAIT 1
 
 
 #------------------------------------------------------------------------------
 # Step 2.2.8: Generate Report R1 and verify values are {5,EXPR,6}
 #------------------------------------------------------------------------------
-c11541054f8405422523478145a7014105014180
-WAIT 1
-
-
-
+#
+# ARI: ari:/IANA:amp.agent/Ctrl.gen_rpts([ari://rptt.r1],[])
+#
+#------------------------------------------------------------------------------
+c115410505022523810742723100
+WAIT 1
\ No newline at end of file
